
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model apiclient
 * 
 */
export type apiclient = $Result.DefaultSelection<Prisma.$apiclientPayload>
/**
 * Model refreshtoken
 * 
 */
export type refreshtoken = $Result.DefaultSelection<Prisma.$refreshtokenPayload>
/**
 * Model revokedtoken
 * 
 */
export type revokedtoken = $Result.DefaultSelection<Prisma.$revokedtokenPayload>
/**
 * Model role
 * 
 */
export type role = $Result.DefaultSelection<Prisma.$rolePayload>
/**
 * Model notification
 * 
 */
export type notification = $Result.DefaultSelection<Prisma.$notificationPayload>
/**
 * Model permission
 * 
 */
export type permission = $Result.DefaultSelection<Prisma.$permissionPayload>
/**
 * Model rolepermission
 * 
 */
export type rolepermission = $Result.DefaultSelection<Prisma.$rolepermissionPayload>
/**
 * Model transaction
 * 
 */
export type transaction = $Result.DefaultSelection<Prisma.$transactionPayload>
/**
 * Model entrance
 * 
 */
export type entrance = $Result.DefaultSelection<Prisma.$entrancePayload>
/**
 * Model userpermission
 * 
 */
export type userpermission = $Result.DefaultSelection<Prisma.$userpermissionPayload>
/**
 * Model userrole
 * 
 */
export type userrole = $Result.DefaultSelection<Prisma.$userrolePayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model plan
 * 
 */
export type plan = $Result.DefaultSelection<Prisma.$planPayload>
/**
 * Model subscription
 * 
 */
export type subscription = $Result.DefaultSelection<Prisma.$subscriptionPayload>
/**
 * Model customer
 * 
 */
export type customer = $Result.DefaultSelection<Prisma.$customerPayload>
/**
 * Model invoice
 * 
 */
export type invoice = $Result.DefaultSelection<Prisma.$invoicePayload>
/**
 * Model payment
 * 
 */
export type payment = $Result.DefaultSelection<Prisma.$paymentPayload>
/**
 * Model parameters
 * 
 */
export type parameters = $Result.DefaultSelection<Prisma.$parametersPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PaymentStatus: {
  pending: 'pending',
  completed: 'completed',
  failed: 'failed'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const NotificationType: {
  SYSTEM: 'SYSTEM',
  USER: 'USER',
  WARNING: 'WARNING',
  ERROR: 'ERROR',
  INFO: 'INFO'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const TransactionType: {
  LOGIN: 'LOGIN',
  LOGOUT: 'LOGOUT',
  PAYMENT: 'PAYMENT',
  REFUND: 'REFUND',
  NOTIFICATION: 'NOTIFICATION'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]

}

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Apiclients
 * const apiclients = await prisma.apiclient.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Apiclients
   * const apiclients = await prisma.apiclient.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.apiclient`: Exposes CRUD operations for the **apiclient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Apiclients
    * const apiclients = await prisma.apiclient.findMany()
    * ```
    */
  get apiclient(): Prisma.apiclientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshtoken`: Exposes CRUD operations for the **refreshtoken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Refreshtokens
    * const refreshtokens = await prisma.refreshtoken.findMany()
    * ```
    */
  get refreshtoken(): Prisma.refreshtokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.revokedtoken`: Exposes CRUD operations for the **revokedtoken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Revokedtokens
    * const revokedtokens = await prisma.revokedtoken.findMany()
    * ```
    */
  get revokedtoken(): Prisma.revokedtokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.roleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.notificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.permissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolepermission`: Exposes CRUD operations for the **rolepermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rolepermissions
    * const rolepermissions = await prisma.rolepermission.findMany()
    * ```
    */
  get rolepermission(): Prisma.rolepermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.transactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.entrance`: Exposes CRUD operations for the **entrance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entrances
    * const entrances = await prisma.entrance.findMany()
    * ```
    */
  get entrance(): Prisma.entranceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userpermission`: Exposes CRUD operations for the **userpermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Userpermissions
    * const userpermissions = await prisma.userpermission.findMany()
    * ```
    */
  get userpermission(): Prisma.userpermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userrole`: Exposes CRUD operations for the **userrole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Userroles
    * const userroles = await prisma.userrole.findMany()
    * ```
    */
  get userrole(): Prisma.userroleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.planDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.subscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.customerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.invoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.paymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parameters`: Exposes CRUD operations for the **parameters** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parameters
    * const parameters = await prisma.parameters.findMany()
    * ```
    */
  get parameters(): Prisma.parametersDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    apiclient: 'apiclient',
    refreshtoken: 'refreshtoken',
    revokedtoken: 'revokedtoken',
    role: 'role',
    notification: 'notification',
    permission: 'permission',
    rolepermission: 'rolepermission',
    transaction: 'transaction',
    entrance: 'entrance',
    userpermission: 'userpermission',
    userrole: 'userrole',
    user: 'user',
    plan: 'plan',
    subscription: 'subscription',
    customer: 'customer',
    invoice: 'invoice',
    payment: 'payment',
    parameters: 'parameters'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "apiclient" | "refreshtoken" | "revokedtoken" | "role" | "notification" | "permission" | "rolepermission" | "transaction" | "entrance" | "userpermission" | "userrole" | "user" | "plan" | "subscription" | "customer" | "invoice" | "payment" | "parameters"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      apiclient: {
        payload: Prisma.$apiclientPayload<ExtArgs>
        fields: Prisma.apiclientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.apiclientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apiclientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.apiclientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apiclientPayload>
          }
          findFirst: {
            args: Prisma.apiclientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apiclientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.apiclientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apiclientPayload>
          }
          findMany: {
            args: Prisma.apiclientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apiclientPayload>[]
          }
          create: {
            args: Prisma.apiclientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apiclientPayload>
          }
          createMany: {
            args: Prisma.apiclientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.apiclientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apiclientPayload>[]
          }
          delete: {
            args: Prisma.apiclientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apiclientPayload>
          }
          update: {
            args: Prisma.apiclientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apiclientPayload>
          }
          deleteMany: {
            args: Prisma.apiclientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.apiclientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.apiclientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apiclientPayload>[]
          }
          upsert: {
            args: Prisma.apiclientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apiclientPayload>
          }
          aggregate: {
            args: Prisma.ApiclientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiclient>
          }
          groupBy: {
            args: Prisma.apiclientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiclientGroupByOutputType>[]
          }
          count: {
            args: Prisma.apiclientCountArgs<ExtArgs>
            result: $Utils.Optional<ApiclientCountAggregateOutputType> | number
          }
        }
      }
      refreshtoken: {
        payload: Prisma.$refreshtokenPayload<ExtArgs>
        fields: Prisma.refreshtokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.refreshtokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.refreshtokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>
          }
          findFirst: {
            args: Prisma.refreshtokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.refreshtokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>
          }
          findMany: {
            args: Prisma.refreshtokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>[]
          }
          create: {
            args: Prisma.refreshtokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>
          }
          createMany: {
            args: Prisma.refreshtokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.refreshtokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>[]
          }
          delete: {
            args: Prisma.refreshtokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>
          }
          update: {
            args: Prisma.refreshtokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>
          }
          deleteMany: {
            args: Prisma.refreshtokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.refreshtokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.refreshtokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>[]
          }
          upsert: {
            args: Prisma.refreshtokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshtokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshtoken>
          }
          groupBy: {
            args: Prisma.refreshtokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshtokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.refreshtokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshtokenCountAggregateOutputType> | number
          }
        }
      }
      revokedtoken: {
        payload: Prisma.$revokedtokenPayload<ExtArgs>
        fields: Prisma.revokedtokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.revokedtokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$revokedtokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.revokedtokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$revokedtokenPayload>
          }
          findFirst: {
            args: Prisma.revokedtokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$revokedtokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.revokedtokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$revokedtokenPayload>
          }
          findMany: {
            args: Prisma.revokedtokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$revokedtokenPayload>[]
          }
          create: {
            args: Prisma.revokedtokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$revokedtokenPayload>
          }
          createMany: {
            args: Prisma.revokedtokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.revokedtokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$revokedtokenPayload>[]
          }
          delete: {
            args: Prisma.revokedtokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$revokedtokenPayload>
          }
          update: {
            args: Prisma.revokedtokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$revokedtokenPayload>
          }
          deleteMany: {
            args: Prisma.revokedtokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.revokedtokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.revokedtokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$revokedtokenPayload>[]
          }
          upsert: {
            args: Prisma.revokedtokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$revokedtokenPayload>
          }
          aggregate: {
            args: Prisma.RevokedtokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRevokedtoken>
          }
          groupBy: {
            args: Prisma.revokedtokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RevokedtokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.revokedtokenCountArgs<ExtArgs>
            result: $Utils.Optional<RevokedtokenCountAggregateOutputType> | number
          }
        }
      }
      role: {
        payload: Prisma.$rolePayload<ExtArgs>
        fields: Prisma.roleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.roleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.roleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          findFirst: {
            args: Prisma.roleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.roleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          findMany: {
            args: Prisma.roleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[]
          }
          create: {
            args: Prisma.roleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          createMany: {
            args: Prisma.roleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.roleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[]
          }
          delete: {
            args: Prisma.roleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          update: {
            args: Prisma.roleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          deleteMany: {
            args: Prisma.roleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.roleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.roleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[]
          }
          upsert: {
            args: Prisma.roleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.roleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.roleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      notification: {
        payload: Prisma.$notificationPayload<ExtArgs>
        fields: Prisma.notificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          findFirst: {
            args: Prisma.notificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          findMany: {
            args: Prisma.notificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>[]
          }
          create: {
            args: Prisma.notificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          createMany: {
            args: Prisma.notificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>[]
          }
          delete: {
            args: Prisma.notificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          update: {
            args: Prisma.notificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          deleteMany: {
            args: Prisma.notificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>[]
          }
          upsert: {
            args: Prisma.notificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.notificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      permission: {
        payload: Prisma.$permissionPayload<ExtArgs>
        fields: Prisma.permissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.permissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.permissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          findFirst: {
            args: Prisma.permissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.permissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          findMany: {
            args: Prisma.permissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>[]
          }
          create: {
            args: Prisma.permissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          createMany: {
            args: Prisma.permissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.permissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>[]
          }
          delete: {
            args: Prisma.permissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          update: {
            args: Prisma.permissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          deleteMany: {
            args: Prisma.permissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.permissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.permissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>[]
          }
          upsert: {
            args: Prisma.permissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.permissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.permissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      rolepermission: {
        payload: Prisma.$rolepermissionPayload<ExtArgs>
        fields: Prisma.rolepermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rolepermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolepermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolepermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolepermissionPayload>
          }
          findFirst: {
            args: Prisma.rolepermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolepermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolepermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolepermissionPayload>
          }
          findMany: {
            args: Prisma.rolepermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolepermissionPayload>[]
          }
          create: {
            args: Prisma.rolepermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolepermissionPayload>
          }
          createMany: {
            args: Prisma.rolepermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.rolepermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolepermissionPayload>[]
          }
          delete: {
            args: Prisma.rolepermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolepermissionPayload>
          }
          update: {
            args: Prisma.rolepermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolepermissionPayload>
          }
          deleteMany: {
            args: Prisma.rolepermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rolepermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.rolepermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolepermissionPayload>[]
          }
          upsert: {
            args: Prisma.rolepermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolepermissionPayload>
          }
          aggregate: {
            args: Prisma.RolepermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolepermission>
          }
          groupBy: {
            args: Prisma.rolepermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolepermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.rolepermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolepermissionCountAggregateOutputType> | number
          }
        }
      }
      transaction: {
        payload: Prisma.$transactionPayload<ExtArgs>
        fields: Prisma.transactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          findFirst: {
            args: Prisma.transactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          findMany: {
            args: Prisma.transactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>[]
          }
          create: {
            args: Prisma.transactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          createMany: {
            args: Prisma.transactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.transactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>[]
          }
          delete: {
            args: Prisma.transactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          update: {
            args: Prisma.transactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          deleteMany: {
            args: Prisma.transactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.transactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>[]
          }
          upsert: {
            args: Prisma.transactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.transactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.transactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      entrance: {
        payload: Prisma.$entrancePayload<ExtArgs>
        fields: Prisma.entranceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.entranceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entrancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.entranceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entrancePayload>
          }
          findFirst: {
            args: Prisma.entranceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entrancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.entranceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entrancePayload>
          }
          findMany: {
            args: Prisma.entranceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entrancePayload>[]
          }
          create: {
            args: Prisma.entranceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entrancePayload>
          }
          createMany: {
            args: Prisma.entranceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.entranceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entrancePayload>[]
          }
          delete: {
            args: Prisma.entranceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entrancePayload>
          }
          update: {
            args: Prisma.entranceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entrancePayload>
          }
          deleteMany: {
            args: Prisma.entranceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.entranceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.entranceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entrancePayload>[]
          }
          upsert: {
            args: Prisma.entranceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entrancePayload>
          }
          aggregate: {
            args: Prisma.EntranceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEntrance>
          }
          groupBy: {
            args: Prisma.entranceGroupByArgs<ExtArgs>
            result: $Utils.Optional<EntranceGroupByOutputType>[]
          }
          count: {
            args: Prisma.entranceCountArgs<ExtArgs>
            result: $Utils.Optional<EntranceCountAggregateOutputType> | number
          }
        }
      }
      userpermission: {
        payload: Prisma.$userpermissionPayload<ExtArgs>
        fields: Prisma.userpermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userpermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userpermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userpermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userpermissionPayload>
          }
          findFirst: {
            args: Prisma.userpermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userpermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userpermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userpermissionPayload>
          }
          findMany: {
            args: Prisma.userpermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userpermissionPayload>[]
          }
          create: {
            args: Prisma.userpermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userpermissionPayload>
          }
          createMany: {
            args: Prisma.userpermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userpermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userpermissionPayload>[]
          }
          delete: {
            args: Prisma.userpermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userpermissionPayload>
          }
          update: {
            args: Prisma.userpermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userpermissionPayload>
          }
          deleteMany: {
            args: Prisma.userpermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userpermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userpermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userpermissionPayload>[]
          }
          upsert: {
            args: Prisma.userpermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userpermissionPayload>
          }
          aggregate: {
            args: Prisma.UserpermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserpermission>
          }
          groupBy: {
            args: Prisma.userpermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserpermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.userpermissionCountArgs<ExtArgs>
            result: $Utils.Optional<UserpermissionCountAggregateOutputType> | number
          }
        }
      }
      userrole: {
        payload: Prisma.$userrolePayload<ExtArgs>
        fields: Prisma.userroleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userroleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userroleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          findFirst: {
            args: Prisma.userroleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userroleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          findMany: {
            args: Prisma.userroleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>[]
          }
          create: {
            args: Prisma.userroleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          createMany: {
            args: Prisma.userroleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userroleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>[]
          }
          delete: {
            args: Prisma.userroleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          update: {
            args: Prisma.userroleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          deleteMany: {
            args: Prisma.userroleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userroleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userroleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>[]
          }
          upsert: {
            args: Prisma.userroleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          aggregate: {
            args: Prisma.UserroleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserrole>
          }
          groupBy: {
            args: Prisma.userroleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserroleGroupByOutputType>[]
          }
          count: {
            args: Prisma.userroleCountArgs<ExtArgs>
            result: $Utils.Optional<UserroleCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      plan: {
        payload: Prisma.$planPayload<ExtArgs>
        fields: Prisma.planFieldRefs
        operations: {
          findUnique: {
            args: Prisma.planFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.planFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planPayload>
          }
          findFirst: {
            args: Prisma.planFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.planFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planPayload>
          }
          findMany: {
            args: Prisma.planFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planPayload>[]
          }
          create: {
            args: Prisma.planCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planPayload>
          }
          createMany: {
            args: Prisma.planCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.planCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planPayload>[]
          }
          delete: {
            args: Prisma.planDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planPayload>
          }
          update: {
            args: Prisma.planUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planPayload>
          }
          deleteMany: {
            args: Prisma.planDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.planUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.planUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planPayload>[]
          }
          upsert: {
            args: Prisma.planUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planPayload>
          }
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan>
          }
          groupBy: {
            args: Prisma.planGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.planCountArgs<ExtArgs>
            result: $Utils.Optional<PlanCountAggregateOutputType> | number
          }
        }
      }
      subscription: {
        payload: Prisma.$subscriptionPayload<ExtArgs>
        fields: Prisma.subscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.subscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.subscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          findFirst: {
            args: Prisma.subscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.subscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          findMany: {
            args: Prisma.subscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>[]
          }
          create: {
            args: Prisma.subscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          createMany: {
            args: Prisma.subscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.subscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>[]
          }
          delete: {
            args: Prisma.subscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          update: {
            args: Prisma.subscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          deleteMany: {
            args: Prisma.subscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.subscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.subscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>[]
          }
          upsert: {
            args: Prisma.subscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.subscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.subscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      customer: {
        payload: Prisma.$customerPayload<ExtArgs>
        fields: Prisma.customerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          findFirst: {
            args: Prisma.customerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          findMany: {
            args: Prisma.customerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>[]
          }
          create: {
            args: Prisma.customerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          createMany: {
            args: Prisma.customerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.customerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>[]
          }
          delete: {
            args: Prisma.customerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          update: {
            args: Prisma.customerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          deleteMany: {
            args: Prisma.customerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.customerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.customerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>[]
          }
          upsert: {
            args: Prisma.customerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.customerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.customerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      invoice: {
        payload: Prisma.$invoicePayload<ExtArgs>
        fields: Prisma.invoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload>
          }
          findFirst: {
            args: Prisma.invoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload>
          }
          findMany: {
            args: Prisma.invoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload>[]
          }
          create: {
            args: Prisma.invoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload>
          }
          createMany: {
            args: Prisma.invoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.invoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload>[]
          }
          delete: {
            args: Prisma.invoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload>
          }
          update: {
            args: Prisma.invoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload>
          }
          deleteMany: {
            args: Prisma.invoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.invoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.invoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload>[]
          }
          upsert: {
            args: Prisma.invoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.invoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.invoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      payment: {
        payload: Prisma.$paymentPayload<ExtArgs>
        fields: Prisma.paymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          findFirst: {
            args: Prisma.paymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          findMany: {
            args: Prisma.paymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>[]
          }
          create: {
            args: Prisma.paymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          createMany: {
            args: Prisma.paymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>[]
          }
          delete: {
            args: Prisma.paymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          update: {
            args: Prisma.paymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          deleteMany: {
            args: Prisma.paymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.paymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>[]
          }
          upsert: {
            args: Prisma.paymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.paymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      parameters: {
        payload: Prisma.$parametersPayload<ExtArgs>
        fields: Prisma.parametersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.parametersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parametersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.parametersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parametersPayload>
          }
          findFirst: {
            args: Prisma.parametersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parametersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.parametersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parametersPayload>
          }
          findMany: {
            args: Prisma.parametersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parametersPayload>[]
          }
          create: {
            args: Prisma.parametersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parametersPayload>
          }
          createMany: {
            args: Prisma.parametersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.parametersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parametersPayload>[]
          }
          delete: {
            args: Prisma.parametersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parametersPayload>
          }
          update: {
            args: Prisma.parametersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parametersPayload>
          }
          deleteMany: {
            args: Prisma.parametersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.parametersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.parametersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parametersPayload>[]
          }
          upsert: {
            args: Prisma.parametersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parametersPayload>
          }
          aggregate: {
            args: Prisma.ParametersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParameters>
          }
          groupBy: {
            args: Prisma.parametersGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParametersGroupByOutputType>[]
          }
          count: {
            args: Prisma.parametersCountArgs<ExtArgs>
            result: $Utils.Optional<ParametersCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    apiclient?: apiclientOmit
    refreshtoken?: refreshtokenOmit
    revokedtoken?: revokedtokenOmit
    role?: roleOmit
    notification?: notificationOmit
    permission?: permissionOmit
    rolepermission?: rolepermissionOmit
    transaction?: transactionOmit
    entrance?: entranceOmit
    userpermission?: userpermissionOmit
    userrole?: userroleOmit
    user?: userOmit
    plan?: planOmit
    subscription?: subscriptionOmit
    customer?: customerOmit
    invoice?: invoiceOmit
    payment?: paymentOmit
    parameters?: parametersOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    rolepermissions: number
    userroles: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolepermissions?: boolean | RoleCountOutputTypeCountRolepermissionsArgs
    userroles?: boolean | RoleCountOutputTypeCountUserrolesArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountRolepermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolepermissionWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserrolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userroleWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    rolepermissions: number
    userpermissions: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolepermissions?: boolean | PermissionCountOutputTypeCountRolepermissionsArgs
    userpermissions?: boolean | PermissionCountOutputTypeCountUserpermissionsArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolepermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolepermissionWhereInput
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountUserpermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userpermissionWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    invoices: number
    subscriptions: number
    customers: number
    parameters: number
    entrances: number
    payments: number
    transactions: number
    notificationuser: number
    createdapiclients: number
    updatedapiclients: number
    createdpermissions: number
    updatedpermissions: number
    refreshtokens: number
    createdroles: number
    updatedroles: number
    createdrolepermissions: number
    updatedrolepermissions: number
    createdusers: number
    updatedusers: number
    createduserpermissions: number
    updateduserpermissions: number
    userpermissions: number
    createduserroles: number
    updateduserroles: number
    userroles: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | UserCountOutputTypeCountInvoicesArgs
    subscriptions?: boolean | UserCountOutputTypeCountSubscriptionsArgs
    customers?: boolean | UserCountOutputTypeCountCustomersArgs
    parameters?: boolean | UserCountOutputTypeCountParametersArgs
    entrances?: boolean | UserCountOutputTypeCountEntrancesArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
    transactions?: boolean | UserCountOutputTypeCountTransactionsArgs
    notificationuser?: boolean | UserCountOutputTypeCountNotificationuserArgs
    createdapiclients?: boolean | UserCountOutputTypeCountCreatedapiclientsArgs
    updatedapiclients?: boolean | UserCountOutputTypeCountUpdatedapiclientsArgs
    createdpermissions?: boolean | UserCountOutputTypeCountCreatedpermissionsArgs
    updatedpermissions?: boolean | UserCountOutputTypeCountUpdatedpermissionsArgs
    refreshtokens?: boolean | UserCountOutputTypeCountRefreshtokensArgs
    createdroles?: boolean | UserCountOutputTypeCountCreatedrolesArgs
    updatedroles?: boolean | UserCountOutputTypeCountUpdatedrolesArgs
    createdrolepermissions?: boolean | UserCountOutputTypeCountCreatedrolepermissionsArgs
    updatedrolepermissions?: boolean | UserCountOutputTypeCountUpdatedrolepermissionsArgs
    createdusers?: boolean | UserCountOutputTypeCountCreatedusersArgs
    updatedusers?: boolean | UserCountOutputTypeCountUpdatedusersArgs
    createduserpermissions?: boolean | UserCountOutputTypeCountCreateduserpermissionsArgs
    updateduserpermissions?: boolean | UserCountOutputTypeCountUpdateduserpermissionsArgs
    userpermissions?: boolean | UserCountOutputTypeCountUserpermissionsArgs
    createduserroles?: boolean | UserCountOutputTypeCountCreateduserrolesArgs
    updateduserroles?: boolean | UserCountOutputTypeCountUpdateduserrolesArgs
    userroles?: boolean | UserCountOutputTypeCountUserrolesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subscriptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountParametersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: parametersWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEntrancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: entranceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationuserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedapiclientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: apiclientWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedapiclientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: apiclientWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedpermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedpermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshtokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: refreshtokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedrolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedrolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedrolepermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolepermissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedrolepermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolepermissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedusersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedusersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreateduserpermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userpermissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdateduserpermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userpermissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserpermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userpermissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreateduserrolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userroleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdateduserrolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userroleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserrolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userroleWhereInput
  }


  /**
   * Count Type PlanCountOutputType
   */

  export type PlanCountOutputType = {
    subscriptions: number
    users: number
  }

  export type PlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | PlanCountOutputTypeCountSubscriptionsArgs
    users?: boolean | PlanCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCountOutputType
     */
    select?: PlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subscriptionWhereInput
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    invoices: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | CustomerCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoiceWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    payments: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model apiclient
   */

  export type AggregateApiclient = {
    _count: ApiclientCountAggregateOutputType | null
    _avg: ApiclientAvgAggregateOutputType | null
    _sum: ApiclientSumAggregateOutputType | null
    _min: ApiclientMinAggregateOutputType | null
    _max: ApiclientMaxAggregateOutputType | null
  }

  export type ApiclientAvgAggregateOutputType = {
    type: number | null
  }

  export type ApiclientSumAggregateOutputType = {
    type: number | null
  }

  export type ApiclientMinAggregateOutputType = {
    id: string | null
    name: string | null
    key: string | null
    secret: string | null
    type: number | null
    createdat: Date | null
    createdby: string | null
    updatedat: Date | null
    updatedby: string | null
    isactive: boolean | null
  }

  export type ApiclientMaxAggregateOutputType = {
    id: string | null
    name: string | null
    key: string | null
    secret: string | null
    type: number | null
    createdat: Date | null
    createdby: string | null
    updatedat: Date | null
    updatedby: string | null
    isactive: boolean | null
  }

  export type ApiclientCountAggregateOutputType = {
    id: number
    name: number
    key: number
    secret: number
    type: number
    createdat: number
    createdby: number
    updatedat: number
    updatedby: number
    isactive: number
    _all: number
  }


  export type ApiclientAvgAggregateInputType = {
    type?: true
  }

  export type ApiclientSumAggregateInputType = {
    type?: true
  }

  export type ApiclientMinAggregateInputType = {
    id?: true
    name?: true
    key?: true
    secret?: true
    type?: true
    createdat?: true
    createdby?: true
    updatedat?: true
    updatedby?: true
    isactive?: true
  }

  export type ApiclientMaxAggregateInputType = {
    id?: true
    name?: true
    key?: true
    secret?: true
    type?: true
    createdat?: true
    createdby?: true
    updatedat?: true
    updatedby?: true
    isactive?: true
  }

  export type ApiclientCountAggregateInputType = {
    id?: true
    name?: true
    key?: true
    secret?: true
    type?: true
    createdat?: true
    createdby?: true
    updatedat?: true
    updatedby?: true
    isactive?: true
    _all?: true
  }

  export type ApiclientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which apiclient to aggregate.
     */
    where?: apiclientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apiclients to fetch.
     */
    orderBy?: apiclientOrderByWithRelationInput | apiclientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: apiclientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apiclients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apiclients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned apiclients
    **/
    _count?: true | ApiclientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiclientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiclientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiclientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiclientMaxAggregateInputType
  }

  export type GetApiclientAggregateType<T extends ApiclientAggregateArgs> = {
        [P in keyof T & keyof AggregateApiclient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiclient[P]>
      : GetScalarType<T[P], AggregateApiclient[P]>
  }




  export type apiclientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: apiclientWhereInput
    orderBy?: apiclientOrderByWithAggregationInput | apiclientOrderByWithAggregationInput[]
    by: ApiclientScalarFieldEnum[] | ApiclientScalarFieldEnum
    having?: apiclientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiclientCountAggregateInputType | true
    _avg?: ApiclientAvgAggregateInputType
    _sum?: ApiclientSumAggregateInputType
    _min?: ApiclientMinAggregateInputType
    _max?: ApiclientMaxAggregateInputType
  }

  export type ApiclientGroupByOutputType = {
    id: string
    name: string
    key: string
    secret: string
    type: number
    createdat: Date
    createdby: string
    updatedat: Date | null
    updatedby: string | null
    isactive: boolean
    _count: ApiclientCountAggregateOutputType | null
    _avg: ApiclientAvgAggregateOutputType | null
    _sum: ApiclientSumAggregateOutputType | null
    _min: ApiclientMinAggregateOutputType | null
    _max: ApiclientMaxAggregateOutputType | null
  }

  type GetApiclientGroupByPayload<T extends apiclientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiclientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiclientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiclientGroupByOutputType[P]>
            : GetScalarType<T[P], ApiclientGroupByOutputType[P]>
        }
      >
    >


  export type apiclientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    key?: boolean
    secret?: boolean
    type?: boolean
    createdat?: boolean
    createdby?: boolean
    updatedat?: boolean
    updatedby?: boolean
    isactive?: boolean
    createduser?: boolean | userDefaultArgs<ExtArgs>
    updateduser?: boolean | apiclient$updateduserArgs<ExtArgs>
  }, ExtArgs["result"]["apiclient"]>

  export type apiclientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    key?: boolean
    secret?: boolean
    type?: boolean
    createdat?: boolean
    createdby?: boolean
    updatedat?: boolean
    updatedby?: boolean
    isactive?: boolean
    createduser?: boolean | userDefaultArgs<ExtArgs>
    updateduser?: boolean | apiclient$updateduserArgs<ExtArgs>
  }, ExtArgs["result"]["apiclient"]>

  export type apiclientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    key?: boolean
    secret?: boolean
    type?: boolean
    createdat?: boolean
    createdby?: boolean
    updatedat?: boolean
    updatedby?: boolean
    isactive?: boolean
    createduser?: boolean | userDefaultArgs<ExtArgs>
    updateduser?: boolean | apiclient$updateduserArgs<ExtArgs>
  }, ExtArgs["result"]["apiclient"]>

  export type apiclientSelectScalar = {
    id?: boolean
    name?: boolean
    key?: boolean
    secret?: boolean
    type?: boolean
    createdat?: boolean
    createdby?: boolean
    updatedat?: boolean
    updatedby?: boolean
    isactive?: boolean
  }

  export type apiclientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "key" | "secret" | "type" | "createdat" | "createdby" | "updatedat" | "updatedby" | "isactive", ExtArgs["result"]["apiclient"]>
  export type apiclientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createduser?: boolean | userDefaultArgs<ExtArgs>
    updateduser?: boolean | apiclient$updateduserArgs<ExtArgs>
  }
  export type apiclientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createduser?: boolean | userDefaultArgs<ExtArgs>
    updateduser?: boolean | apiclient$updateduserArgs<ExtArgs>
  }
  export type apiclientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createduser?: boolean | userDefaultArgs<ExtArgs>
    updateduser?: boolean | apiclient$updateduserArgs<ExtArgs>
  }

  export type $apiclientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "apiclient"
    objects: {
      createduser: Prisma.$userPayload<ExtArgs>
      updateduser: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      key: string
      secret: string
      type: number
      createdat: Date
      createdby: string
      updatedat: Date | null
      updatedby: string | null
      isactive: boolean
    }, ExtArgs["result"]["apiclient"]>
    composites: {}
  }

  type apiclientGetPayload<S extends boolean | null | undefined | apiclientDefaultArgs> = $Result.GetResult<Prisma.$apiclientPayload, S>

  type apiclientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<apiclientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiclientCountAggregateInputType | true
    }

  export interface apiclientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['apiclient'], meta: { name: 'apiclient' } }
    /**
     * Find zero or one Apiclient that matches the filter.
     * @param {apiclientFindUniqueArgs} args - Arguments to find a Apiclient
     * @example
     * // Get one Apiclient
     * const apiclient = await prisma.apiclient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends apiclientFindUniqueArgs>(args: SelectSubset<T, apiclientFindUniqueArgs<ExtArgs>>): Prisma__apiclientClient<$Result.GetResult<Prisma.$apiclientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Apiclient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {apiclientFindUniqueOrThrowArgs} args - Arguments to find a Apiclient
     * @example
     * // Get one Apiclient
     * const apiclient = await prisma.apiclient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends apiclientFindUniqueOrThrowArgs>(args: SelectSubset<T, apiclientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__apiclientClient<$Result.GetResult<Prisma.$apiclientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Apiclient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apiclientFindFirstArgs} args - Arguments to find a Apiclient
     * @example
     * // Get one Apiclient
     * const apiclient = await prisma.apiclient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends apiclientFindFirstArgs>(args?: SelectSubset<T, apiclientFindFirstArgs<ExtArgs>>): Prisma__apiclientClient<$Result.GetResult<Prisma.$apiclientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Apiclient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apiclientFindFirstOrThrowArgs} args - Arguments to find a Apiclient
     * @example
     * // Get one Apiclient
     * const apiclient = await prisma.apiclient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends apiclientFindFirstOrThrowArgs>(args?: SelectSubset<T, apiclientFindFirstOrThrowArgs<ExtArgs>>): Prisma__apiclientClient<$Result.GetResult<Prisma.$apiclientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Apiclients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apiclientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Apiclients
     * const apiclients = await prisma.apiclient.findMany()
     * 
     * // Get first 10 Apiclients
     * const apiclients = await prisma.apiclient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiclientWithIdOnly = await prisma.apiclient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends apiclientFindManyArgs>(args?: SelectSubset<T, apiclientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$apiclientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Apiclient.
     * @param {apiclientCreateArgs} args - Arguments to create a Apiclient.
     * @example
     * // Create one Apiclient
     * const Apiclient = await prisma.apiclient.create({
     *   data: {
     *     // ... data to create a Apiclient
     *   }
     * })
     * 
     */
    create<T extends apiclientCreateArgs>(args: SelectSubset<T, apiclientCreateArgs<ExtArgs>>): Prisma__apiclientClient<$Result.GetResult<Prisma.$apiclientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Apiclients.
     * @param {apiclientCreateManyArgs} args - Arguments to create many Apiclients.
     * @example
     * // Create many Apiclients
     * const apiclient = await prisma.apiclient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends apiclientCreateManyArgs>(args?: SelectSubset<T, apiclientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Apiclients and returns the data saved in the database.
     * @param {apiclientCreateManyAndReturnArgs} args - Arguments to create many Apiclients.
     * @example
     * // Create many Apiclients
     * const apiclient = await prisma.apiclient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Apiclients and only return the `id`
     * const apiclientWithIdOnly = await prisma.apiclient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends apiclientCreateManyAndReturnArgs>(args?: SelectSubset<T, apiclientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$apiclientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Apiclient.
     * @param {apiclientDeleteArgs} args - Arguments to delete one Apiclient.
     * @example
     * // Delete one Apiclient
     * const Apiclient = await prisma.apiclient.delete({
     *   where: {
     *     // ... filter to delete one Apiclient
     *   }
     * })
     * 
     */
    delete<T extends apiclientDeleteArgs>(args: SelectSubset<T, apiclientDeleteArgs<ExtArgs>>): Prisma__apiclientClient<$Result.GetResult<Prisma.$apiclientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Apiclient.
     * @param {apiclientUpdateArgs} args - Arguments to update one Apiclient.
     * @example
     * // Update one Apiclient
     * const apiclient = await prisma.apiclient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends apiclientUpdateArgs>(args: SelectSubset<T, apiclientUpdateArgs<ExtArgs>>): Prisma__apiclientClient<$Result.GetResult<Prisma.$apiclientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Apiclients.
     * @param {apiclientDeleteManyArgs} args - Arguments to filter Apiclients to delete.
     * @example
     * // Delete a few Apiclients
     * const { count } = await prisma.apiclient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends apiclientDeleteManyArgs>(args?: SelectSubset<T, apiclientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Apiclients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apiclientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Apiclients
     * const apiclient = await prisma.apiclient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends apiclientUpdateManyArgs>(args: SelectSubset<T, apiclientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Apiclients and returns the data updated in the database.
     * @param {apiclientUpdateManyAndReturnArgs} args - Arguments to update many Apiclients.
     * @example
     * // Update many Apiclients
     * const apiclient = await prisma.apiclient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Apiclients and only return the `id`
     * const apiclientWithIdOnly = await prisma.apiclient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends apiclientUpdateManyAndReturnArgs>(args: SelectSubset<T, apiclientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$apiclientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Apiclient.
     * @param {apiclientUpsertArgs} args - Arguments to update or create a Apiclient.
     * @example
     * // Update or create a Apiclient
     * const apiclient = await prisma.apiclient.upsert({
     *   create: {
     *     // ... data to create a Apiclient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Apiclient we want to update
     *   }
     * })
     */
    upsert<T extends apiclientUpsertArgs>(args: SelectSubset<T, apiclientUpsertArgs<ExtArgs>>): Prisma__apiclientClient<$Result.GetResult<Prisma.$apiclientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Apiclients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apiclientCountArgs} args - Arguments to filter Apiclients to count.
     * @example
     * // Count the number of Apiclients
     * const count = await prisma.apiclient.count({
     *   where: {
     *     // ... the filter for the Apiclients we want to count
     *   }
     * })
    **/
    count<T extends apiclientCountArgs>(
      args?: Subset<T, apiclientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiclientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Apiclient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiclientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiclientAggregateArgs>(args: Subset<T, ApiclientAggregateArgs>): Prisma.PrismaPromise<GetApiclientAggregateType<T>>

    /**
     * Group by Apiclient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apiclientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends apiclientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: apiclientGroupByArgs['orderBy'] }
        : { orderBy?: apiclientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, apiclientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiclientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the apiclient model
   */
  readonly fields: apiclientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for apiclient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__apiclientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createduser<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updateduser<T extends apiclient$updateduserArgs<ExtArgs> = {}>(args?: Subset<T, apiclient$updateduserArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the apiclient model
   */
  interface apiclientFieldRefs {
    readonly id: FieldRef<"apiclient", 'String'>
    readonly name: FieldRef<"apiclient", 'String'>
    readonly key: FieldRef<"apiclient", 'String'>
    readonly secret: FieldRef<"apiclient", 'String'>
    readonly type: FieldRef<"apiclient", 'Int'>
    readonly createdat: FieldRef<"apiclient", 'DateTime'>
    readonly createdby: FieldRef<"apiclient", 'String'>
    readonly updatedat: FieldRef<"apiclient", 'DateTime'>
    readonly updatedby: FieldRef<"apiclient", 'String'>
    readonly isactive: FieldRef<"apiclient", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * apiclient findUnique
   */
  export type apiclientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apiclient
     */
    select?: apiclientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apiclient
     */
    omit?: apiclientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: apiclientInclude<ExtArgs> | null
    /**
     * Filter, which apiclient to fetch.
     */
    where: apiclientWhereUniqueInput
  }

  /**
   * apiclient findUniqueOrThrow
   */
  export type apiclientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apiclient
     */
    select?: apiclientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apiclient
     */
    omit?: apiclientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: apiclientInclude<ExtArgs> | null
    /**
     * Filter, which apiclient to fetch.
     */
    where: apiclientWhereUniqueInput
  }

  /**
   * apiclient findFirst
   */
  export type apiclientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apiclient
     */
    select?: apiclientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apiclient
     */
    omit?: apiclientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: apiclientInclude<ExtArgs> | null
    /**
     * Filter, which apiclient to fetch.
     */
    where?: apiclientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apiclients to fetch.
     */
    orderBy?: apiclientOrderByWithRelationInput | apiclientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for apiclients.
     */
    cursor?: apiclientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apiclients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apiclients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of apiclients.
     */
    distinct?: ApiclientScalarFieldEnum | ApiclientScalarFieldEnum[]
  }

  /**
   * apiclient findFirstOrThrow
   */
  export type apiclientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apiclient
     */
    select?: apiclientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apiclient
     */
    omit?: apiclientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: apiclientInclude<ExtArgs> | null
    /**
     * Filter, which apiclient to fetch.
     */
    where?: apiclientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apiclients to fetch.
     */
    orderBy?: apiclientOrderByWithRelationInput | apiclientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for apiclients.
     */
    cursor?: apiclientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apiclients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apiclients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of apiclients.
     */
    distinct?: ApiclientScalarFieldEnum | ApiclientScalarFieldEnum[]
  }

  /**
   * apiclient findMany
   */
  export type apiclientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apiclient
     */
    select?: apiclientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apiclient
     */
    omit?: apiclientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: apiclientInclude<ExtArgs> | null
    /**
     * Filter, which apiclients to fetch.
     */
    where?: apiclientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apiclients to fetch.
     */
    orderBy?: apiclientOrderByWithRelationInput | apiclientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing apiclients.
     */
    cursor?: apiclientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apiclients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apiclients.
     */
    skip?: number
    distinct?: ApiclientScalarFieldEnum | ApiclientScalarFieldEnum[]
  }

  /**
   * apiclient create
   */
  export type apiclientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apiclient
     */
    select?: apiclientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apiclient
     */
    omit?: apiclientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: apiclientInclude<ExtArgs> | null
    /**
     * The data needed to create a apiclient.
     */
    data: XOR<apiclientCreateInput, apiclientUncheckedCreateInput>
  }

  /**
   * apiclient createMany
   */
  export type apiclientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many apiclients.
     */
    data: apiclientCreateManyInput | apiclientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * apiclient createManyAndReturn
   */
  export type apiclientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apiclient
     */
    select?: apiclientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the apiclient
     */
    omit?: apiclientOmit<ExtArgs> | null
    /**
     * The data used to create many apiclients.
     */
    data: apiclientCreateManyInput | apiclientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: apiclientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * apiclient update
   */
  export type apiclientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apiclient
     */
    select?: apiclientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apiclient
     */
    omit?: apiclientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: apiclientInclude<ExtArgs> | null
    /**
     * The data needed to update a apiclient.
     */
    data: XOR<apiclientUpdateInput, apiclientUncheckedUpdateInput>
    /**
     * Choose, which apiclient to update.
     */
    where: apiclientWhereUniqueInput
  }

  /**
   * apiclient updateMany
   */
  export type apiclientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update apiclients.
     */
    data: XOR<apiclientUpdateManyMutationInput, apiclientUncheckedUpdateManyInput>
    /**
     * Filter which apiclients to update
     */
    where?: apiclientWhereInput
    /**
     * Limit how many apiclients to update.
     */
    limit?: number
  }

  /**
   * apiclient updateManyAndReturn
   */
  export type apiclientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apiclient
     */
    select?: apiclientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the apiclient
     */
    omit?: apiclientOmit<ExtArgs> | null
    /**
     * The data used to update apiclients.
     */
    data: XOR<apiclientUpdateManyMutationInput, apiclientUncheckedUpdateManyInput>
    /**
     * Filter which apiclients to update
     */
    where?: apiclientWhereInput
    /**
     * Limit how many apiclients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: apiclientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * apiclient upsert
   */
  export type apiclientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apiclient
     */
    select?: apiclientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apiclient
     */
    omit?: apiclientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: apiclientInclude<ExtArgs> | null
    /**
     * The filter to search for the apiclient to update in case it exists.
     */
    where: apiclientWhereUniqueInput
    /**
     * In case the apiclient found by the `where` argument doesn't exist, create a new apiclient with this data.
     */
    create: XOR<apiclientCreateInput, apiclientUncheckedCreateInput>
    /**
     * In case the apiclient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<apiclientUpdateInput, apiclientUncheckedUpdateInput>
  }

  /**
   * apiclient delete
   */
  export type apiclientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apiclient
     */
    select?: apiclientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apiclient
     */
    omit?: apiclientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: apiclientInclude<ExtArgs> | null
    /**
     * Filter which apiclient to delete.
     */
    where: apiclientWhereUniqueInput
  }

  /**
   * apiclient deleteMany
   */
  export type apiclientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which apiclients to delete
     */
    where?: apiclientWhereInput
    /**
     * Limit how many apiclients to delete.
     */
    limit?: number
  }

  /**
   * apiclient.updateduser
   */
  export type apiclient$updateduserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * apiclient without action
   */
  export type apiclientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apiclient
     */
    select?: apiclientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apiclient
     */
    omit?: apiclientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: apiclientInclude<ExtArgs> | null
  }


  /**
   * Model refreshtoken
   */

  export type AggregateRefreshtoken = {
    _count: RefreshtokenCountAggregateOutputType | null
    _min: RefreshtokenMinAggregateOutputType | null
    _max: RefreshtokenMaxAggregateOutputType | null
  }

  export type RefreshtokenMinAggregateOutputType = {
    id: string | null
    userid: string | null
    token: string | null
    createdat: Date | null
    updatedat: Date | null
    expiresat: Date | null
  }

  export type RefreshtokenMaxAggregateOutputType = {
    id: string | null
    userid: string | null
    token: string | null
    createdat: Date | null
    updatedat: Date | null
    expiresat: Date | null
  }

  export type RefreshtokenCountAggregateOutputType = {
    id: number
    userid: number
    token: number
    createdat: number
    updatedat: number
    expiresat: number
    _all: number
  }


  export type RefreshtokenMinAggregateInputType = {
    id?: true
    userid?: true
    token?: true
    createdat?: true
    updatedat?: true
    expiresat?: true
  }

  export type RefreshtokenMaxAggregateInputType = {
    id?: true
    userid?: true
    token?: true
    createdat?: true
    updatedat?: true
    expiresat?: true
  }

  export type RefreshtokenCountAggregateInputType = {
    id?: true
    userid?: true
    token?: true
    createdat?: true
    updatedat?: true
    expiresat?: true
    _all?: true
  }

  export type RefreshtokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which refreshtoken to aggregate.
     */
    where?: refreshtokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refreshtokens to fetch.
     */
    orderBy?: refreshtokenOrderByWithRelationInput | refreshtokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: refreshtokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refreshtokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refreshtokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned refreshtokens
    **/
    _count?: true | RefreshtokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshtokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshtokenMaxAggregateInputType
  }

  export type GetRefreshtokenAggregateType<T extends RefreshtokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshtoken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshtoken[P]>
      : GetScalarType<T[P], AggregateRefreshtoken[P]>
  }




  export type refreshtokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: refreshtokenWhereInput
    orderBy?: refreshtokenOrderByWithAggregationInput | refreshtokenOrderByWithAggregationInput[]
    by: RefreshtokenScalarFieldEnum[] | RefreshtokenScalarFieldEnum
    having?: refreshtokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshtokenCountAggregateInputType | true
    _min?: RefreshtokenMinAggregateInputType
    _max?: RefreshtokenMaxAggregateInputType
  }

  export type RefreshtokenGroupByOutputType = {
    id: string
    userid: string
    token: string
    createdat: Date
    updatedat: Date | null
    expiresat: Date | null
    _count: RefreshtokenCountAggregateOutputType | null
    _min: RefreshtokenMinAggregateOutputType | null
    _max: RefreshtokenMaxAggregateOutputType | null
  }

  type GetRefreshtokenGroupByPayload<T extends refreshtokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshtokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshtokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshtokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshtokenGroupByOutputType[P]>
        }
      >
    >


  export type refreshtokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    token?: boolean
    createdat?: boolean
    updatedat?: boolean
    expiresat?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshtoken"]>

  export type refreshtokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    token?: boolean
    createdat?: boolean
    updatedat?: boolean
    expiresat?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshtoken"]>

  export type refreshtokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    token?: boolean
    createdat?: boolean
    updatedat?: boolean
    expiresat?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshtoken"]>

  export type refreshtokenSelectScalar = {
    id?: boolean
    userid?: boolean
    token?: boolean
    createdat?: boolean
    updatedat?: boolean
    expiresat?: boolean
  }

  export type refreshtokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userid" | "token" | "createdat" | "updatedat" | "expiresat", ExtArgs["result"]["refreshtoken"]>
  export type refreshtokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type refreshtokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type refreshtokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $refreshtokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "refreshtoken"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userid: string
      token: string
      createdat: Date
      updatedat: Date | null
      expiresat: Date | null
    }, ExtArgs["result"]["refreshtoken"]>
    composites: {}
  }

  type refreshtokenGetPayload<S extends boolean | null | undefined | refreshtokenDefaultArgs> = $Result.GetResult<Prisma.$refreshtokenPayload, S>

  type refreshtokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<refreshtokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshtokenCountAggregateInputType | true
    }

  export interface refreshtokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['refreshtoken'], meta: { name: 'refreshtoken' } }
    /**
     * Find zero or one Refreshtoken that matches the filter.
     * @param {refreshtokenFindUniqueArgs} args - Arguments to find a Refreshtoken
     * @example
     * // Get one Refreshtoken
     * const refreshtoken = await prisma.refreshtoken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends refreshtokenFindUniqueArgs>(args: SelectSubset<T, refreshtokenFindUniqueArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Refreshtoken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {refreshtokenFindUniqueOrThrowArgs} args - Arguments to find a Refreshtoken
     * @example
     * // Get one Refreshtoken
     * const refreshtoken = await prisma.refreshtoken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends refreshtokenFindUniqueOrThrowArgs>(args: SelectSubset<T, refreshtokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Refreshtoken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refreshtokenFindFirstArgs} args - Arguments to find a Refreshtoken
     * @example
     * // Get one Refreshtoken
     * const refreshtoken = await prisma.refreshtoken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends refreshtokenFindFirstArgs>(args?: SelectSubset<T, refreshtokenFindFirstArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Refreshtoken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refreshtokenFindFirstOrThrowArgs} args - Arguments to find a Refreshtoken
     * @example
     * // Get one Refreshtoken
     * const refreshtoken = await prisma.refreshtoken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends refreshtokenFindFirstOrThrowArgs>(args?: SelectSubset<T, refreshtokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Refreshtokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refreshtokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Refreshtokens
     * const refreshtokens = await prisma.refreshtoken.findMany()
     * 
     * // Get first 10 Refreshtokens
     * const refreshtokens = await prisma.refreshtoken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshtokenWithIdOnly = await prisma.refreshtoken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends refreshtokenFindManyArgs>(args?: SelectSubset<T, refreshtokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Refreshtoken.
     * @param {refreshtokenCreateArgs} args - Arguments to create a Refreshtoken.
     * @example
     * // Create one Refreshtoken
     * const Refreshtoken = await prisma.refreshtoken.create({
     *   data: {
     *     // ... data to create a Refreshtoken
     *   }
     * })
     * 
     */
    create<T extends refreshtokenCreateArgs>(args: SelectSubset<T, refreshtokenCreateArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Refreshtokens.
     * @param {refreshtokenCreateManyArgs} args - Arguments to create many Refreshtokens.
     * @example
     * // Create many Refreshtokens
     * const refreshtoken = await prisma.refreshtoken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends refreshtokenCreateManyArgs>(args?: SelectSubset<T, refreshtokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Refreshtokens and returns the data saved in the database.
     * @param {refreshtokenCreateManyAndReturnArgs} args - Arguments to create many Refreshtokens.
     * @example
     * // Create many Refreshtokens
     * const refreshtoken = await prisma.refreshtoken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Refreshtokens and only return the `id`
     * const refreshtokenWithIdOnly = await prisma.refreshtoken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends refreshtokenCreateManyAndReturnArgs>(args?: SelectSubset<T, refreshtokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Refreshtoken.
     * @param {refreshtokenDeleteArgs} args - Arguments to delete one Refreshtoken.
     * @example
     * // Delete one Refreshtoken
     * const Refreshtoken = await prisma.refreshtoken.delete({
     *   where: {
     *     // ... filter to delete one Refreshtoken
     *   }
     * })
     * 
     */
    delete<T extends refreshtokenDeleteArgs>(args: SelectSubset<T, refreshtokenDeleteArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Refreshtoken.
     * @param {refreshtokenUpdateArgs} args - Arguments to update one Refreshtoken.
     * @example
     * // Update one Refreshtoken
     * const refreshtoken = await prisma.refreshtoken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends refreshtokenUpdateArgs>(args: SelectSubset<T, refreshtokenUpdateArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Refreshtokens.
     * @param {refreshtokenDeleteManyArgs} args - Arguments to filter Refreshtokens to delete.
     * @example
     * // Delete a few Refreshtokens
     * const { count } = await prisma.refreshtoken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends refreshtokenDeleteManyArgs>(args?: SelectSubset<T, refreshtokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Refreshtokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refreshtokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Refreshtokens
     * const refreshtoken = await prisma.refreshtoken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends refreshtokenUpdateManyArgs>(args: SelectSubset<T, refreshtokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Refreshtokens and returns the data updated in the database.
     * @param {refreshtokenUpdateManyAndReturnArgs} args - Arguments to update many Refreshtokens.
     * @example
     * // Update many Refreshtokens
     * const refreshtoken = await prisma.refreshtoken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Refreshtokens and only return the `id`
     * const refreshtokenWithIdOnly = await prisma.refreshtoken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends refreshtokenUpdateManyAndReturnArgs>(args: SelectSubset<T, refreshtokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Refreshtoken.
     * @param {refreshtokenUpsertArgs} args - Arguments to update or create a Refreshtoken.
     * @example
     * // Update or create a Refreshtoken
     * const refreshtoken = await prisma.refreshtoken.upsert({
     *   create: {
     *     // ... data to create a Refreshtoken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Refreshtoken we want to update
     *   }
     * })
     */
    upsert<T extends refreshtokenUpsertArgs>(args: SelectSubset<T, refreshtokenUpsertArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Refreshtokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refreshtokenCountArgs} args - Arguments to filter Refreshtokens to count.
     * @example
     * // Count the number of Refreshtokens
     * const count = await prisma.refreshtoken.count({
     *   where: {
     *     // ... the filter for the Refreshtokens we want to count
     *   }
     * })
    **/
    count<T extends refreshtokenCountArgs>(
      args?: Subset<T, refreshtokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshtokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Refreshtoken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshtokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshtokenAggregateArgs>(args: Subset<T, RefreshtokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshtokenAggregateType<T>>

    /**
     * Group by Refreshtoken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refreshtokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends refreshtokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: refreshtokenGroupByArgs['orderBy'] }
        : { orderBy?: refreshtokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, refreshtokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshtokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the refreshtoken model
   */
  readonly fields: refreshtokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for refreshtoken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__refreshtokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the refreshtoken model
   */
  interface refreshtokenFieldRefs {
    readonly id: FieldRef<"refreshtoken", 'String'>
    readonly userid: FieldRef<"refreshtoken", 'String'>
    readonly token: FieldRef<"refreshtoken", 'String'>
    readonly createdat: FieldRef<"refreshtoken", 'DateTime'>
    readonly updatedat: FieldRef<"refreshtoken", 'DateTime'>
    readonly expiresat: FieldRef<"refreshtoken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * refreshtoken findUnique
   */
  export type refreshtokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refreshtoken
     */
    omit?: refreshtokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * Filter, which refreshtoken to fetch.
     */
    where: refreshtokenWhereUniqueInput
  }

  /**
   * refreshtoken findUniqueOrThrow
   */
  export type refreshtokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refreshtoken
     */
    omit?: refreshtokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * Filter, which refreshtoken to fetch.
     */
    where: refreshtokenWhereUniqueInput
  }

  /**
   * refreshtoken findFirst
   */
  export type refreshtokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refreshtoken
     */
    omit?: refreshtokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * Filter, which refreshtoken to fetch.
     */
    where?: refreshtokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refreshtokens to fetch.
     */
    orderBy?: refreshtokenOrderByWithRelationInput | refreshtokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for refreshtokens.
     */
    cursor?: refreshtokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refreshtokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refreshtokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of refreshtokens.
     */
    distinct?: RefreshtokenScalarFieldEnum | RefreshtokenScalarFieldEnum[]
  }

  /**
   * refreshtoken findFirstOrThrow
   */
  export type refreshtokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refreshtoken
     */
    omit?: refreshtokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * Filter, which refreshtoken to fetch.
     */
    where?: refreshtokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refreshtokens to fetch.
     */
    orderBy?: refreshtokenOrderByWithRelationInput | refreshtokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for refreshtokens.
     */
    cursor?: refreshtokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refreshtokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refreshtokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of refreshtokens.
     */
    distinct?: RefreshtokenScalarFieldEnum | RefreshtokenScalarFieldEnum[]
  }

  /**
   * refreshtoken findMany
   */
  export type refreshtokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refreshtoken
     */
    omit?: refreshtokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * Filter, which refreshtokens to fetch.
     */
    where?: refreshtokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refreshtokens to fetch.
     */
    orderBy?: refreshtokenOrderByWithRelationInput | refreshtokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing refreshtokens.
     */
    cursor?: refreshtokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refreshtokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refreshtokens.
     */
    skip?: number
    distinct?: RefreshtokenScalarFieldEnum | RefreshtokenScalarFieldEnum[]
  }

  /**
   * refreshtoken create
   */
  export type refreshtokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refreshtoken
     */
    omit?: refreshtokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * The data needed to create a refreshtoken.
     */
    data: XOR<refreshtokenCreateInput, refreshtokenUncheckedCreateInput>
  }

  /**
   * refreshtoken createMany
   */
  export type refreshtokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many refreshtokens.
     */
    data: refreshtokenCreateManyInput | refreshtokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * refreshtoken createManyAndReturn
   */
  export type refreshtokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the refreshtoken
     */
    omit?: refreshtokenOmit<ExtArgs> | null
    /**
     * The data used to create many refreshtokens.
     */
    data: refreshtokenCreateManyInput | refreshtokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * refreshtoken update
   */
  export type refreshtokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refreshtoken
     */
    omit?: refreshtokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * The data needed to update a refreshtoken.
     */
    data: XOR<refreshtokenUpdateInput, refreshtokenUncheckedUpdateInput>
    /**
     * Choose, which refreshtoken to update.
     */
    where: refreshtokenWhereUniqueInput
  }

  /**
   * refreshtoken updateMany
   */
  export type refreshtokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update refreshtokens.
     */
    data: XOR<refreshtokenUpdateManyMutationInput, refreshtokenUncheckedUpdateManyInput>
    /**
     * Filter which refreshtokens to update
     */
    where?: refreshtokenWhereInput
    /**
     * Limit how many refreshtokens to update.
     */
    limit?: number
  }

  /**
   * refreshtoken updateManyAndReturn
   */
  export type refreshtokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the refreshtoken
     */
    omit?: refreshtokenOmit<ExtArgs> | null
    /**
     * The data used to update refreshtokens.
     */
    data: XOR<refreshtokenUpdateManyMutationInput, refreshtokenUncheckedUpdateManyInput>
    /**
     * Filter which refreshtokens to update
     */
    where?: refreshtokenWhereInput
    /**
     * Limit how many refreshtokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * refreshtoken upsert
   */
  export type refreshtokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refreshtoken
     */
    omit?: refreshtokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * The filter to search for the refreshtoken to update in case it exists.
     */
    where: refreshtokenWhereUniqueInput
    /**
     * In case the refreshtoken found by the `where` argument doesn't exist, create a new refreshtoken with this data.
     */
    create: XOR<refreshtokenCreateInput, refreshtokenUncheckedCreateInput>
    /**
     * In case the refreshtoken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<refreshtokenUpdateInput, refreshtokenUncheckedUpdateInput>
  }

  /**
   * refreshtoken delete
   */
  export type refreshtokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refreshtoken
     */
    omit?: refreshtokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * Filter which refreshtoken to delete.
     */
    where: refreshtokenWhereUniqueInput
  }

  /**
   * refreshtoken deleteMany
   */
  export type refreshtokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which refreshtokens to delete
     */
    where?: refreshtokenWhereInput
    /**
     * Limit how many refreshtokens to delete.
     */
    limit?: number
  }

  /**
   * refreshtoken without action
   */
  export type refreshtokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refreshtoken
     */
    omit?: refreshtokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
  }


  /**
   * Model revokedtoken
   */

  export type AggregateRevokedtoken = {
    _count: RevokedtokenCountAggregateOutputType | null
    _min: RevokedtokenMinAggregateOutputType | null
    _max: RevokedtokenMaxAggregateOutputType | null
  }

  export type RevokedtokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    date: Date | null
  }

  export type RevokedtokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    date: Date | null
  }

  export type RevokedtokenCountAggregateOutputType = {
    id: number
    token: number
    date: number
    _all: number
  }


  export type RevokedtokenMinAggregateInputType = {
    id?: true
    token?: true
    date?: true
  }

  export type RevokedtokenMaxAggregateInputType = {
    id?: true
    token?: true
    date?: true
  }

  export type RevokedtokenCountAggregateInputType = {
    id?: true
    token?: true
    date?: true
    _all?: true
  }

  export type RevokedtokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which revokedtoken to aggregate.
     */
    where?: revokedtokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of revokedtokens to fetch.
     */
    orderBy?: revokedtokenOrderByWithRelationInput | revokedtokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: revokedtokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` revokedtokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` revokedtokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned revokedtokens
    **/
    _count?: true | RevokedtokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RevokedtokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RevokedtokenMaxAggregateInputType
  }

  export type GetRevokedtokenAggregateType<T extends RevokedtokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRevokedtoken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRevokedtoken[P]>
      : GetScalarType<T[P], AggregateRevokedtoken[P]>
  }




  export type revokedtokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: revokedtokenWhereInput
    orderBy?: revokedtokenOrderByWithAggregationInput | revokedtokenOrderByWithAggregationInput[]
    by: RevokedtokenScalarFieldEnum[] | RevokedtokenScalarFieldEnum
    having?: revokedtokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RevokedtokenCountAggregateInputType | true
    _min?: RevokedtokenMinAggregateInputType
    _max?: RevokedtokenMaxAggregateInputType
  }

  export type RevokedtokenGroupByOutputType = {
    id: string
    token: string
    date: Date
    _count: RevokedtokenCountAggregateOutputType | null
    _min: RevokedtokenMinAggregateOutputType | null
    _max: RevokedtokenMaxAggregateOutputType | null
  }

  type GetRevokedtokenGroupByPayload<T extends revokedtokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RevokedtokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RevokedtokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RevokedtokenGroupByOutputType[P]>
            : GetScalarType<T[P], RevokedtokenGroupByOutputType[P]>
        }
      >
    >


  export type revokedtokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    date?: boolean
  }, ExtArgs["result"]["revokedtoken"]>

  export type revokedtokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    date?: boolean
  }, ExtArgs["result"]["revokedtoken"]>

  export type revokedtokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    date?: boolean
  }, ExtArgs["result"]["revokedtoken"]>

  export type revokedtokenSelectScalar = {
    id?: boolean
    token?: boolean
    date?: boolean
  }

  export type revokedtokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "date", ExtArgs["result"]["revokedtoken"]>

  export type $revokedtokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "revokedtoken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      date: Date
    }, ExtArgs["result"]["revokedtoken"]>
    composites: {}
  }

  type revokedtokenGetPayload<S extends boolean | null | undefined | revokedtokenDefaultArgs> = $Result.GetResult<Prisma.$revokedtokenPayload, S>

  type revokedtokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<revokedtokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RevokedtokenCountAggregateInputType | true
    }

  export interface revokedtokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['revokedtoken'], meta: { name: 'revokedtoken' } }
    /**
     * Find zero or one Revokedtoken that matches the filter.
     * @param {revokedtokenFindUniqueArgs} args - Arguments to find a Revokedtoken
     * @example
     * // Get one Revokedtoken
     * const revokedtoken = await prisma.revokedtoken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends revokedtokenFindUniqueArgs>(args: SelectSubset<T, revokedtokenFindUniqueArgs<ExtArgs>>): Prisma__revokedtokenClient<$Result.GetResult<Prisma.$revokedtokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Revokedtoken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {revokedtokenFindUniqueOrThrowArgs} args - Arguments to find a Revokedtoken
     * @example
     * // Get one Revokedtoken
     * const revokedtoken = await prisma.revokedtoken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends revokedtokenFindUniqueOrThrowArgs>(args: SelectSubset<T, revokedtokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__revokedtokenClient<$Result.GetResult<Prisma.$revokedtokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Revokedtoken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {revokedtokenFindFirstArgs} args - Arguments to find a Revokedtoken
     * @example
     * // Get one Revokedtoken
     * const revokedtoken = await prisma.revokedtoken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends revokedtokenFindFirstArgs>(args?: SelectSubset<T, revokedtokenFindFirstArgs<ExtArgs>>): Prisma__revokedtokenClient<$Result.GetResult<Prisma.$revokedtokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Revokedtoken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {revokedtokenFindFirstOrThrowArgs} args - Arguments to find a Revokedtoken
     * @example
     * // Get one Revokedtoken
     * const revokedtoken = await prisma.revokedtoken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends revokedtokenFindFirstOrThrowArgs>(args?: SelectSubset<T, revokedtokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__revokedtokenClient<$Result.GetResult<Prisma.$revokedtokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Revokedtokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {revokedtokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Revokedtokens
     * const revokedtokens = await prisma.revokedtoken.findMany()
     * 
     * // Get first 10 Revokedtokens
     * const revokedtokens = await prisma.revokedtoken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const revokedtokenWithIdOnly = await prisma.revokedtoken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends revokedtokenFindManyArgs>(args?: SelectSubset<T, revokedtokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$revokedtokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Revokedtoken.
     * @param {revokedtokenCreateArgs} args - Arguments to create a Revokedtoken.
     * @example
     * // Create one Revokedtoken
     * const Revokedtoken = await prisma.revokedtoken.create({
     *   data: {
     *     // ... data to create a Revokedtoken
     *   }
     * })
     * 
     */
    create<T extends revokedtokenCreateArgs>(args: SelectSubset<T, revokedtokenCreateArgs<ExtArgs>>): Prisma__revokedtokenClient<$Result.GetResult<Prisma.$revokedtokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Revokedtokens.
     * @param {revokedtokenCreateManyArgs} args - Arguments to create many Revokedtokens.
     * @example
     * // Create many Revokedtokens
     * const revokedtoken = await prisma.revokedtoken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends revokedtokenCreateManyArgs>(args?: SelectSubset<T, revokedtokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Revokedtokens and returns the data saved in the database.
     * @param {revokedtokenCreateManyAndReturnArgs} args - Arguments to create many Revokedtokens.
     * @example
     * // Create many Revokedtokens
     * const revokedtoken = await prisma.revokedtoken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Revokedtokens and only return the `id`
     * const revokedtokenWithIdOnly = await prisma.revokedtoken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends revokedtokenCreateManyAndReturnArgs>(args?: SelectSubset<T, revokedtokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$revokedtokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Revokedtoken.
     * @param {revokedtokenDeleteArgs} args - Arguments to delete one Revokedtoken.
     * @example
     * // Delete one Revokedtoken
     * const Revokedtoken = await prisma.revokedtoken.delete({
     *   where: {
     *     // ... filter to delete one Revokedtoken
     *   }
     * })
     * 
     */
    delete<T extends revokedtokenDeleteArgs>(args: SelectSubset<T, revokedtokenDeleteArgs<ExtArgs>>): Prisma__revokedtokenClient<$Result.GetResult<Prisma.$revokedtokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Revokedtoken.
     * @param {revokedtokenUpdateArgs} args - Arguments to update one Revokedtoken.
     * @example
     * // Update one Revokedtoken
     * const revokedtoken = await prisma.revokedtoken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends revokedtokenUpdateArgs>(args: SelectSubset<T, revokedtokenUpdateArgs<ExtArgs>>): Prisma__revokedtokenClient<$Result.GetResult<Prisma.$revokedtokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Revokedtokens.
     * @param {revokedtokenDeleteManyArgs} args - Arguments to filter Revokedtokens to delete.
     * @example
     * // Delete a few Revokedtokens
     * const { count } = await prisma.revokedtoken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends revokedtokenDeleteManyArgs>(args?: SelectSubset<T, revokedtokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Revokedtokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {revokedtokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Revokedtokens
     * const revokedtoken = await prisma.revokedtoken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends revokedtokenUpdateManyArgs>(args: SelectSubset<T, revokedtokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Revokedtokens and returns the data updated in the database.
     * @param {revokedtokenUpdateManyAndReturnArgs} args - Arguments to update many Revokedtokens.
     * @example
     * // Update many Revokedtokens
     * const revokedtoken = await prisma.revokedtoken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Revokedtokens and only return the `id`
     * const revokedtokenWithIdOnly = await prisma.revokedtoken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends revokedtokenUpdateManyAndReturnArgs>(args: SelectSubset<T, revokedtokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$revokedtokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Revokedtoken.
     * @param {revokedtokenUpsertArgs} args - Arguments to update or create a Revokedtoken.
     * @example
     * // Update or create a Revokedtoken
     * const revokedtoken = await prisma.revokedtoken.upsert({
     *   create: {
     *     // ... data to create a Revokedtoken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Revokedtoken we want to update
     *   }
     * })
     */
    upsert<T extends revokedtokenUpsertArgs>(args: SelectSubset<T, revokedtokenUpsertArgs<ExtArgs>>): Prisma__revokedtokenClient<$Result.GetResult<Prisma.$revokedtokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Revokedtokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {revokedtokenCountArgs} args - Arguments to filter Revokedtokens to count.
     * @example
     * // Count the number of Revokedtokens
     * const count = await prisma.revokedtoken.count({
     *   where: {
     *     // ... the filter for the Revokedtokens we want to count
     *   }
     * })
    **/
    count<T extends revokedtokenCountArgs>(
      args?: Subset<T, revokedtokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RevokedtokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Revokedtoken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevokedtokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RevokedtokenAggregateArgs>(args: Subset<T, RevokedtokenAggregateArgs>): Prisma.PrismaPromise<GetRevokedtokenAggregateType<T>>

    /**
     * Group by Revokedtoken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {revokedtokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends revokedtokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: revokedtokenGroupByArgs['orderBy'] }
        : { orderBy?: revokedtokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, revokedtokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRevokedtokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the revokedtoken model
   */
  readonly fields: revokedtokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for revokedtoken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__revokedtokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the revokedtoken model
   */
  interface revokedtokenFieldRefs {
    readonly id: FieldRef<"revokedtoken", 'String'>
    readonly token: FieldRef<"revokedtoken", 'String'>
    readonly date: FieldRef<"revokedtoken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * revokedtoken findUnique
   */
  export type revokedtokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the revokedtoken
     */
    select?: revokedtokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the revokedtoken
     */
    omit?: revokedtokenOmit<ExtArgs> | null
    /**
     * Filter, which revokedtoken to fetch.
     */
    where: revokedtokenWhereUniqueInput
  }

  /**
   * revokedtoken findUniqueOrThrow
   */
  export type revokedtokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the revokedtoken
     */
    select?: revokedtokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the revokedtoken
     */
    omit?: revokedtokenOmit<ExtArgs> | null
    /**
     * Filter, which revokedtoken to fetch.
     */
    where: revokedtokenWhereUniqueInput
  }

  /**
   * revokedtoken findFirst
   */
  export type revokedtokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the revokedtoken
     */
    select?: revokedtokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the revokedtoken
     */
    omit?: revokedtokenOmit<ExtArgs> | null
    /**
     * Filter, which revokedtoken to fetch.
     */
    where?: revokedtokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of revokedtokens to fetch.
     */
    orderBy?: revokedtokenOrderByWithRelationInput | revokedtokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for revokedtokens.
     */
    cursor?: revokedtokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` revokedtokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` revokedtokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of revokedtokens.
     */
    distinct?: RevokedtokenScalarFieldEnum | RevokedtokenScalarFieldEnum[]
  }

  /**
   * revokedtoken findFirstOrThrow
   */
  export type revokedtokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the revokedtoken
     */
    select?: revokedtokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the revokedtoken
     */
    omit?: revokedtokenOmit<ExtArgs> | null
    /**
     * Filter, which revokedtoken to fetch.
     */
    where?: revokedtokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of revokedtokens to fetch.
     */
    orderBy?: revokedtokenOrderByWithRelationInput | revokedtokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for revokedtokens.
     */
    cursor?: revokedtokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` revokedtokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` revokedtokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of revokedtokens.
     */
    distinct?: RevokedtokenScalarFieldEnum | RevokedtokenScalarFieldEnum[]
  }

  /**
   * revokedtoken findMany
   */
  export type revokedtokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the revokedtoken
     */
    select?: revokedtokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the revokedtoken
     */
    omit?: revokedtokenOmit<ExtArgs> | null
    /**
     * Filter, which revokedtokens to fetch.
     */
    where?: revokedtokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of revokedtokens to fetch.
     */
    orderBy?: revokedtokenOrderByWithRelationInput | revokedtokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing revokedtokens.
     */
    cursor?: revokedtokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` revokedtokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` revokedtokens.
     */
    skip?: number
    distinct?: RevokedtokenScalarFieldEnum | RevokedtokenScalarFieldEnum[]
  }

  /**
   * revokedtoken create
   */
  export type revokedtokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the revokedtoken
     */
    select?: revokedtokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the revokedtoken
     */
    omit?: revokedtokenOmit<ExtArgs> | null
    /**
     * The data needed to create a revokedtoken.
     */
    data: XOR<revokedtokenCreateInput, revokedtokenUncheckedCreateInput>
  }

  /**
   * revokedtoken createMany
   */
  export type revokedtokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many revokedtokens.
     */
    data: revokedtokenCreateManyInput | revokedtokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * revokedtoken createManyAndReturn
   */
  export type revokedtokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the revokedtoken
     */
    select?: revokedtokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the revokedtoken
     */
    omit?: revokedtokenOmit<ExtArgs> | null
    /**
     * The data used to create many revokedtokens.
     */
    data: revokedtokenCreateManyInput | revokedtokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * revokedtoken update
   */
  export type revokedtokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the revokedtoken
     */
    select?: revokedtokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the revokedtoken
     */
    omit?: revokedtokenOmit<ExtArgs> | null
    /**
     * The data needed to update a revokedtoken.
     */
    data: XOR<revokedtokenUpdateInput, revokedtokenUncheckedUpdateInput>
    /**
     * Choose, which revokedtoken to update.
     */
    where: revokedtokenWhereUniqueInput
  }

  /**
   * revokedtoken updateMany
   */
  export type revokedtokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update revokedtokens.
     */
    data: XOR<revokedtokenUpdateManyMutationInput, revokedtokenUncheckedUpdateManyInput>
    /**
     * Filter which revokedtokens to update
     */
    where?: revokedtokenWhereInput
    /**
     * Limit how many revokedtokens to update.
     */
    limit?: number
  }

  /**
   * revokedtoken updateManyAndReturn
   */
  export type revokedtokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the revokedtoken
     */
    select?: revokedtokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the revokedtoken
     */
    omit?: revokedtokenOmit<ExtArgs> | null
    /**
     * The data used to update revokedtokens.
     */
    data: XOR<revokedtokenUpdateManyMutationInput, revokedtokenUncheckedUpdateManyInput>
    /**
     * Filter which revokedtokens to update
     */
    where?: revokedtokenWhereInput
    /**
     * Limit how many revokedtokens to update.
     */
    limit?: number
  }

  /**
   * revokedtoken upsert
   */
  export type revokedtokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the revokedtoken
     */
    select?: revokedtokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the revokedtoken
     */
    omit?: revokedtokenOmit<ExtArgs> | null
    /**
     * The filter to search for the revokedtoken to update in case it exists.
     */
    where: revokedtokenWhereUniqueInput
    /**
     * In case the revokedtoken found by the `where` argument doesn't exist, create a new revokedtoken with this data.
     */
    create: XOR<revokedtokenCreateInput, revokedtokenUncheckedCreateInput>
    /**
     * In case the revokedtoken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<revokedtokenUpdateInput, revokedtokenUncheckedUpdateInput>
  }

  /**
   * revokedtoken delete
   */
  export type revokedtokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the revokedtoken
     */
    select?: revokedtokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the revokedtoken
     */
    omit?: revokedtokenOmit<ExtArgs> | null
    /**
     * Filter which revokedtoken to delete.
     */
    where: revokedtokenWhereUniqueInput
  }

  /**
   * revokedtoken deleteMany
   */
  export type revokedtokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which revokedtokens to delete
     */
    where?: revokedtokenWhereInput
    /**
     * Limit how many revokedtokens to delete.
     */
    limit?: number
  }

  /**
   * revokedtoken without action
   */
  export type revokedtokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the revokedtoken
     */
    select?: revokedtokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the revokedtoken
     */
    omit?: revokedtokenOmit<ExtArgs> | null
  }


  /**
   * Model role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdby: string | null
    createdat: Date | null
    updatedby: string | null
    updatedat: Date | null
    issystemrole: boolean | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdby: string | null
    createdat: Date | null
    updatedby: string | null
    updatedat: Date | null
    issystemrole: boolean | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    createdby: number
    createdat: number
    updatedby: number
    updatedat: number
    issystemrole: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    createdby?: true
    createdat?: true
    updatedby?: true
    updatedat?: true
    issystemrole?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    createdby?: true
    createdat?: true
    updatedby?: true
    updatedat?: true
    issystemrole?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    createdby?: true
    createdat?: true
    updatedby?: true
    updatedat?: true
    issystemrole?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role to aggregate.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type roleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roleWhereInput
    orderBy?: roleOrderByWithAggregationInput | roleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: roleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    createdby: string
    createdat: Date
    updatedby: string | null
    updatedat: Date | null
    issystemrole: boolean
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends roleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type roleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdby?: boolean
    createdat?: boolean
    updatedby?: boolean
    updatedat?: boolean
    issystemrole?: boolean
    createduser?: boolean | userDefaultArgs<ExtArgs>
    updateduser?: boolean | role$updateduserArgs<ExtArgs>
    rolepermissions?: boolean | role$rolepermissionsArgs<ExtArgs>
    userroles?: boolean | role$userrolesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type roleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdby?: boolean
    createdat?: boolean
    updatedby?: boolean
    updatedat?: boolean
    issystemrole?: boolean
    createduser?: boolean | userDefaultArgs<ExtArgs>
    updateduser?: boolean | role$updateduserArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type roleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdby?: boolean
    createdat?: boolean
    updatedby?: boolean
    updatedat?: boolean
    issystemrole?: boolean
    createduser?: boolean | userDefaultArgs<ExtArgs>
    updateduser?: boolean | role$updateduserArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type roleSelectScalar = {
    id?: boolean
    name?: boolean
    createdby?: boolean
    createdat?: boolean
    updatedby?: boolean
    updatedat?: boolean
    issystemrole?: boolean
  }

  export type roleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdby" | "createdat" | "updatedby" | "updatedat" | "issystemrole", ExtArgs["result"]["role"]>
  export type roleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createduser?: boolean | userDefaultArgs<ExtArgs>
    updateduser?: boolean | role$updateduserArgs<ExtArgs>
    rolepermissions?: boolean | role$rolepermissionsArgs<ExtArgs>
    userroles?: boolean | role$userrolesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type roleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createduser?: boolean | userDefaultArgs<ExtArgs>
    updateduser?: boolean | role$updateduserArgs<ExtArgs>
  }
  export type roleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createduser?: boolean | userDefaultArgs<ExtArgs>
    updateduser?: boolean | role$updateduserArgs<ExtArgs>
  }

  export type $rolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "role"
    objects: {
      createduser: Prisma.$userPayload<ExtArgs>
      updateduser: Prisma.$userPayload<ExtArgs> | null
      rolepermissions: Prisma.$rolepermissionPayload<ExtArgs>[]
      userroles: Prisma.$userrolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdby: string
      createdat: Date
      updatedby: string | null
      updatedat: Date | null
      issystemrole: boolean
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type roleGetPayload<S extends boolean | null | undefined | roleDefaultArgs> = $Result.GetResult<Prisma.$rolePayload, S>

  type roleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<roleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface roleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['role'], meta: { name: 'role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {roleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends roleFindUniqueArgs>(args: SelectSubset<T, roleFindUniqueArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {roleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends roleFindUniqueOrThrowArgs>(args: SelectSubset<T, roleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends roleFindFirstArgs>(args?: SelectSubset<T, roleFindFirstArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends roleFindFirstOrThrowArgs>(args?: SelectSubset<T, roleFindFirstOrThrowArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends roleFindManyArgs>(args?: SelectSubset<T, roleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {roleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends roleCreateArgs>(args: SelectSubset<T, roleCreateArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {roleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends roleCreateManyArgs>(args?: SelectSubset<T, roleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {roleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends roleCreateManyAndReturnArgs>(args?: SelectSubset<T, roleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {roleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends roleDeleteArgs>(args: SelectSubset<T, roleDeleteArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {roleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends roleUpdateArgs>(args: SelectSubset<T, roleUpdateArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {roleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends roleDeleteManyArgs>(args?: SelectSubset<T, roleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends roleUpdateManyArgs>(args: SelectSubset<T, roleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {roleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends roleUpdateManyAndReturnArgs>(args: SelectSubset<T, roleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {roleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends roleUpsertArgs>(args: SelectSubset<T, roleUpsertArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends roleCountArgs>(
      args?: Subset<T, roleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends roleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: roleGroupByArgs['orderBy'] }
        : { orderBy?: roleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, roleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the role model
   */
  readonly fields: roleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__roleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createduser<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updateduser<T extends role$updateduserArgs<ExtArgs> = {}>(args?: Subset<T, role$updateduserArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    rolepermissions<T extends role$rolepermissionsArgs<ExtArgs> = {}>(args?: Subset<T, role$rolepermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userroles<T extends role$userrolesArgs<ExtArgs> = {}>(args?: Subset<T, role$userrolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the role model
   */
  interface roleFieldRefs {
    readonly id: FieldRef<"role", 'String'>
    readonly name: FieldRef<"role", 'String'>
    readonly createdby: FieldRef<"role", 'String'>
    readonly createdat: FieldRef<"role", 'DateTime'>
    readonly updatedby: FieldRef<"role", 'String'>
    readonly updatedat: FieldRef<"role", 'DateTime'>
    readonly issystemrole: FieldRef<"role", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * role findUnique
   */
  export type roleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role findUniqueOrThrow
   */
  export type roleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role findFirst
   */
  export type roleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role findFirstOrThrow
   */
  export type roleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role findMany
   */
  export type roleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role create
   */
  export type roleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The data needed to create a role.
     */
    data: XOR<roleCreateInput, roleUncheckedCreateInput>
  }

  /**
   * role createMany
   */
  export type roleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: roleCreateManyInput | roleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * role createManyAndReturn
   */
  export type roleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * The data used to create many roles.
     */
    data: roleCreateManyInput | roleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * role update
   */
  export type roleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The data needed to update a role.
     */
    data: XOR<roleUpdateInput, roleUncheckedUpdateInput>
    /**
     * Choose, which role to update.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role updateMany
   */
  export type roleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<roleUpdateManyMutationInput, roleUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: roleWhereInput
    /**
     * Limit how many roles to update.
     */
    limit?: number
  }

  /**
   * role updateManyAndReturn
   */
  export type roleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * The data used to update roles.
     */
    data: XOR<roleUpdateManyMutationInput, roleUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: roleWhereInput
    /**
     * Limit how many roles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * role upsert
   */
  export type roleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The filter to search for the role to update in case it exists.
     */
    where: roleWhereUniqueInput
    /**
     * In case the role found by the `where` argument doesn't exist, create a new role with this data.
     */
    create: XOR<roleCreateInput, roleUncheckedCreateInput>
    /**
     * In case the role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<roleUpdateInput, roleUncheckedUpdateInput>
  }

  /**
   * role delete
   */
  export type roleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter which role to delete.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role deleteMany
   */
  export type roleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: roleWhereInput
    /**
     * Limit how many roles to delete.
     */
    limit?: number
  }

  /**
   * role.updateduser
   */
  export type role$updateduserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * role.rolepermissions
   */
  export type role$rolepermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
    where?: rolepermissionWhereInput
    orderBy?: rolepermissionOrderByWithRelationInput | rolepermissionOrderByWithRelationInput[]
    cursor?: rolepermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolepermissionScalarFieldEnum | RolepermissionScalarFieldEnum[]
  }

  /**
   * role.userroles
   */
  export type role$userrolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    where?: userroleWhereInput
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    cursor?: userroleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * role without action
   */
  export type roleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
  }


  /**
   * Model notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    touserid: string | null
    message: string | null
    url: string | null
    createdby: string | null
    createdat: Date | null
    readedat: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    touserid: string | null
    message: string | null
    url: string | null
    createdby: string | null
    createdat: Date | null
    readedat: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    touserid: number
    message: number
    url: number
    createdby: number
    createdat: number
    readedat: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    touserid?: true
    message?: true
    url?: true
    createdby?: true
    createdat?: true
    readedat?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    touserid?: true
    message?: true
    url?: true
    createdby?: true
    createdat?: true
    readedat?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    touserid?: true
    message?: true
    url?: true
    createdby?: true
    createdat?: true
    readedat?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification to aggregate.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type notificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationWhereInput
    orderBy?: notificationOrderByWithAggregationInput | notificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: notificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    touserid: string
    message: string
    url: string
    createdby: string
    createdat: Date
    readedat: Date | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends notificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type notificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    touserid?: boolean
    message?: boolean
    url?: boolean
    createdby?: boolean
    createdat?: boolean
    readedat?: boolean
    to?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type notificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    touserid?: boolean
    message?: boolean
    url?: boolean
    createdby?: boolean
    createdat?: boolean
    readedat?: boolean
    to?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type notificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    touserid?: boolean
    message?: boolean
    url?: boolean
    createdby?: boolean
    createdat?: boolean
    readedat?: boolean
    to?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type notificationSelectScalar = {
    id?: boolean
    touserid?: boolean
    message?: boolean
    url?: boolean
    createdby?: boolean
    createdat?: boolean
    readedat?: boolean
  }

  export type notificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "touserid" | "message" | "url" | "createdby" | "createdat" | "readedat", ExtArgs["result"]["notification"]>
  export type notificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    to?: boolean | userDefaultArgs<ExtArgs>
  }
  export type notificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    to?: boolean | userDefaultArgs<ExtArgs>
  }
  export type notificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    to?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $notificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notification"
    objects: {
      to: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      touserid: string
      message: string
      url: string
      createdby: string
      createdat: Date
      readedat: Date | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type notificationGetPayload<S extends boolean | null | undefined | notificationDefaultArgs> = $Result.GetResult<Prisma.$notificationPayload, S>

  type notificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface notificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notification'], meta: { name: 'notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {notificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationFindUniqueArgs>(args: SelectSubset<T, notificationFindUniqueArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationFindFirstArgs>(args?: SelectSubset<T, notificationFindFirstArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationFindManyArgs>(args?: SelectSubset<T, notificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {notificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends notificationCreateArgs>(args: SelectSubset<T, notificationCreateArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {notificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationCreateManyArgs>(args?: SelectSubset<T, notificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {notificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notificationCreateManyAndReturnArgs>(args?: SelectSubset<T, notificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {notificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends notificationDeleteArgs>(args: SelectSubset<T, notificationDeleteArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {notificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationUpdateArgs>(args: SelectSubset<T, notificationUpdateArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {notificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationDeleteManyArgs>(args?: SelectSubset<T, notificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationUpdateManyArgs>(args: SelectSubset<T, notificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {notificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notificationUpdateManyAndReturnArgs>(args: SelectSubset<T, notificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {notificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends notificationUpsertArgs>(args: SelectSubset<T, notificationUpsertArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationCountArgs>(
      args?: Subset<T, notificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationGroupByArgs['orderBy'] }
        : { orderBy?: notificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notification model
   */
  readonly fields: notificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    to<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notification model
   */
  interface notificationFieldRefs {
    readonly id: FieldRef<"notification", 'String'>
    readonly touserid: FieldRef<"notification", 'String'>
    readonly message: FieldRef<"notification", 'String'>
    readonly url: FieldRef<"notification", 'String'>
    readonly createdby: FieldRef<"notification", 'String'>
    readonly createdat: FieldRef<"notification", 'DateTime'>
    readonly readedat: FieldRef<"notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * notification findUnique
   */
  export type notificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification findUniqueOrThrow
   */
  export type notificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification findFirst
   */
  export type notificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification findFirstOrThrow
   */
  export type notificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification findMany
   */
  export type notificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification create
   */
  export type notificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The data needed to create a notification.
     */
    data: XOR<notificationCreateInput, notificationUncheckedCreateInput>
  }

  /**
   * notification createMany
   */
  export type notificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationCreateManyInput | notificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notification createManyAndReturn
   */
  export type notificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * The data used to create many notifications.
     */
    data: notificationCreateManyInput | notificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notification update
   */
  export type notificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The data needed to update a notification.
     */
    data: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
    /**
     * Choose, which notification to update.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification updateMany
   */
  export type notificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
  }

  /**
   * notification updateManyAndReturn
   */
  export type notificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * notification upsert
   */
  export type notificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The filter to search for the notification to update in case it exists.
     */
    where: notificationWhereUniqueInput
    /**
     * In case the notification found by the `where` argument doesn't exist, create a new notification with this data.
     */
    create: XOR<notificationCreateInput, notificationUncheckedCreateInput>
    /**
     * In case the notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
  }

  /**
   * notification delete
   */
  export type notificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter which notification to delete.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification deleteMany
   */
  export type notificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationWhereInput
    /**
     * Limit how many notifications to delete.
     */
    limit?: number
  }

  /**
   * notification without action
   */
  export type notificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
  }


  /**
   * Model permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    name: string | null
    value: string | null
    group: string | null
    description: string | null
    createdby: string | null
    createdat: Date | null
    updatedby: string | null
    updatedat: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    value: string | null
    group: string | null
    description: string | null
    createdby: string | null
    createdat: Date | null
    updatedby: string | null
    updatedat: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    name: number
    value: number
    group: number
    description: number
    createdby: number
    createdat: number
    updatedby: number
    updatedat: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    name?: true
    value?: true
    group?: true
    description?: true
    createdby?: true
    createdat?: true
    updatedby?: true
    updatedat?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    name?: true
    value?: true
    group?: true
    description?: true
    createdby?: true
    createdat?: true
    updatedby?: true
    updatedat?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    name?: true
    value?: true
    group?: true
    description?: true
    createdby?: true
    createdat?: true
    updatedby?: true
    updatedat?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permission to aggregate.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type permissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permissionWhereInput
    orderBy?: permissionOrderByWithAggregationInput | permissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: permissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    name: string
    value: string
    group: string
    description: string
    createdby: string
    createdat: Date
    updatedby: string | null
    updatedat: Date | null
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends permissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type permissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    group?: boolean
    description?: boolean
    createdby?: boolean
    createdat?: boolean
    updatedby?: boolean
    updatedat?: boolean
    createduser?: boolean | userDefaultArgs<ExtArgs>
    updateduser?: boolean | permission$updateduserArgs<ExtArgs>
    rolepermissions?: boolean | permission$rolepermissionsArgs<ExtArgs>
    userpermissions?: boolean | permission$userpermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type permissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    group?: boolean
    description?: boolean
    createdby?: boolean
    createdat?: boolean
    updatedby?: boolean
    updatedat?: boolean
    createduser?: boolean | userDefaultArgs<ExtArgs>
    updateduser?: boolean | permission$updateduserArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type permissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    group?: boolean
    description?: boolean
    createdby?: boolean
    createdat?: boolean
    updatedby?: boolean
    updatedat?: boolean
    createduser?: boolean | userDefaultArgs<ExtArgs>
    updateduser?: boolean | permission$updateduserArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type permissionSelectScalar = {
    id?: boolean
    name?: boolean
    value?: boolean
    group?: boolean
    description?: boolean
    createdby?: boolean
    createdat?: boolean
    updatedby?: boolean
    updatedat?: boolean
  }

  export type permissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "value" | "group" | "description" | "createdby" | "createdat" | "updatedby" | "updatedat", ExtArgs["result"]["permission"]>
  export type permissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createduser?: boolean | userDefaultArgs<ExtArgs>
    updateduser?: boolean | permission$updateduserArgs<ExtArgs>
    rolepermissions?: boolean | permission$rolepermissionsArgs<ExtArgs>
    userpermissions?: boolean | permission$userpermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type permissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createduser?: boolean | userDefaultArgs<ExtArgs>
    updateduser?: boolean | permission$updateduserArgs<ExtArgs>
  }
  export type permissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createduser?: boolean | userDefaultArgs<ExtArgs>
    updateduser?: boolean | permission$updateduserArgs<ExtArgs>
  }

  export type $permissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "permission"
    objects: {
      createduser: Prisma.$userPayload<ExtArgs>
      updateduser: Prisma.$userPayload<ExtArgs> | null
      rolepermissions: Prisma.$rolepermissionPayload<ExtArgs>[]
      userpermissions: Prisma.$userpermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      value: string
      group: string
      description: string
      createdby: string
      createdat: Date
      updatedby: string | null
      updatedat: Date | null
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type permissionGetPayload<S extends boolean | null | undefined | permissionDefaultArgs> = $Result.GetResult<Prisma.$permissionPayload, S>

  type permissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<permissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface permissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['permission'], meta: { name: 'permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {permissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends permissionFindUniqueArgs>(args: SelectSubset<T, permissionFindUniqueArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {permissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends permissionFindUniqueOrThrowArgs>(args: SelectSubset<T, permissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends permissionFindFirstArgs>(args?: SelectSubset<T, permissionFindFirstArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends permissionFindFirstOrThrowArgs>(args?: SelectSubset<T, permissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends permissionFindManyArgs>(args?: SelectSubset<T, permissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {permissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends permissionCreateArgs>(args: SelectSubset<T, permissionCreateArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {permissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends permissionCreateManyArgs>(args?: SelectSubset<T, permissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {permissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends permissionCreateManyAndReturnArgs>(args?: SelectSubset<T, permissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permission.
     * @param {permissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends permissionDeleteArgs>(args: SelectSubset<T, permissionDeleteArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {permissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends permissionUpdateArgs>(args: SelectSubset<T, permissionUpdateArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {permissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends permissionDeleteManyArgs>(args?: SelectSubset<T, permissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends permissionUpdateManyArgs>(args: SelectSubset<T, permissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {permissionUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends permissionUpdateManyAndReturnArgs>(args: SelectSubset<T, permissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permission.
     * @param {permissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends permissionUpsertArgs>(args: SelectSubset<T, permissionUpsertArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends permissionCountArgs>(
      args?: Subset<T, permissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends permissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: permissionGroupByArgs['orderBy'] }
        : { orderBy?: permissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, permissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the permission model
   */
  readonly fields: permissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__permissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createduser<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updateduser<T extends permission$updateduserArgs<ExtArgs> = {}>(args?: Subset<T, permission$updateduserArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    rolepermissions<T extends permission$rolepermissionsArgs<ExtArgs> = {}>(args?: Subset<T, permission$rolepermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userpermissions<T extends permission$userpermissionsArgs<ExtArgs> = {}>(args?: Subset<T, permission$userpermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userpermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the permission model
   */
  interface permissionFieldRefs {
    readonly id: FieldRef<"permission", 'String'>
    readonly name: FieldRef<"permission", 'String'>
    readonly value: FieldRef<"permission", 'String'>
    readonly group: FieldRef<"permission", 'String'>
    readonly description: FieldRef<"permission", 'String'>
    readonly createdby: FieldRef<"permission", 'String'>
    readonly createdat: FieldRef<"permission", 'DateTime'>
    readonly updatedby: FieldRef<"permission", 'String'>
    readonly updatedat: FieldRef<"permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * permission findUnique
   */
  export type permissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where: permissionWhereUniqueInput
  }

  /**
   * permission findUniqueOrThrow
   */
  export type permissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where: permissionWhereUniqueInput
  }

  /**
   * permission findFirst
   */
  export type permissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * permission findFirstOrThrow
   */
  export type permissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * permission findMany
   */
  export type permissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing permissions.
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * permission create
   */
  export type permissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * The data needed to create a permission.
     */
    data: XOR<permissionCreateInput, permissionUncheckedCreateInput>
  }

  /**
   * permission createMany
   */
  export type permissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many permissions.
     */
    data: permissionCreateManyInput | permissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * permission createManyAndReturn
   */
  export type permissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * The data used to create many permissions.
     */
    data: permissionCreateManyInput | permissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * permission update
   */
  export type permissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * The data needed to update a permission.
     */
    data: XOR<permissionUpdateInput, permissionUncheckedUpdateInput>
    /**
     * Choose, which permission to update.
     */
    where: permissionWhereUniqueInput
  }

  /**
   * permission updateMany
   */
  export type permissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update permissions.
     */
    data: XOR<permissionUpdateManyMutationInput, permissionUncheckedUpdateManyInput>
    /**
     * Filter which permissions to update
     */
    where?: permissionWhereInput
    /**
     * Limit how many permissions to update.
     */
    limit?: number
  }

  /**
   * permission updateManyAndReturn
   */
  export type permissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * The data used to update permissions.
     */
    data: XOR<permissionUpdateManyMutationInput, permissionUncheckedUpdateManyInput>
    /**
     * Filter which permissions to update
     */
    where?: permissionWhereInput
    /**
     * Limit how many permissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * permission upsert
   */
  export type permissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * The filter to search for the permission to update in case it exists.
     */
    where: permissionWhereUniqueInput
    /**
     * In case the permission found by the `where` argument doesn't exist, create a new permission with this data.
     */
    create: XOR<permissionCreateInput, permissionUncheckedCreateInput>
    /**
     * In case the permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<permissionUpdateInput, permissionUncheckedUpdateInput>
  }

  /**
   * permission delete
   */
  export type permissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter which permission to delete.
     */
    where: permissionWhereUniqueInput
  }

  /**
   * permission deleteMany
   */
  export type permissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissions to delete
     */
    where?: permissionWhereInput
    /**
     * Limit how many permissions to delete.
     */
    limit?: number
  }

  /**
   * permission.updateduser
   */
  export type permission$updateduserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * permission.rolepermissions
   */
  export type permission$rolepermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
    where?: rolepermissionWhereInput
    orderBy?: rolepermissionOrderByWithRelationInput | rolepermissionOrderByWithRelationInput[]
    cursor?: rolepermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolepermissionScalarFieldEnum | RolepermissionScalarFieldEnum[]
  }

  /**
   * permission.userpermissions
   */
  export type permission$userpermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userpermission
     */
    select?: userpermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userpermission
     */
    omit?: userpermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userpermissionInclude<ExtArgs> | null
    where?: userpermissionWhereInput
    orderBy?: userpermissionOrderByWithRelationInput | userpermissionOrderByWithRelationInput[]
    cursor?: userpermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserpermissionScalarFieldEnum | UserpermissionScalarFieldEnum[]
  }

  /**
   * permission without action
   */
  export type permissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
  }


  /**
   * Model rolepermission
   */

  export type AggregateRolepermission = {
    _count: RolepermissionCountAggregateOutputType | null
    _min: RolepermissionMinAggregateOutputType | null
    _max: RolepermissionMaxAggregateOutputType | null
  }

  export type RolepermissionMinAggregateOutputType = {
    id: string | null
    roleid: string | null
    permissionid: string | null
    createdat: Date | null
    createdby: string | null
    updatedby: string | null
    updatedat: Date | null
  }

  export type RolepermissionMaxAggregateOutputType = {
    id: string | null
    roleid: string | null
    permissionid: string | null
    createdat: Date | null
    createdby: string | null
    updatedby: string | null
    updatedat: Date | null
  }

  export type RolepermissionCountAggregateOutputType = {
    id: number
    roleid: number
    permissionid: number
    createdat: number
    createdby: number
    updatedby: number
    updatedat: number
    _all: number
  }


  export type RolepermissionMinAggregateInputType = {
    id?: true
    roleid?: true
    permissionid?: true
    createdat?: true
    createdby?: true
    updatedby?: true
    updatedat?: true
  }

  export type RolepermissionMaxAggregateInputType = {
    id?: true
    roleid?: true
    permissionid?: true
    createdat?: true
    createdby?: true
    updatedby?: true
    updatedat?: true
  }

  export type RolepermissionCountAggregateInputType = {
    id?: true
    roleid?: true
    permissionid?: true
    createdat?: true
    createdby?: true
    updatedby?: true
    updatedat?: true
    _all?: true
  }

  export type RolepermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rolepermission to aggregate.
     */
    where?: rolepermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rolepermissions to fetch.
     */
    orderBy?: rolepermissionOrderByWithRelationInput | rolepermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolepermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rolepermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rolepermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rolepermissions
    **/
    _count?: true | RolepermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolepermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolepermissionMaxAggregateInputType
  }

  export type GetRolepermissionAggregateType<T extends RolepermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolepermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolepermission[P]>
      : GetScalarType<T[P], AggregateRolepermission[P]>
  }




  export type rolepermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolepermissionWhereInput
    orderBy?: rolepermissionOrderByWithAggregationInput | rolepermissionOrderByWithAggregationInput[]
    by: RolepermissionScalarFieldEnum[] | RolepermissionScalarFieldEnum
    having?: rolepermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolepermissionCountAggregateInputType | true
    _min?: RolepermissionMinAggregateInputType
    _max?: RolepermissionMaxAggregateInputType
  }

  export type RolepermissionGroupByOutputType = {
    id: string
    roleid: string
    permissionid: string
    createdat: Date
    createdby: string
    updatedby: string | null
    updatedat: Date | null
    _count: RolepermissionCountAggregateOutputType | null
    _min: RolepermissionMinAggregateOutputType | null
    _max: RolepermissionMaxAggregateOutputType | null
  }

  type GetRolepermissionGroupByPayload<T extends rolepermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolepermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolepermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolepermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolepermissionGroupByOutputType[P]>
        }
      >
    >


  export type rolepermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleid?: boolean
    permissionid?: boolean
    createdat?: boolean
    createdby?: boolean
    updatedby?: boolean
    updatedat?: boolean
    createduser?: boolean | userDefaultArgs<ExtArgs>
    permission?: boolean | permissionDefaultArgs<ExtArgs>
    role?: boolean | roleDefaultArgs<ExtArgs>
    updateduser?: boolean | rolepermission$updateduserArgs<ExtArgs>
  }, ExtArgs["result"]["rolepermission"]>

  export type rolepermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleid?: boolean
    permissionid?: boolean
    createdat?: boolean
    createdby?: boolean
    updatedby?: boolean
    updatedat?: boolean
    createduser?: boolean | userDefaultArgs<ExtArgs>
    permission?: boolean | permissionDefaultArgs<ExtArgs>
    role?: boolean | roleDefaultArgs<ExtArgs>
    updateduser?: boolean | rolepermission$updateduserArgs<ExtArgs>
  }, ExtArgs["result"]["rolepermission"]>

  export type rolepermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleid?: boolean
    permissionid?: boolean
    createdat?: boolean
    createdby?: boolean
    updatedby?: boolean
    updatedat?: boolean
    createduser?: boolean | userDefaultArgs<ExtArgs>
    permission?: boolean | permissionDefaultArgs<ExtArgs>
    role?: boolean | roleDefaultArgs<ExtArgs>
    updateduser?: boolean | rolepermission$updateduserArgs<ExtArgs>
  }, ExtArgs["result"]["rolepermission"]>

  export type rolepermissionSelectScalar = {
    id?: boolean
    roleid?: boolean
    permissionid?: boolean
    createdat?: boolean
    createdby?: boolean
    updatedby?: boolean
    updatedat?: boolean
  }

  export type rolepermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roleid" | "permissionid" | "createdat" | "createdby" | "updatedby" | "updatedat", ExtArgs["result"]["rolepermission"]>
  export type rolepermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createduser?: boolean | userDefaultArgs<ExtArgs>
    permission?: boolean | permissionDefaultArgs<ExtArgs>
    role?: boolean | roleDefaultArgs<ExtArgs>
    updateduser?: boolean | rolepermission$updateduserArgs<ExtArgs>
  }
  export type rolepermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createduser?: boolean | userDefaultArgs<ExtArgs>
    permission?: boolean | permissionDefaultArgs<ExtArgs>
    role?: boolean | roleDefaultArgs<ExtArgs>
    updateduser?: boolean | rolepermission$updateduserArgs<ExtArgs>
  }
  export type rolepermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createduser?: boolean | userDefaultArgs<ExtArgs>
    permission?: boolean | permissionDefaultArgs<ExtArgs>
    role?: boolean | roleDefaultArgs<ExtArgs>
    updateduser?: boolean | rolepermission$updateduserArgs<ExtArgs>
  }

  export type $rolepermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rolepermission"
    objects: {
      createduser: Prisma.$userPayload<ExtArgs>
      permission: Prisma.$permissionPayload<ExtArgs>
      role: Prisma.$rolePayload<ExtArgs>
      updateduser: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roleid: string
      permissionid: string
      createdat: Date
      createdby: string
      updatedby: string | null
      updatedat: Date | null
    }, ExtArgs["result"]["rolepermission"]>
    composites: {}
  }

  type rolepermissionGetPayload<S extends boolean | null | undefined | rolepermissionDefaultArgs> = $Result.GetResult<Prisma.$rolepermissionPayload, S>

  type rolepermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rolepermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolepermissionCountAggregateInputType | true
    }

  export interface rolepermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rolepermission'], meta: { name: 'rolepermission' } }
    /**
     * Find zero or one Rolepermission that matches the filter.
     * @param {rolepermissionFindUniqueArgs} args - Arguments to find a Rolepermission
     * @example
     * // Get one Rolepermission
     * const rolepermission = await prisma.rolepermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rolepermissionFindUniqueArgs>(args: SelectSubset<T, rolepermissionFindUniqueArgs<ExtArgs>>): Prisma__rolepermissionClient<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rolepermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rolepermissionFindUniqueOrThrowArgs} args - Arguments to find a Rolepermission
     * @example
     * // Get one Rolepermission
     * const rolepermission = await prisma.rolepermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rolepermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, rolepermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rolepermissionClient<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rolepermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolepermissionFindFirstArgs} args - Arguments to find a Rolepermission
     * @example
     * // Get one Rolepermission
     * const rolepermission = await prisma.rolepermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rolepermissionFindFirstArgs>(args?: SelectSubset<T, rolepermissionFindFirstArgs<ExtArgs>>): Prisma__rolepermissionClient<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rolepermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolepermissionFindFirstOrThrowArgs} args - Arguments to find a Rolepermission
     * @example
     * // Get one Rolepermission
     * const rolepermission = await prisma.rolepermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rolepermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, rolepermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__rolepermissionClient<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rolepermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolepermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rolepermissions
     * const rolepermissions = await prisma.rolepermission.findMany()
     * 
     * // Get first 10 Rolepermissions
     * const rolepermissions = await prisma.rolepermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolepermissionWithIdOnly = await prisma.rolepermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rolepermissionFindManyArgs>(args?: SelectSubset<T, rolepermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rolepermission.
     * @param {rolepermissionCreateArgs} args - Arguments to create a Rolepermission.
     * @example
     * // Create one Rolepermission
     * const Rolepermission = await prisma.rolepermission.create({
     *   data: {
     *     // ... data to create a Rolepermission
     *   }
     * })
     * 
     */
    create<T extends rolepermissionCreateArgs>(args: SelectSubset<T, rolepermissionCreateArgs<ExtArgs>>): Prisma__rolepermissionClient<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rolepermissions.
     * @param {rolepermissionCreateManyArgs} args - Arguments to create many Rolepermissions.
     * @example
     * // Create many Rolepermissions
     * const rolepermission = await prisma.rolepermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rolepermissionCreateManyArgs>(args?: SelectSubset<T, rolepermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rolepermissions and returns the data saved in the database.
     * @param {rolepermissionCreateManyAndReturnArgs} args - Arguments to create many Rolepermissions.
     * @example
     * // Create many Rolepermissions
     * const rolepermission = await prisma.rolepermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rolepermissions and only return the `id`
     * const rolepermissionWithIdOnly = await prisma.rolepermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends rolepermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, rolepermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rolepermission.
     * @param {rolepermissionDeleteArgs} args - Arguments to delete one Rolepermission.
     * @example
     * // Delete one Rolepermission
     * const Rolepermission = await prisma.rolepermission.delete({
     *   where: {
     *     // ... filter to delete one Rolepermission
     *   }
     * })
     * 
     */
    delete<T extends rolepermissionDeleteArgs>(args: SelectSubset<T, rolepermissionDeleteArgs<ExtArgs>>): Prisma__rolepermissionClient<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rolepermission.
     * @param {rolepermissionUpdateArgs} args - Arguments to update one Rolepermission.
     * @example
     * // Update one Rolepermission
     * const rolepermission = await prisma.rolepermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rolepermissionUpdateArgs>(args: SelectSubset<T, rolepermissionUpdateArgs<ExtArgs>>): Prisma__rolepermissionClient<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rolepermissions.
     * @param {rolepermissionDeleteManyArgs} args - Arguments to filter Rolepermissions to delete.
     * @example
     * // Delete a few Rolepermissions
     * const { count } = await prisma.rolepermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rolepermissionDeleteManyArgs>(args?: SelectSubset<T, rolepermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rolepermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolepermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rolepermissions
     * const rolepermission = await prisma.rolepermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rolepermissionUpdateManyArgs>(args: SelectSubset<T, rolepermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rolepermissions and returns the data updated in the database.
     * @param {rolepermissionUpdateManyAndReturnArgs} args - Arguments to update many Rolepermissions.
     * @example
     * // Update many Rolepermissions
     * const rolepermission = await prisma.rolepermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rolepermissions and only return the `id`
     * const rolepermissionWithIdOnly = await prisma.rolepermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends rolepermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, rolepermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rolepermission.
     * @param {rolepermissionUpsertArgs} args - Arguments to update or create a Rolepermission.
     * @example
     * // Update or create a Rolepermission
     * const rolepermission = await prisma.rolepermission.upsert({
     *   create: {
     *     // ... data to create a Rolepermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rolepermission we want to update
     *   }
     * })
     */
    upsert<T extends rolepermissionUpsertArgs>(args: SelectSubset<T, rolepermissionUpsertArgs<ExtArgs>>): Prisma__rolepermissionClient<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rolepermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolepermissionCountArgs} args - Arguments to filter Rolepermissions to count.
     * @example
     * // Count the number of Rolepermissions
     * const count = await prisma.rolepermission.count({
     *   where: {
     *     // ... the filter for the Rolepermissions we want to count
     *   }
     * })
    **/
    count<T extends rolepermissionCountArgs>(
      args?: Subset<T, rolepermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolepermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rolepermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolepermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolepermissionAggregateArgs>(args: Subset<T, RolepermissionAggregateArgs>): Prisma.PrismaPromise<GetRolepermissionAggregateType<T>>

    /**
     * Group by Rolepermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolepermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rolepermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rolepermissionGroupByArgs['orderBy'] }
        : { orderBy?: rolepermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rolepermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolepermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rolepermission model
   */
  readonly fields: rolepermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rolepermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rolepermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createduser<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    permission<T extends permissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, permissionDefaultArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends roleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, roleDefaultArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updateduser<T extends rolepermission$updateduserArgs<ExtArgs> = {}>(args?: Subset<T, rolepermission$updateduserArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rolepermission model
   */
  interface rolepermissionFieldRefs {
    readonly id: FieldRef<"rolepermission", 'String'>
    readonly roleid: FieldRef<"rolepermission", 'String'>
    readonly permissionid: FieldRef<"rolepermission", 'String'>
    readonly createdat: FieldRef<"rolepermission", 'DateTime'>
    readonly createdby: FieldRef<"rolepermission", 'String'>
    readonly updatedby: FieldRef<"rolepermission", 'String'>
    readonly updatedat: FieldRef<"rolepermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * rolepermission findUnique
   */
  export type rolepermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
    /**
     * Filter, which rolepermission to fetch.
     */
    where: rolepermissionWhereUniqueInput
  }

  /**
   * rolepermission findUniqueOrThrow
   */
  export type rolepermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
    /**
     * Filter, which rolepermission to fetch.
     */
    where: rolepermissionWhereUniqueInput
  }

  /**
   * rolepermission findFirst
   */
  export type rolepermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
    /**
     * Filter, which rolepermission to fetch.
     */
    where?: rolepermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rolepermissions to fetch.
     */
    orderBy?: rolepermissionOrderByWithRelationInput | rolepermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rolepermissions.
     */
    cursor?: rolepermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rolepermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rolepermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rolepermissions.
     */
    distinct?: RolepermissionScalarFieldEnum | RolepermissionScalarFieldEnum[]
  }

  /**
   * rolepermission findFirstOrThrow
   */
  export type rolepermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
    /**
     * Filter, which rolepermission to fetch.
     */
    where?: rolepermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rolepermissions to fetch.
     */
    orderBy?: rolepermissionOrderByWithRelationInput | rolepermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rolepermissions.
     */
    cursor?: rolepermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rolepermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rolepermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rolepermissions.
     */
    distinct?: RolepermissionScalarFieldEnum | RolepermissionScalarFieldEnum[]
  }

  /**
   * rolepermission findMany
   */
  export type rolepermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
    /**
     * Filter, which rolepermissions to fetch.
     */
    where?: rolepermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rolepermissions to fetch.
     */
    orderBy?: rolepermissionOrderByWithRelationInput | rolepermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rolepermissions.
     */
    cursor?: rolepermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rolepermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rolepermissions.
     */
    skip?: number
    distinct?: RolepermissionScalarFieldEnum | RolepermissionScalarFieldEnum[]
  }

  /**
   * rolepermission create
   */
  export type rolepermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a rolepermission.
     */
    data: XOR<rolepermissionCreateInput, rolepermissionUncheckedCreateInput>
  }

  /**
   * rolepermission createMany
   */
  export type rolepermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rolepermissions.
     */
    data: rolepermissionCreateManyInput | rolepermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rolepermission createManyAndReturn
   */
  export type rolepermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * The data used to create many rolepermissions.
     */
    data: rolepermissionCreateManyInput | rolepermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * rolepermission update
   */
  export type rolepermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a rolepermission.
     */
    data: XOR<rolepermissionUpdateInput, rolepermissionUncheckedUpdateInput>
    /**
     * Choose, which rolepermission to update.
     */
    where: rolepermissionWhereUniqueInput
  }

  /**
   * rolepermission updateMany
   */
  export type rolepermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rolepermissions.
     */
    data: XOR<rolepermissionUpdateManyMutationInput, rolepermissionUncheckedUpdateManyInput>
    /**
     * Filter which rolepermissions to update
     */
    where?: rolepermissionWhereInput
    /**
     * Limit how many rolepermissions to update.
     */
    limit?: number
  }

  /**
   * rolepermission updateManyAndReturn
   */
  export type rolepermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * The data used to update rolepermissions.
     */
    data: XOR<rolepermissionUpdateManyMutationInput, rolepermissionUncheckedUpdateManyInput>
    /**
     * Filter which rolepermissions to update
     */
    where?: rolepermissionWhereInput
    /**
     * Limit how many rolepermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * rolepermission upsert
   */
  export type rolepermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the rolepermission to update in case it exists.
     */
    where: rolepermissionWhereUniqueInput
    /**
     * In case the rolepermission found by the `where` argument doesn't exist, create a new rolepermission with this data.
     */
    create: XOR<rolepermissionCreateInput, rolepermissionUncheckedCreateInput>
    /**
     * In case the rolepermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolepermissionUpdateInput, rolepermissionUncheckedUpdateInput>
  }

  /**
   * rolepermission delete
   */
  export type rolepermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
    /**
     * Filter which rolepermission to delete.
     */
    where: rolepermissionWhereUniqueInput
  }

  /**
   * rolepermission deleteMany
   */
  export type rolepermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rolepermissions to delete
     */
    where?: rolepermissionWhereInput
    /**
     * Limit how many rolepermissions to delete.
     */
    limit?: number
  }

  /**
   * rolepermission.updateduser
   */
  export type rolepermission$updateduserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * rolepermission without action
   */
  export type rolepermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
  }


  /**
   * Model transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    type: number | null
  }

  export type TransactionSumAggregateOutputType = {
    type: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    type: number | null
    useragent: string | null
    ipaddress: string | null
    userid: string | null
    createdat: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    type: number | null
    useragent: string | null
    ipaddress: string | null
    userid: string | null
    createdat: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    type: number
    useragent: number
    ipaddress: number
    userid: number
    createdat: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    type?: true
  }

  export type TransactionSumAggregateInputType = {
    type?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    type?: true
    useragent?: true
    ipaddress?: true
    userid?: true
    createdat?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    type?: true
    useragent?: true
    ipaddress?: true
    userid?: true
    createdat?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    type?: true
    useragent?: true
    ipaddress?: true
    userid?: true
    createdat?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaction to aggregate.
     */
    where?: transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type transactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionWhereInput
    orderBy?: transactionOrderByWithAggregationInput | transactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: transactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    type: number
    useragent: string
    ipaddress: string
    userid: string
    createdat: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends transactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type transactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    useragent?: boolean
    ipaddress?: boolean
    userid?: boolean
    createdat?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type transactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    useragent?: boolean
    ipaddress?: boolean
    userid?: boolean
    createdat?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type transactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    useragent?: boolean
    ipaddress?: boolean
    userid?: boolean
    createdat?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type transactionSelectScalar = {
    id?: boolean
    type?: boolean
    useragent?: boolean
    ipaddress?: boolean
    userid?: boolean
    createdat?: boolean
  }

  export type transactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "useragent" | "ipaddress" | "userid" | "createdat", ExtArgs["result"]["transaction"]>
  export type transactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type transactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type transactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $transactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transaction"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: number
      useragent: string
      ipaddress: string
      userid: string
      createdat: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type transactionGetPayload<S extends boolean | null | undefined | transactionDefaultArgs> = $Result.GetResult<Prisma.$transactionPayload, S>

  type transactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<transactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface transactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transaction'], meta: { name: 'transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {transactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transactionFindUniqueArgs>(args: SelectSubset<T, transactionFindUniqueArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {transactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transactionFindUniqueOrThrowArgs>(args: SelectSubset<T, transactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transactionFindFirstArgs>(args?: SelectSubset<T, transactionFindFirstArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transactionFindFirstOrThrowArgs>(args?: SelectSubset<T, transactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends transactionFindManyArgs>(args?: SelectSubset<T, transactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {transactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends transactionCreateArgs>(args: SelectSubset<T, transactionCreateArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {transactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transactionCreateManyArgs>(args?: SelectSubset<T, transactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {transactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends transactionCreateManyAndReturnArgs>(args?: SelectSubset<T, transactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {transactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends transactionDeleteArgs>(args: SelectSubset<T, transactionDeleteArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {transactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transactionUpdateArgs>(args: SelectSubset<T, transactionUpdateArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {transactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transactionDeleteManyArgs>(args?: SelectSubset<T, transactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transactionUpdateManyArgs>(args: SelectSubset<T, transactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {transactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends transactionUpdateManyAndReturnArgs>(args: SelectSubset<T, transactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {transactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends transactionUpsertArgs>(args: SelectSubset<T, transactionUpsertArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends transactionCountArgs>(
      args?: Subset<T, transactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transactionGroupByArgs['orderBy'] }
        : { orderBy?: transactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transaction model
   */
  readonly fields: transactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transaction model
   */
  interface transactionFieldRefs {
    readonly id: FieldRef<"transaction", 'String'>
    readonly type: FieldRef<"transaction", 'Int'>
    readonly useragent: FieldRef<"transaction", 'String'>
    readonly ipaddress: FieldRef<"transaction", 'String'>
    readonly userid: FieldRef<"transaction", 'String'>
    readonly createdat: FieldRef<"transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * transaction findUnique
   */
  export type transactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transaction to fetch.
     */
    where: transactionWhereUniqueInput
  }

  /**
   * transaction findUniqueOrThrow
   */
  export type transactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transaction to fetch.
     */
    where: transactionWhereUniqueInput
  }

  /**
   * transaction findFirst
   */
  export type transactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transaction to fetch.
     */
    where?: transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * transaction findFirstOrThrow
   */
  export type transactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transaction to fetch.
     */
    where?: transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * transaction findMany
   */
  export type transactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transactions.
     */
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * transaction create
   */
  export type transactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * The data needed to create a transaction.
     */
    data: XOR<transactionCreateInput, transactionUncheckedCreateInput>
  }

  /**
   * transaction createMany
   */
  export type transactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transactions.
     */
    data: transactionCreateManyInput | transactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transaction createManyAndReturn
   */
  export type transactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * The data used to create many transactions.
     */
    data: transactionCreateManyInput | transactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * transaction update
   */
  export type transactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * The data needed to update a transaction.
     */
    data: XOR<transactionUpdateInput, transactionUncheckedUpdateInput>
    /**
     * Choose, which transaction to update.
     */
    where: transactionWhereUniqueInput
  }

  /**
   * transaction updateMany
   */
  export type transactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transactions.
     */
    data: XOR<transactionUpdateManyMutationInput, transactionUncheckedUpdateManyInput>
    /**
     * Filter which transactions to update
     */
    where?: transactionWhereInput
    /**
     * Limit how many transactions to update.
     */
    limit?: number
  }

  /**
   * transaction updateManyAndReturn
   */
  export type transactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * The data used to update transactions.
     */
    data: XOR<transactionUpdateManyMutationInput, transactionUncheckedUpdateManyInput>
    /**
     * Filter which transactions to update
     */
    where?: transactionWhereInput
    /**
     * Limit how many transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * transaction upsert
   */
  export type transactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * The filter to search for the transaction to update in case it exists.
     */
    where: transactionWhereUniqueInput
    /**
     * In case the transaction found by the `where` argument doesn't exist, create a new transaction with this data.
     */
    create: XOR<transactionCreateInput, transactionUncheckedCreateInput>
    /**
     * In case the transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transactionUpdateInput, transactionUncheckedUpdateInput>
  }

  /**
   * transaction delete
   */
  export type transactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter which transaction to delete.
     */
    where: transactionWhereUniqueInput
  }

  /**
   * transaction deleteMany
   */
  export type transactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactions to delete
     */
    where?: transactionWhereInput
    /**
     * Limit how many transactions to delete.
     */
    limit?: number
  }

  /**
   * transaction without action
   */
  export type transactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
  }


  /**
   * Model entrance
   */

  export type AggregateEntrance = {
    _count: EntranceCountAggregateOutputType | null
    _min: EntranceMinAggregateOutputType | null
    _max: EntranceMaxAggregateOutputType | null
  }

  export type EntranceMinAggregateOutputType = {
    id: string | null
    type: string | null
    useragent: string | null
    ipaddress: string | null
    userid: string | null
    createdat: Date | null
  }

  export type EntranceMaxAggregateOutputType = {
    id: string | null
    type: string | null
    useragent: string | null
    ipaddress: string | null
    userid: string | null
    createdat: Date | null
  }

  export type EntranceCountAggregateOutputType = {
    id: number
    type: number
    useragent: number
    ipaddress: number
    userid: number
    createdat: number
    _all: number
  }


  export type EntranceMinAggregateInputType = {
    id?: true
    type?: true
    useragent?: true
    ipaddress?: true
    userid?: true
    createdat?: true
  }

  export type EntranceMaxAggregateInputType = {
    id?: true
    type?: true
    useragent?: true
    ipaddress?: true
    userid?: true
    createdat?: true
  }

  export type EntranceCountAggregateInputType = {
    id?: true
    type?: true
    useragent?: true
    ipaddress?: true
    userid?: true
    createdat?: true
    _all?: true
  }

  export type EntranceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which entrance to aggregate.
     */
    where?: entranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entrances to fetch.
     */
    orderBy?: entranceOrderByWithRelationInput | entranceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: entranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entrances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entrances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned entrances
    **/
    _count?: true | EntranceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntranceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntranceMaxAggregateInputType
  }

  export type GetEntranceAggregateType<T extends EntranceAggregateArgs> = {
        [P in keyof T & keyof AggregateEntrance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntrance[P]>
      : GetScalarType<T[P], AggregateEntrance[P]>
  }




  export type entranceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: entranceWhereInput
    orderBy?: entranceOrderByWithAggregationInput | entranceOrderByWithAggregationInput[]
    by: EntranceScalarFieldEnum[] | EntranceScalarFieldEnum
    having?: entranceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntranceCountAggregateInputType | true
    _min?: EntranceMinAggregateInputType
    _max?: EntranceMaxAggregateInputType
  }

  export type EntranceGroupByOutputType = {
    id: string
    type: string
    useragent: string
    ipaddress: string
    userid: string
    createdat: Date
    _count: EntranceCountAggregateOutputType | null
    _min: EntranceMinAggregateOutputType | null
    _max: EntranceMaxAggregateOutputType | null
  }

  type GetEntranceGroupByPayload<T extends entranceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntranceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntranceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntranceGroupByOutputType[P]>
            : GetScalarType<T[P], EntranceGroupByOutputType[P]>
        }
      >
    >


  export type entranceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    useragent?: boolean
    ipaddress?: boolean
    userid?: boolean
    createdat?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entrance"]>

  export type entranceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    useragent?: boolean
    ipaddress?: boolean
    userid?: boolean
    createdat?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entrance"]>

  export type entranceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    useragent?: boolean
    ipaddress?: boolean
    userid?: boolean
    createdat?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entrance"]>

  export type entranceSelectScalar = {
    id?: boolean
    type?: boolean
    useragent?: boolean
    ipaddress?: boolean
    userid?: boolean
    createdat?: boolean
  }

  export type entranceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "useragent" | "ipaddress" | "userid" | "createdat", ExtArgs["result"]["entrance"]>
  export type entranceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type entranceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type entranceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $entrancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "entrance"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      useragent: string
      ipaddress: string
      userid: string
      createdat: Date
    }, ExtArgs["result"]["entrance"]>
    composites: {}
  }

  type entranceGetPayload<S extends boolean | null | undefined | entranceDefaultArgs> = $Result.GetResult<Prisma.$entrancePayload, S>

  type entranceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<entranceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EntranceCountAggregateInputType | true
    }

  export interface entranceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['entrance'], meta: { name: 'entrance' } }
    /**
     * Find zero or one Entrance that matches the filter.
     * @param {entranceFindUniqueArgs} args - Arguments to find a Entrance
     * @example
     * // Get one Entrance
     * const entrance = await prisma.entrance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends entranceFindUniqueArgs>(args: SelectSubset<T, entranceFindUniqueArgs<ExtArgs>>): Prisma__entranceClient<$Result.GetResult<Prisma.$entrancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Entrance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {entranceFindUniqueOrThrowArgs} args - Arguments to find a Entrance
     * @example
     * // Get one Entrance
     * const entrance = await prisma.entrance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends entranceFindUniqueOrThrowArgs>(args: SelectSubset<T, entranceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__entranceClient<$Result.GetResult<Prisma.$entrancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Entrance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entranceFindFirstArgs} args - Arguments to find a Entrance
     * @example
     * // Get one Entrance
     * const entrance = await prisma.entrance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends entranceFindFirstArgs>(args?: SelectSubset<T, entranceFindFirstArgs<ExtArgs>>): Prisma__entranceClient<$Result.GetResult<Prisma.$entrancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Entrance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entranceFindFirstOrThrowArgs} args - Arguments to find a Entrance
     * @example
     * // Get one Entrance
     * const entrance = await prisma.entrance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends entranceFindFirstOrThrowArgs>(args?: SelectSubset<T, entranceFindFirstOrThrowArgs<ExtArgs>>): Prisma__entranceClient<$Result.GetResult<Prisma.$entrancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Entrances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entranceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entrances
     * const entrances = await prisma.entrance.findMany()
     * 
     * // Get first 10 Entrances
     * const entrances = await prisma.entrance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entranceWithIdOnly = await prisma.entrance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends entranceFindManyArgs>(args?: SelectSubset<T, entranceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entrancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Entrance.
     * @param {entranceCreateArgs} args - Arguments to create a Entrance.
     * @example
     * // Create one Entrance
     * const Entrance = await prisma.entrance.create({
     *   data: {
     *     // ... data to create a Entrance
     *   }
     * })
     * 
     */
    create<T extends entranceCreateArgs>(args: SelectSubset<T, entranceCreateArgs<ExtArgs>>): Prisma__entranceClient<$Result.GetResult<Prisma.$entrancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Entrances.
     * @param {entranceCreateManyArgs} args - Arguments to create many Entrances.
     * @example
     * // Create many Entrances
     * const entrance = await prisma.entrance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends entranceCreateManyArgs>(args?: SelectSubset<T, entranceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Entrances and returns the data saved in the database.
     * @param {entranceCreateManyAndReturnArgs} args - Arguments to create many Entrances.
     * @example
     * // Create many Entrances
     * const entrance = await prisma.entrance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Entrances and only return the `id`
     * const entranceWithIdOnly = await prisma.entrance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends entranceCreateManyAndReturnArgs>(args?: SelectSubset<T, entranceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entrancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Entrance.
     * @param {entranceDeleteArgs} args - Arguments to delete one Entrance.
     * @example
     * // Delete one Entrance
     * const Entrance = await prisma.entrance.delete({
     *   where: {
     *     // ... filter to delete one Entrance
     *   }
     * })
     * 
     */
    delete<T extends entranceDeleteArgs>(args: SelectSubset<T, entranceDeleteArgs<ExtArgs>>): Prisma__entranceClient<$Result.GetResult<Prisma.$entrancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Entrance.
     * @param {entranceUpdateArgs} args - Arguments to update one Entrance.
     * @example
     * // Update one Entrance
     * const entrance = await prisma.entrance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends entranceUpdateArgs>(args: SelectSubset<T, entranceUpdateArgs<ExtArgs>>): Prisma__entranceClient<$Result.GetResult<Prisma.$entrancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Entrances.
     * @param {entranceDeleteManyArgs} args - Arguments to filter Entrances to delete.
     * @example
     * // Delete a few Entrances
     * const { count } = await prisma.entrance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends entranceDeleteManyArgs>(args?: SelectSubset<T, entranceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entrances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entranceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entrances
     * const entrance = await prisma.entrance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends entranceUpdateManyArgs>(args: SelectSubset<T, entranceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entrances and returns the data updated in the database.
     * @param {entranceUpdateManyAndReturnArgs} args - Arguments to update many Entrances.
     * @example
     * // Update many Entrances
     * const entrance = await prisma.entrance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Entrances and only return the `id`
     * const entranceWithIdOnly = await prisma.entrance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends entranceUpdateManyAndReturnArgs>(args: SelectSubset<T, entranceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entrancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Entrance.
     * @param {entranceUpsertArgs} args - Arguments to update or create a Entrance.
     * @example
     * // Update or create a Entrance
     * const entrance = await prisma.entrance.upsert({
     *   create: {
     *     // ... data to create a Entrance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entrance we want to update
     *   }
     * })
     */
    upsert<T extends entranceUpsertArgs>(args: SelectSubset<T, entranceUpsertArgs<ExtArgs>>): Prisma__entranceClient<$Result.GetResult<Prisma.$entrancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Entrances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entranceCountArgs} args - Arguments to filter Entrances to count.
     * @example
     * // Count the number of Entrances
     * const count = await prisma.entrance.count({
     *   where: {
     *     // ... the filter for the Entrances we want to count
     *   }
     * })
    **/
    count<T extends entranceCountArgs>(
      args?: Subset<T, entranceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntranceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entrance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntranceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntranceAggregateArgs>(args: Subset<T, EntranceAggregateArgs>): Prisma.PrismaPromise<GetEntranceAggregateType<T>>

    /**
     * Group by Entrance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entranceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends entranceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: entranceGroupByArgs['orderBy'] }
        : { orderBy?: entranceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, entranceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntranceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the entrance model
   */
  readonly fields: entranceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for entrance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__entranceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the entrance model
   */
  interface entranceFieldRefs {
    readonly id: FieldRef<"entrance", 'String'>
    readonly type: FieldRef<"entrance", 'String'>
    readonly useragent: FieldRef<"entrance", 'String'>
    readonly ipaddress: FieldRef<"entrance", 'String'>
    readonly userid: FieldRef<"entrance", 'String'>
    readonly createdat: FieldRef<"entrance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * entrance findUnique
   */
  export type entranceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entrance
     */
    select?: entranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entrance
     */
    omit?: entranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entranceInclude<ExtArgs> | null
    /**
     * Filter, which entrance to fetch.
     */
    where: entranceWhereUniqueInput
  }

  /**
   * entrance findUniqueOrThrow
   */
  export type entranceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entrance
     */
    select?: entranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entrance
     */
    omit?: entranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entranceInclude<ExtArgs> | null
    /**
     * Filter, which entrance to fetch.
     */
    where: entranceWhereUniqueInput
  }

  /**
   * entrance findFirst
   */
  export type entranceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entrance
     */
    select?: entranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entrance
     */
    omit?: entranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entranceInclude<ExtArgs> | null
    /**
     * Filter, which entrance to fetch.
     */
    where?: entranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entrances to fetch.
     */
    orderBy?: entranceOrderByWithRelationInput | entranceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for entrances.
     */
    cursor?: entranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entrances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entrances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of entrances.
     */
    distinct?: EntranceScalarFieldEnum | EntranceScalarFieldEnum[]
  }

  /**
   * entrance findFirstOrThrow
   */
  export type entranceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entrance
     */
    select?: entranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entrance
     */
    omit?: entranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entranceInclude<ExtArgs> | null
    /**
     * Filter, which entrance to fetch.
     */
    where?: entranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entrances to fetch.
     */
    orderBy?: entranceOrderByWithRelationInput | entranceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for entrances.
     */
    cursor?: entranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entrances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entrances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of entrances.
     */
    distinct?: EntranceScalarFieldEnum | EntranceScalarFieldEnum[]
  }

  /**
   * entrance findMany
   */
  export type entranceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entrance
     */
    select?: entranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entrance
     */
    omit?: entranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entranceInclude<ExtArgs> | null
    /**
     * Filter, which entrances to fetch.
     */
    where?: entranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entrances to fetch.
     */
    orderBy?: entranceOrderByWithRelationInput | entranceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing entrances.
     */
    cursor?: entranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entrances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entrances.
     */
    skip?: number
    distinct?: EntranceScalarFieldEnum | EntranceScalarFieldEnum[]
  }

  /**
   * entrance create
   */
  export type entranceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entrance
     */
    select?: entranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entrance
     */
    omit?: entranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entranceInclude<ExtArgs> | null
    /**
     * The data needed to create a entrance.
     */
    data: XOR<entranceCreateInput, entranceUncheckedCreateInput>
  }

  /**
   * entrance createMany
   */
  export type entranceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many entrances.
     */
    data: entranceCreateManyInput | entranceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * entrance createManyAndReturn
   */
  export type entranceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entrance
     */
    select?: entranceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the entrance
     */
    omit?: entranceOmit<ExtArgs> | null
    /**
     * The data used to create many entrances.
     */
    data: entranceCreateManyInput | entranceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entranceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * entrance update
   */
  export type entranceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entrance
     */
    select?: entranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entrance
     */
    omit?: entranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entranceInclude<ExtArgs> | null
    /**
     * The data needed to update a entrance.
     */
    data: XOR<entranceUpdateInput, entranceUncheckedUpdateInput>
    /**
     * Choose, which entrance to update.
     */
    where: entranceWhereUniqueInput
  }

  /**
   * entrance updateMany
   */
  export type entranceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update entrances.
     */
    data: XOR<entranceUpdateManyMutationInput, entranceUncheckedUpdateManyInput>
    /**
     * Filter which entrances to update
     */
    where?: entranceWhereInput
    /**
     * Limit how many entrances to update.
     */
    limit?: number
  }

  /**
   * entrance updateManyAndReturn
   */
  export type entranceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entrance
     */
    select?: entranceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the entrance
     */
    omit?: entranceOmit<ExtArgs> | null
    /**
     * The data used to update entrances.
     */
    data: XOR<entranceUpdateManyMutationInput, entranceUncheckedUpdateManyInput>
    /**
     * Filter which entrances to update
     */
    where?: entranceWhereInput
    /**
     * Limit how many entrances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entranceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * entrance upsert
   */
  export type entranceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entrance
     */
    select?: entranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entrance
     */
    omit?: entranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entranceInclude<ExtArgs> | null
    /**
     * The filter to search for the entrance to update in case it exists.
     */
    where: entranceWhereUniqueInput
    /**
     * In case the entrance found by the `where` argument doesn't exist, create a new entrance with this data.
     */
    create: XOR<entranceCreateInput, entranceUncheckedCreateInput>
    /**
     * In case the entrance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<entranceUpdateInput, entranceUncheckedUpdateInput>
  }

  /**
   * entrance delete
   */
  export type entranceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entrance
     */
    select?: entranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entrance
     */
    omit?: entranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entranceInclude<ExtArgs> | null
    /**
     * Filter which entrance to delete.
     */
    where: entranceWhereUniqueInput
  }

  /**
   * entrance deleteMany
   */
  export type entranceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which entrances to delete
     */
    where?: entranceWhereInput
    /**
     * Limit how many entrances to delete.
     */
    limit?: number
  }

  /**
   * entrance without action
   */
  export type entranceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entrance
     */
    select?: entranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entrance
     */
    omit?: entranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entranceInclude<ExtArgs> | null
  }


  /**
   * Model userpermission
   */

  export type AggregateUserpermission = {
    _count: UserpermissionCountAggregateOutputType | null
    _min: UserpermissionMinAggregateOutputType | null
    _max: UserpermissionMaxAggregateOutputType | null
  }

  export type UserpermissionMinAggregateOutputType = {
    id: string | null
    userid: string | null
    permissionid: string | null
    createdby: string | null
    createdat: Date | null
    updatedby: string | null
    updatedat: Date | null
  }

  export type UserpermissionMaxAggregateOutputType = {
    id: string | null
    userid: string | null
    permissionid: string | null
    createdby: string | null
    createdat: Date | null
    updatedby: string | null
    updatedat: Date | null
  }

  export type UserpermissionCountAggregateOutputType = {
    id: number
    userid: number
    permissionid: number
    createdby: number
    createdat: number
    updatedby: number
    updatedat: number
    _all: number
  }


  export type UserpermissionMinAggregateInputType = {
    id?: true
    userid?: true
    permissionid?: true
    createdby?: true
    createdat?: true
    updatedby?: true
    updatedat?: true
  }

  export type UserpermissionMaxAggregateInputType = {
    id?: true
    userid?: true
    permissionid?: true
    createdby?: true
    createdat?: true
    updatedby?: true
    updatedat?: true
  }

  export type UserpermissionCountAggregateInputType = {
    id?: true
    userid?: true
    permissionid?: true
    createdby?: true
    createdat?: true
    updatedby?: true
    updatedat?: true
    _all?: true
  }

  export type UserpermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userpermission to aggregate.
     */
    where?: userpermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userpermissions to fetch.
     */
    orderBy?: userpermissionOrderByWithRelationInput | userpermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userpermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userpermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userpermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userpermissions
    **/
    _count?: true | UserpermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserpermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserpermissionMaxAggregateInputType
  }

  export type GetUserpermissionAggregateType<T extends UserpermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserpermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserpermission[P]>
      : GetScalarType<T[P], AggregateUserpermission[P]>
  }




  export type userpermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userpermissionWhereInput
    orderBy?: userpermissionOrderByWithAggregationInput | userpermissionOrderByWithAggregationInput[]
    by: UserpermissionScalarFieldEnum[] | UserpermissionScalarFieldEnum
    having?: userpermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserpermissionCountAggregateInputType | true
    _min?: UserpermissionMinAggregateInputType
    _max?: UserpermissionMaxAggregateInputType
  }

  export type UserpermissionGroupByOutputType = {
    id: string
    userid: string
    permissionid: string
    createdby: string
    createdat: Date
    updatedby: string | null
    updatedat: Date | null
    _count: UserpermissionCountAggregateOutputType | null
    _min: UserpermissionMinAggregateOutputType | null
    _max: UserpermissionMaxAggregateOutputType | null
  }

  type GetUserpermissionGroupByPayload<T extends userpermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserpermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserpermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserpermissionGroupByOutputType[P]>
            : GetScalarType<T[P], UserpermissionGroupByOutputType[P]>
        }
      >
    >


  export type userpermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    permissionid?: boolean
    createdby?: boolean
    createdat?: boolean
    updatedby?: boolean
    updatedat?: boolean
    createduser?: boolean | userDefaultArgs<ExtArgs>
    permission?: boolean | permissionDefaultArgs<ExtArgs>
    updateduser?: boolean | userpermission$updateduserArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userpermission"]>

  export type userpermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    permissionid?: boolean
    createdby?: boolean
    createdat?: boolean
    updatedby?: boolean
    updatedat?: boolean
    createduser?: boolean | userDefaultArgs<ExtArgs>
    permission?: boolean | permissionDefaultArgs<ExtArgs>
    updateduser?: boolean | userpermission$updateduserArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userpermission"]>

  export type userpermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    permissionid?: boolean
    createdby?: boolean
    createdat?: boolean
    updatedby?: boolean
    updatedat?: boolean
    createduser?: boolean | userDefaultArgs<ExtArgs>
    permission?: boolean | permissionDefaultArgs<ExtArgs>
    updateduser?: boolean | userpermission$updateduserArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userpermission"]>

  export type userpermissionSelectScalar = {
    id?: boolean
    userid?: boolean
    permissionid?: boolean
    createdby?: boolean
    createdat?: boolean
    updatedby?: boolean
    updatedat?: boolean
  }

  export type userpermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userid" | "permissionid" | "createdby" | "createdat" | "updatedby" | "updatedat", ExtArgs["result"]["userpermission"]>
  export type userpermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createduser?: boolean | userDefaultArgs<ExtArgs>
    permission?: boolean | permissionDefaultArgs<ExtArgs>
    updateduser?: boolean | userpermission$updateduserArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type userpermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createduser?: boolean | userDefaultArgs<ExtArgs>
    permission?: boolean | permissionDefaultArgs<ExtArgs>
    updateduser?: boolean | userpermission$updateduserArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type userpermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createduser?: boolean | userDefaultArgs<ExtArgs>
    permission?: boolean | permissionDefaultArgs<ExtArgs>
    updateduser?: boolean | userpermission$updateduserArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $userpermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userpermission"
    objects: {
      createduser: Prisma.$userPayload<ExtArgs>
      permission: Prisma.$permissionPayload<ExtArgs>
      updateduser: Prisma.$userPayload<ExtArgs> | null
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userid: string
      permissionid: string
      createdby: string
      createdat: Date
      updatedby: string | null
      updatedat: Date | null
    }, ExtArgs["result"]["userpermission"]>
    composites: {}
  }

  type userpermissionGetPayload<S extends boolean | null | undefined | userpermissionDefaultArgs> = $Result.GetResult<Prisma.$userpermissionPayload, S>

  type userpermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userpermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserpermissionCountAggregateInputType | true
    }

  export interface userpermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userpermission'], meta: { name: 'userpermission' } }
    /**
     * Find zero or one Userpermission that matches the filter.
     * @param {userpermissionFindUniqueArgs} args - Arguments to find a Userpermission
     * @example
     * // Get one Userpermission
     * const userpermission = await prisma.userpermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userpermissionFindUniqueArgs>(args: SelectSubset<T, userpermissionFindUniqueArgs<ExtArgs>>): Prisma__userpermissionClient<$Result.GetResult<Prisma.$userpermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Userpermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userpermissionFindUniqueOrThrowArgs} args - Arguments to find a Userpermission
     * @example
     * // Get one Userpermission
     * const userpermission = await prisma.userpermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userpermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, userpermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userpermissionClient<$Result.GetResult<Prisma.$userpermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userpermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userpermissionFindFirstArgs} args - Arguments to find a Userpermission
     * @example
     * // Get one Userpermission
     * const userpermission = await prisma.userpermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userpermissionFindFirstArgs>(args?: SelectSubset<T, userpermissionFindFirstArgs<ExtArgs>>): Prisma__userpermissionClient<$Result.GetResult<Prisma.$userpermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userpermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userpermissionFindFirstOrThrowArgs} args - Arguments to find a Userpermission
     * @example
     * // Get one Userpermission
     * const userpermission = await prisma.userpermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userpermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, userpermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__userpermissionClient<$Result.GetResult<Prisma.$userpermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Userpermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userpermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Userpermissions
     * const userpermissions = await prisma.userpermission.findMany()
     * 
     * // Get first 10 Userpermissions
     * const userpermissions = await prisma.userpermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userpermissionWithIdOnly = await prisma.userpermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userpermissionFindManyArgs>(args?: SelectSubset<T, userpermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userpermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Userpermission.
     * @param {userpermissionCreateArgs} args - Arguments to create a Userpermission.
     * @example
     * // Create one Userpermission
     * const Userpermission = await prisma.userpermission.create({
     *   data: {
     *     // ... data to create a Userpermission
     *   }
     * })
     * 
     */
    create<T extends userpermissionCreateArgs>(args: SelectSubset<T, userpermissionCreateArgs<ExtArgs>>): Prisma__userpermissionClient<$Result.GetResult<Prisma.$userpermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Userpermissions.
     * @param {userpermissionCreateManyArgs} args - Arguments to create many Userpermissions.
     * @example
     * // Create many Userpermissions
     * const userpermission = await prisma.userpermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userpermissionCreateManyArgs>(args?: SelectSubset<T, userpermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Userpermissions and returns the data saved in the database.
     * @param {userpermissionCreateManyAndReturnArgs} args - Arguments to create many Userpermissions.
     * @example
     * // Create many Userpermissions
     * const userpermission = await prisma.userpermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Userpermissions and only return the `id`
     * const userpermissionWithIdOnly = await prisma.userpermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userpermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, userpermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userpermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Userpermission.
     * @param {userpermissionDeleteArgs} args - Arguments to delete one Userpermission.
     * @example
     * // Delete one Userpermission
     * const Userpermission = await prisma.userpermission.delete({
     *   where: {
     *     // ... filter to delete one Userpermission
     *   }
     * })
     * 
     */
    delete<T extends userpermissionDeleteArgs>(args: SelectSubset<T, userpermissionDeleteArgs<ExtArgs>>): Prisma__userpermissionClient<$Result.GetResult<Prisma.$userpermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Userpermission.
     * @param {userpermissionUpdateArgs} args - Arguments to update one Userpermission.
     * @example
     * // Update one Userpermission
     * const userpermission = await prisma.userpermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userpermissionUpdateArgs>(args: SelectSubset<T, userpermissionUpdateArgs<ExtArgs>>): Prisma__userpermissionClient<$Result.GetResult<Prisma.$userpermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Userpermissions.
     * @param {userpermissionDeleteManyArgs} args - Arguments to filter Userpermissions to delete.
     * @example
     * // Delete a few Userpermissions
     * const { count } = await prisma.userpermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userpermissionDeleteManyArgs>(args?: SelectSubset<T, userpermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userpermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userpermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Userpermissions
     * const userpermission = await prisma.userpermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userpermissionUpdateManyArgs>(args: SelectSubset<T, userpermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userpermissions and returns the data updated in the database.
     * @param {userpermissionUpdateManyAndReturnArgs} args - Arguments to update many Userpermissions.
     * @example
     * // Update many Userpermissions
     * const userpermission = await prisma.userpermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Userpermissions and only return the `id`
     * const userpermissionWithIdOnly = await prisma.userpermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userpermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, userpermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userpermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Userpermission.
     * @param {userpermissionUpsertArgs} args - Arguments to update or create a Userpermission.
     * @example
     * // Update or create a Userpermission
     * const userpermission = await prisma.userpermission.upsert({
     *   create: {
     *     // ... data to create a Userpermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Userpermission we want to update
     *   }
     * })
     */
    upsert<T extends userpermissionUpsertArgs>(args: SelectSubset<T, userpermissionUpsertArgs<ExtArgs>>): Prisma__userpermissionClient<$Result.GetResult<Prisma.$userpermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Userpermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userpermissionCountArgs} args - Arguments to filter Userpermissions to count.
     * @example
     * // Count the number of Userpermissions
     * const count = await prisma.userpermission.count({
     *   where: {
     *     // ... the filter for the Userpermissions we want to count
     *   }
     * })
    **/
    count<T extends userpermissionCountArgs>(
      args?: Subset<T, userpermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserpermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Userpermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserpermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserpermissionAggregateArgs>(args: Subset<T, UserpermissionAggregateArgs>): Prisma.PrismaPromise<GetUserpermissionAggregateType<T>>

    /**
     * Group by Userpermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userpermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userpermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userpermissionGroupByArgs['orderBy'] }
        : { orderBy?: userpermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userpermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserpermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userpermission model
   */
  readonly fields: userpermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userpermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userpermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createduser<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    permission<T extends permissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, permissionDefaultArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updateduser<T extends userpermission$updateduserArgs<ExtArgs> = {}>(args?: Subset<T, userpermission$updateduserArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userpermission model
   */
  interface userpermissionFieldRefs {
    readonly id: FieldRef<"userpermission", 'String'>
    readonly userid: FieldRef<"userpermission", 'String'>
    readonly permissionid: FieldRef<"userpermission", 'String'>
    readonly createdby: FieldRef<"userpermission", 'String'>
    readonly createdat: FieldRef<"userpermission", 'DateTime'>
    readonly updatedby: FieldRef<"userpermission", 'String'>
    readonly updatedat: FieldRef<"userpermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * userpermission findUnique
   */
  export type userpermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userpermission
     */
    select?: userpermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userpermission
     */
    omit?: userpermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userpermissionInclude<ExtArgs> | null
    /**
     * Filter, which userpermission to fetch.
     */
    where: userpermissionWhereUniqueInput
  }

  /**
   * userpermission findUniqueOrThrow
   */
  export type userpermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userpermission
     */
    select?: userpermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userpermission
     */
    omit?: userpermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userpermissionInclude<ExtArgs> | null
    /**
     * Filter, which userpermission to fetch.
     */
    where: userpermissionWhereUniqueInput
  }

  /**
   * userpermission findFirst
   */
  export type userpermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userpermission
     */
    select?: userpermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userpermission
     */
    omit?: userpermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userpermissionInclude<ExtArgs> | null
    /**
     * Filter, which userpermission to fetch.
     */
    where?: userpermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userpermissions to fetch.
     */
    orderBy?: userpermissionOrderByWithRelationInput | userpermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userpermissions.
     */
    cursor?: userpermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userpermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userpermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userpermissions.
     */
    distinct?: UserpermissionScalarFieldEnum | UserpermissionScalarFieldEnum[]
  }

  /**
   * userpermission findFirstOrThrow
   */
  export type userpermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userpermission
     */
    select?: userpermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userpermission
     */
    omit?: userpermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userpermissionInclude<ExtArgs> | null
    /**
     * Filter, which userpermission to fetch.
     */
    where?: userpermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userpermissions to fetch.
     */
    orderBy?: userpermissionOrderByWithRelationInput | userpermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userpermissions.
     */
    cursor?: userpermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userpermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userpermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userpermissions.
     */
    distinct?: UserpermissionScalarFieldEnum | UserpermissionScalarFieldEnum[]
  }

  /**
   * userpermission findMany
   */
  export type userpermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userpermission
     */
    select?: userpermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userpermission
     */
    omit?: userpermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userpermissionInclude<ExtArgs> | null
    /**
     * Filter, which userpermissions to fetch.
     */
    where?: userpermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userpermissions to fetch.
     */
    orderBy?: userpermissionOrderByWithRelationInput | userpermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userpermissions.
     */
    cursor?: userpermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userpermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userpermissions.
     */
    skip?: number
    distinct?: UserpermissionScalarFieldEnum | UserpermissionScalarFieldEnum[]
  }

  /**
   * userpermission create
   */
  export type userpermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userpermission
     */
    select?: userpermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userpermission
     */
    omit?: userpermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userpermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a userpermission.
     */
    data: XOR<userpermissionCreateInput, userpermissionUncheckedCreateInput>
  }

  /**
   * userpermission createMany
   */
  export type userpermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userpermissions.
     */
    data: userpermissionCreateManyInput | userpermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * userpermission createManyAndReturn
   */
  export type userpermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userpermission
     */
    select?: userpermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userpermission
     */
    omit?: userpermissionOmit<ExtArgs> | null
    /**
     * The data used to create many userpermissions.
     */
    data: userpermissionCreateManyInput | userpermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userpermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * userpermission update
   */
  export type userpermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userpermission
     */
    select?: userpermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userpermission
     */
    omit?: userpermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userpermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a userpermission.
     */
    data: XOR<userpermissionUpdateInput, userpermissionUncheckedUpdateInput>
    /**
     * Choose, which userpermission to update.
     */
    where: userpermissionWhereUniqueInput
  }

  /**
   * userpermission updateMany
   */
  export type userpermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userpermissions.
     */
    data: XOR<userpermissionUpdateManyMutationInput, userpermissionUncheckedUpdateManyInput>
    /**
     * Filter which userpermissions to update
     */
    where?: userpermissionWhereInput
    /**
     * Limit how many userpermissions to update.
     */
    limit?: number
  }

  /**
   * userpermission updateManyAndReturn
   */
  export type userpermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userpermission
     */
    select?: userpermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userpermission
     */
    omit?: userpermissionOmit<ExtArgs> | null
    /**
     * The data used to update userpermissions.
     */
    data: XOR<userpermissionUpdateManyMutationInput, userpermissionUncheckedUpdateManyInput>
    /**
     * Filter which userpermissions to update
     */
    where?: userpermissionWhereInput
    /**
     * Limit how many userpermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userpermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * userpermission upsert
   */
  export type userpermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userpermission
     */
    select?: userpermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userpermission
     */
    omit?: userpermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userpermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the userpermission to update in case it exists.
     */
    where: userpermissionWhereUniqueInput
    /**
     * In case the userpermission found by the `where` argument doesn't exist, create a new userpermission with this data.
     */
    create: XOR<userpermissionCreateInput, userpermissionUncheckedCreateInput>
    /**
     * In case the userpermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userpermissionUpdateInput, userpermissionUncheckedUpdateInput>
  }

  /**
   * userpermission delete
   */
  export type userpermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userpermission
     */
    select?: userpermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userpermission
     */
    omit?: userpermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userpermissionInclude<ExtArgs> | null
    /**
     * Filter which userpermission to delete.
     */
    where: userpermissionWhereUniqueInput
  }

  /**
   * userpermission deleteMany
   */
  export type userpermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userpermissions to delete
     */
    where?: userpermissionWhereInput
    /**
     * Limit how many userpermissions to delete.
     */
    limit?: number
  }

  /**
   * userpermission.updateduser
   */
  export type userpermission$updateduserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * userpermission without action
   */
  export type userpermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userpermission
     */
    select?: userpermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userpermission
     */
    omit?: userpermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userpermissionInclude<ExtArgs> | null
  }


  /**
   * Model userrole
   */

  export type AggregateUserrole = {
    _count: UserroleCountAggregateOutputType | null
    _min: UserroleMinAggregateOutputType | null
    _max: UserroleMaxAggregateOutputType | null
  }

  export type UserroleMinAggregateOutputType = {
    id: string | null
    userid: string | null
    roleid: string | null
    createdby: string | null
    createdat: Date | null
    updatedby: string | null
    updatedat: Date | null
  }

  export type UserroleMaxAggregateOutputType = {
    id: string | null
    userid: string | null
    roleid: string | null
    createdby: string | null
    createdat: Date | null
    updatedby: string | null
    updatedat: Date | null
  }

  export type UserroleCountAggregateOutputType = {
    id: number
    userid: number
    roleid: number
    createdby: number
    createdat: number
    updatedby: number
    updatedat: number
    _all: number
  }


  export type UserroleMinAggregateInputType = {
    id?: true
    userid?: true
    roleid?: true
    createdby?: true
    createdat?: true
    updatedby?: true
    updatedat?: true
  }

  export type UserroleMaxAggregateInputType = {
    id?: true
    userid?: true
    roleid?: true
    createdby?: true
    createdat?: true
    updatedby?: true
    updatedat?: true
  }

  export type UserroleCountAggregateInputType = {
    id?: true
    userid?: true
    roleid?: true
    createdby?: true
    createdat?: true
    updatedby?: true
    updatedat?: true
    _all?: true
  }

  export type UserroleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userrole to aggregate.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userroles
    **/
    _count?: true | UserroleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserroleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserroleMaxAggregateInputType
  }

  export type GetUserroleAggregateType<T extends UserroleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserrole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserrole[P]>
      : GetScalarType<T[P], AggregateUserrole[P]>
  }




  export type userroleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userroleWhereInput
    orderBy?: userroleOrderByWithAggregationInput | userroleOrderByWithAggregationInput[]
    by: UserroleScalarFieldEnum[] | UserroleScalarFieldEnum
    having?: userroleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserroleCountAggregateInputType | true
    _min?: UserroleMinAggregateInputType
    _max?: UserroleMaxAggregateInputType
  }

  export type UserroleGroupByOutputType = {
    id: string
    userid: string
    roleid: string
    createdby: string
    createdat: Date
    updatedby: string | null
    updatedat: Date | null
    _count: UserroleCountAggregateOutputType | null
    _min: UserroleMinAggregateOutputType | null
    _max: UserroleMaxAggregateOutputType | null
  }

  type GetUserroleGroupByPayload<T extends userroleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserroleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserroleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserroleGroupByOutputType[P]>
            : GetScalarType<T[P], UserroleGroupByOutputType[P]>
        }
      >
    >


  export type userroleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    roleid?: boolean
    createdby?: boolean
    createdat?: boolean
    updatedby?: boolean
    updatedat?: boolean
    createduser?: boolean | userDefaultArgs<ExtArgs>
    role?: boolean | roleDefaultArgs<ExtArgs>
    updateduser?: boolean | userrole$updateduserArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userrole"]>

  export type userroleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    roleid?: boolean
    createdby?: boolean
    createdat?: boolean
    updatedby?: boolean
    updatedat?: boolean
    createduser?: boolean | userDefaultArgs<ExtArgs>
    role?: boolean | roleDefaultArgs<ExtArgs>
    updateduser?: boolean | userrole$updateduserArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userrole"]>

  export type userroleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    roleid?: boolean
    createdby?: boolean
    createdat?: boolean
    updatedby?: boolean
    updatedat?: boolean
    createduser?: boolean | userDefaultArgs<ExtArgs>
    role?: boolean | roleDefaultArgs<ExtArgs>
    updateduser?: boolean | userrole$updateduserArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userrole"]>

  export type userroleSelectScalar = {
    id?: boolean
    userid?: boolean
    roleid?: boolean
    createdby?: boolean
    createdat?: boolean
    updatedby?: boolean
    updatedat?: boolean
  }

  export type userroleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userid" | "roleid" | "createdby" | "createdat" | "updatedby" | "updatedat", ExtArgs["result"]["userrole"]>
  export type userroleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createduser?: boolean | userDefaultArgs<ExtArgs>
    role?: boolean | roleDefaultArgs<ExtArgs>
    updateduser?: boolean | userrole$updateduserArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type userroleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createduser?: boolean | userDefaultArgs<ExtArgs>
    role?: boolean | roleDefaultArgs<ExtArgs>
    updateduser?: boolean | userrole$updateduserArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type userroleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createduser?: boolean | userDefaultArgs<ExtArgs>
    role?: boolean | roleDefaultArgs<ExtArgs>
    updateduser?: boolean | userrole$updateduserArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $userrolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userrole"
    objects: {
      createduser: Prisma.$userPayload<ExtArgs>
      role: Prisma.$rolePayload<ExtArgs>
      updateduser: Prisma.$userPayload<ExtArgs> | null
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userid: string
      roleid: string
      createdby: string
      createdat: Date
      updatedby: string | null
      updatedat: Date | null
    }, ExtArgs["result"]["userrole"]>
    composites: {}
  }

  type userroleGetPayload<S extends boolean | null | undefined | userroleDefaultArgs> = $Result.GetResult<Prisma.$userrolePayload, S>

  type userroleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userroleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserroleCountAggregateInputType | true
    }

  export interface userroleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userrole'], meta: { name: 'userrole' } }
    /**
     * Find zero or one Userrole that matches the filter.
     * @param {userroleFindUniqueArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userroleFindUniqueArgs>(args: SelectSubset<T, userroleFindUniqueArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Userrole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userroleFindUniqueOrThrowArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userroleFindUniqueOrThrowArgs>(args: SelectSubset<T, userroleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userrole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleFindFirstArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userroleFindFirstArgs>(args?: SelectSubset<T, userroleFindFirstArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userrole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleFindFirstOrThrowArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userroleFindFirstOrThrowArgs>(args?: SelectSubset<T, userroleFindFirstOrThrowArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Userroles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Userroles
     * const userroles = await prisma.userrole.findMany()
     * 
     * // Get first 10 Userroles
     * const userroles = await prisma.userrole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userroleWithIdOnly = await prisma.userrole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userroleFindManyArgs>(args?: SelectSubset<T, userroleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Userrole.
     * @param {userroleCreateArgs} args - Arguments to create a Userrole.
     * @example
     * // Create one Userrole
     * const Userrole = await prisma.userrole.create({
     *   data: {
     *     // ... data to create a Userrole
     *   }
     * })
     * 
     */
    create<T extends userroleCreateArgs>(args: SelectSubset<T, userroleCreateArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Userroles.
     * @param {userroleCreateManyArgs} args - Arguments to create many Userroles.
     * @example
     * // Create many Userroles
     * const userrole = await prisma.userrole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userroleCreateManyArgs>(args?: SelectSubset<T, userroleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Userroles and returns the data saved in the database.
     * @param {userroleCreateManyAndReturnArgs} args - Arguments to create many Userroles.
     * @example
     * // Create many Userroles
     * const userrole = await prisma.userrole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Userroles and only return the `id`
     * const userroleWithIdOnly = await prisma.userrole.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userroleCreateManyAndReturnArgs>(args?: SelectSubset<T, userroleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Userrole.
     * @param {userroleDeleteArgs} args - Arguments to delete one Userrole.
     * @example
     * // Delete one Userrole
     * const Userrole = await prisma.userrole.delete({
     *   where: {
     *     // ... filter to delete one Userrole
     *   }
     * })
     * 
     */
    delete<T extends userroleDeleteArgs>(args: SelectSubset<T, userroleDeleteArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Userrole.
     * @param {userroleUpdateArgs} args - Arguments to update one Userrole.
     * @example
     * // Update one Userrole
     * const userrole = await prisma.userrole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userroleUpdateArgs>(args: SelectSubset<T, userroleUpdateArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Userroles.
     * @param {userroleDeleteManyArgs} args - Arguments to filter Userroles to delete.
     * @example
     * // Delete a few Userroles
     * const { count } = await prisma.userrole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userroleDeleteManyArgs>(args?: SelectSubset<T, userroleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userroles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Userroles
     * const userrole = await prisma.userrole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userroleUpdateManyArgs>(args: SelectSubset<T, userroleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userroles and returns the data updated in the database.
     * @param {userroleUpdateManyAndReturnArgs} args - Arguments to update many Userroles.
     * @example
     * // Update many Userroles
     * const userrole = await prisma.userrole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Userroles and only return the `id`
     * const userroleWithIdOnly = await prisma.userrole.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userroleUpdateManyAndReturnArgs>(args: SelectSubset<T, userroleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Userrole.
     * @param {userroleUpsertArgs} args - Arguments to update or create a Userrole.
     * @example
     * // Update or create a Userrole
     * const userrole = await prisma.userrole.upsert({
     *   create: {
     *     // ... data to create a Userrole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Userrole we want to update
     *   }
     * })
     */
    upsert<T extends userroleUpsertArgs>(args: SelectSubset<T, userroleUpsertArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Userroles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleCountArgs} args - Arguments to filter Userroles to count.
     * @example
     * // Count the number of Userroles
     * const count = await prisma.userrole.count({
     *   where: {
     *     // ... the filter for the Userroles we want to count
     *   }
     * })
    **/
    count<T extends userroleCountArgs>(
      args?: Subset<T, userroleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserroleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Userrole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserroleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserroleAggregateArgs>(args: Subset<T, UserroleAggregateArgs>): Prisma.PrismaPromise<GetUserroleAggregateType<T>>

    /**
     * Group by Userrole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userroleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userroleGroupByArgs['orderBy'] }
        : { orderBy?: userroleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userroleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserroleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userrole model
   */
  readonly fields: userroleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userrole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userroleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createduser<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends roleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, roleDefaultArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updateduser<T extends userrole$updateduserArgs<ExtArgs> = {}>(args?: Subset<T, userrole$updateduserArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userrole model
   */
  interface userroleFieldRefs {
    readonly id: FieldRef<"userrole", 'String'>
    readonly userid: FieldRef<"userrole", 'String'>
    readonly roleid: FieldRef<"userrole", 'String'>
    readonly createdby: FieldRef<"userrole", 'String'>
    readonly createdat: FieldRef<"userrole", 'DateTime'>
    readonly updatedby: FieldRef<"userrole", 'String'>
    readonly updatedat: FieldRef<"userrole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * userrole findUnique
   */
  export type userroleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole findUniqueOrThrow
   */
  export type userroleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole findFirst
   */
  export type userroleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userroles.
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userroles.
     */
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * userrole findFirstOrThrow
   */
  export type userroleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userroles.
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userroles.
     */
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * userrole findMany
   */
  export type userroleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userroles to fetch.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userroles.
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * userrole create
   */
  export type userroleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * The data needed to create a userrole.
     */
    data: XOR<userroleCreateInput, userroleUncheckedCreateInput>
  }

  /**
   * userrole createMany
   */
  export type userroleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userroles.
     */
    data: userroleCreateManyInput | userroleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * userrole createManyAndReturn
   */
  export type userroleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * The data used to create many userroles.
     */
    data: userroleCreateManyInput | userroleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * userrole update
   */
  export type userroleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * The data needed to update a userrole.
     */
    data: XOR<userroleUpdateInput, userroleUncheckedUpdateInput>
    /**
     * Choose, which userrole to update.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole updateMany
   */
  export type userroleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userroles.
     */
    data: XOR<userroleUpdateManyMutationInput, userroleUncheckedUpdateManyInput>
    /**
     * Filter which userroles to update
     */
    where?: userroleWhereInput
    /**
     * Limit how many userroles to update.
     */
    limit?: number
  }

  /**
   * userrole updateManyAndReturn
   */
  export type userroleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * The data used to update userroles.
     */
    data: XOR<userroleUpdateManyMutationInput, userroleUncheckedUpdateManyInput>
    /**
     * Filter which userroles to update
     */
    where?: userroleWhereInput
    /**
     * Limit how many userroles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * userrole upsert
   */
  export type userroleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * The filter to search for the userrole to update in case it exists.
     */
    where: userroleWhereUniqueInput
    /**
     * In case the userrole found by the `where` argument doesn't exist, create a new userrole with this data.
     */
    create: XOR<userroleCreateInput, userroleUncheckedCreateInput>
    /**
     * In case the userrole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userroleUpdateInput, userroleUncheckedUpdateInput>
  }

  /**
   * userrole delete
   */
  export type userroleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter which userrole to delete.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole deleteMany
   */
  export type userroleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userroles to delete
     */
    where?: userroleWhereInput
    /**
     * Limit how many userroles to delete.
     */
    limit?: number
  }

  /**
   * userrole.updateduser
   */
  export type userrole$updateduserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * userrole without action
   */
  export type userroleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
  }


  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    firstname: string | null
    lastname: string | null
    email: string | null
    planId: string | null
    password: string | null
    companyName: string | null
    companyLogoUrl: string | null
    taxId: string | null
    address: string | null
    phone: string | null
    createdat: Date | null
    createdby: string | null
    updatedat: Date | null
    updatedby: string | null
    status: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    firstname: string | null
    lastname: string | null
    email: string | null
    planId: string | null
    password: string | null
    companyName: string | null
    companyLogoUrl: string | null
    taxId: string | null
    address: string | null
    phone: string | null
    createdat: Date | null
    createdby: string | null
    updatedat: Date | null
    updatedby: string | null
    status: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstname: number
    lastname: number
    email: number
    planId: number
    password: number
    companyName: number
    companyLogoUrl: number
    taxId: number
    address: number
    phone: number
    createdat: number
    createdby: number
    updatedat: number
    updatedby: number
    status: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    planId?: true
    password?: true
    companyName?: true
    companyLogoUrl?: true
    taxId?: true
    address?: true
    phone?: true
    createdat?: true
    createdby?: true
    updatedat?: true
    updatedby?: true
    status?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    planId?: true
    password?: true
    companyName?: true
    companyLogoUrl?: true
    taxId?: true
    address?: true
    phone?: true
    createdat?: true
    createdby?: true
    updatedat?: true
    updatedby?: true
    status?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    planId?: true
    password?: true
    companyName?: true
    companyLogoUrl?: true
    taxId?: true
    address?: true
    phone?: true
    createdat?: true
    createdby?: true
    updatedat?: true
    updatedby?: true
    status?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    firstname: string
    lastname: string
    email: string
    planId: string | null
    password: string
    companyName: string | null
    companyLogoUrl: string | null
    taxId: string | null
    address: string | null
    phone: string | null
    createdat: Date
    createdby: string
    updatedat: Date | null
    updatedby: string | null
    status: boolean
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    planId?: boolean
    password?: boolean
    companyName?: boolean
    companyLogoUrl?: boolean
    taxId?: boolean
    address?: boolean
    phone?: boolean
    createdat?: boolean
    createdby?: boolean
    updatedat?: boolean
    updatedby?: boolean
    status?: boolean
    invoices?: boolean | user$invoicesArgs<ExtArgs>
    subscriptions?: boolean | user$subscriptionsArgs<ExtArgs>
    customers?: boolean | user$customersArgs<ExtArgs>
    parameters?: boolean | user$parametersArgs<ExtArgs>
    entrances?: boolean | user$entrancesArgs<ExtArgs>
    payments?: boolean | user$paymentsArgs<ExtArgs>
    plan?: boolean | user$planArgs<ExtArgs>
    transactions?: boolean | user$transactionsArgs<ExtArgs>
    notificationuser?: boolean | user$notificationuserArgs<ExtArgs>
    createdapiclients?: boolean | user$createdapiclientsArgs<ExtArgs>
    updatedapiclients?: boolean | user$updatedapiclientsArgs<ExtArgs>
    createdpermissions?: boolean | user$createdpermissionsArgs<ExtArgs>
    updatedpermissions?: boolean | user$updatedpermissionsArgs<ExtArgs>
    refreshtokens?: boolean | user$refreshtokensArgs<ExtArgs>
    createdroles?: boolean | user$createdrolesArgs<ExtArgs>
    updatedroles?: boolean | user$updatedrolesArgs<ExtArgs>
    createdrolepermissions?: boolean | user$createdrolepermissionsArgs<ExtArgs>
    updatedrolepermissions?: boolean | user$updatedrolepermissionsArgs<ExtArgs>
    createduser?: boolean | userDefaultArgs<ExtArgs>
    createdusers?: boolean | user$createdusersArgs<ExtArgs>
    updateduser?: boolean | user$updateduserArgs<ExtArgs>
    updatedusers?: boolean | user$updatedusersArgs<ExtArgs>
    createduserpermissions?: boolean | user$createduserpermissionsArgs<ExtArgs>
    updateduserpermissions?: boolean | user$updateduserpermissionsArgs<ExtArgs>
    userpermissions?: boolean | user$userpermissionsArgs<ExtArgs>
    createduserroles?: boolean | user$createduserrolesArgs<ExtArgs>
    updateduserroles?: boolean | user$updateduserrolesArgs<ExtArgs>
    userroles?: boolean | user$userrolesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    planId?: boolean
    password?: boolean
    companyName?: boolean
    companyLogoUrl?: boolean
    taxId?: boolean
    address?: boolean
    phone?: boolean
    createdat?: boolean
    createdby?: boolean
    updatedat?: boolean
    updatedby?: boolean
    status?: boolean
    plan?: boolean | user$planArgs<ExtArgs>
    createduser?: boolean | userDefaultArgs<ExtArgs>
    updateduser?: boolean | user$updateduserArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    planId?: boolean
    password?: boolean
    companyName?: boolean
    companyLogoUrl?: boolean
    taxId?: boolean
    address?: boolean
    phone?: boolean
    createdat?: boolean
    createdby?: boolean
    updatedat?: boolean
    updatedby?: boolean
    status?: boolean
    plan?: boolean | user$planArgs<ExtArgs>
    createduser?: boolean | userDefaultArgs<ExtArgs>
    updateduser?: boolean | user$updateduserArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectScalar = {
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    planId?: boolean
    password?: boolean
    companyName?: boolean
    companyLogoUrl?: boolean
    taxId?: boolean
    address?: boolean
    phone?: boolean
    createdat?: boolean
    createdby?: boolean
    updatedat?: boolean
    updatedby?: boolean
    status?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstname" | "lastname" | "email" | "planId" | "password" | "companyName" | "companyLogoUrl" | "taxId" | "address" | "phone" | "createdat" | "createdby" | "updatedat" | "updatedby" | "status", ExtArgs["result"]["user"]>
  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | user$invoicesArgs<ExtArgs>
    subscriptions?: boolean | user$subscriptionsArgs<ExtArgs>
    customers?: boolean | user$customersArgs<ExtArgs>
    parameters?: boolean | user$parametersArgs<ExtArgs>
    entrances?: boolean | user$entrancesArgs<ExtArgs>
    payments?: boolean | user$paymentsArgs<ExtArgs>
    plan?: boolean | user$planArgs<ExtArgs>
    transactions?: boolean | user$transactionsArgs<ExtArgs>
    notificationuser?: boolean | user$notificationuserArgs<ExtArgs>
    createdapiclients?: boolean | user$createdapiclientsArgs<ExtArgs>
    updatedapiclients?: boolean | user$updatedapiclientsArgs<ExtArgs>
    createdpermissions?: boolean | user$createdpermissionsArgs<ExtArgs>
    updatedpermissions?: boolean | user$updatedpermissionsArgs<ExtArgs>
    refreshtokens?: boolean | user$refreshtokensArgs<ExtArgs>
    createdroles?: boolean | user$createdrolesArgs<ExtArgs>
    updatedroles?: boolean | user$updatedrolesArgs<ExtArgs>
    createdrolepermissions?: boolean | user$createdrolepermissionsArgs<ExtArgs>
    updatedrolepermissions?: boolean | user$updatedrolepermissionsArgs<ExtArgs>
    createduser?: boolean | userDefaultArgs<ExtArgs>
    createdusers?: boolean | user$createdusersArgs<ExtArgs>
    updateduser?: boolean | user$updateduserArgs<ExtArgs>
    updatedusers?: boolean | user$updatedusersArgs<ExtArgs>
    createduserpermissions?: boolean | user$createduserpermissionsArgs<ExtArgs>
    updateduserpermissions?: boolean | user$updateduserpermissionsArgs<ExtArgs>
    userpermissions?: boolean | user$userpermissionsArgs<ExtArgs>
    createduserroles?: boolean | user$createduserrolesArgs<ExtArgs>
    updateduserroles?: boolean | user$updateduserrolesArgs<ExtArgs>
    userroles?: boolean | user$userrolesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type userIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | user$planArgs<ExtArgs>
    createduser?: boolean | userDefaultArgs<ExtArgs>
    updateduser?: boolean | user$updateduserArgs<ExtArgs>
  }
  export type userIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | user$planArgs<ExtArgs>
    createduser?: boolean | userDefaultArgs<ExtArgs>
    updateduser?: boolean | user$updateduserArgs<ExtArgs>
  }

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      invoices: Prisma.$invoicePayload<ExtArgs>[]
      subscriptions: Prisma.$subscriptionPayload<ExtArgs>[]
      customers: Prisma.$customerPayload<ExtArgs>[]
      parameters: Prisma.$parametersPayload<ExtArgs>[]
      entrances: Prisma.$entrancePayload<ExtArgs>[]
      payments: Prisma.$paymentPayload<ExtArgs>[]
      plan: Prisma.$planPayload<ExtArgs> | null
      transactions: Prisma.$transactionPayload<ExtArgs>[]
      notificationuser: Prisma.$notificationPayload<ExtArgs>[]
      createdapiclients: Prisma.$apiclientPayload<ExtArgs>[]
      updatedapiclients: Prisma.$apiclientPayload<ExtArgs>[]
      createdpermissions: Prisma.$permissionPayload<ExtArgs>[]
      updatedpermissions: Prisma.$permissionPayload<ExtArgs>[]
      refreshtokens: Prisma.$refreshtokenPayload<ExtArgs>[]
      createdroles: Prisma.$rolePayload<ExtArgs>[]
      updatedroles: Prisma.$rolePayload<ExtArgs>[]
      createdrolepermissions: Prisma.$rolepermissionPayload<ExtArgs>[]
      updatedrolepermissions: Prisma.$rolepermissionPayload<ExtArgs>[]
      createduser: Prisma.$userPayload<ExtArgs>
      createdusers: Prisma.$userPayload<ExtArgs>[]
      updateduser: Prisma.$userPayload<ExtArgs> | null
      updatedusers: Prisma.$userPayload<ExtArgs>[]
      createduserpermissions: Prisma.$userpermissionPayload<ExtArgs>[]
      updateduserpermissions: Prisma.$userpermissionPayload<ExtArgs>[]
      userpermissions: Prisma.$userpermissionPayload<ExtArgs>[]
      createduserroles: Prisma.$userrolePayload<ExtArgs>[]
      updateduserroles: Prisma.$userrolePayload<ExtArgs>[]
      userroles: Prisma.$userrolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstname: string
      lastname: string
      email: string
      planId: string | null
      password: string
      companyName: string | null
      companyLogoUrl: string | null
      taxId: string | null
      address: string | null
      phone: string | null
      createdat: Date
      createdby: string
      updatedat: Date | null
      updatedby: string | null
      status: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {userCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userCreateManyAndReturnArgs>(args?: SelectSubset<T, userCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {userUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userUpdateManyAndReturnArgs>(args: SelectSubset<T, userUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoices<T extends user$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, user$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends user$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, user$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customers<T extends user$customersArgs<ExtArgs> = {}>(args?: Subset<T, user$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parameters<T extends user$parametersArgs<ExtArgs> = {}>(args?: Subset<T, user$parametersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parametersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    entrances<T extends user$entrancesArgs<ExtArgs> = {}>(args?: Subset<T, user$entrancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entrancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends user$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, user$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    plan<T extends user$planArgs<ExtArgs> = {}>(args?: Subset<T, user$planArgs<ExtArgs>>): Prisma__planClient<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transactions<T extends user$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, user$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationuser<T extends user$notificationuserArgs<ExtArgs> = {}>(args?: Subset<T, user$notificationuserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdapiclients<T extends user$createdapiclientsArgs<ExtArgs> = {}>(args?: Subset<T, user$createdapiclientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$apiclientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedapiclients<T extends user$updatedapiclientsArgs<ExtArgs> = {}>(args?: Subset<T, user$updatedapiclientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$apiclientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdpermissions<T extends user$createdpermissionsArgs<ExtArgs> = {}>(args?: Subset<T, user$createdpermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedpermissions<T extends user$updatedpermissionsArgs<ExtArgs> = {}>(args?: Subset<T, user$updatedpermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    refreshtokens<T extends user$refreshtokensArgs<ExtArgs> = {}>(args?: Subset<T, user$refreshtokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdroles<T extends user$createdrolesArgs<ExtArgs> = {}>(args?: Subset<T, user$createdrolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedroles<T extends user$updatedrolesArgs<ExtArgs> = {}>(args?: Subset<T, user$updatedrolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdrolepermissions<T extends user$createdrolepermissionsArgs<ExtArgs> = {}>(args?: Subset<T, user$createdrolepermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedrolepermissions<T extends user$updatedrolepermissionsArgs<ExtArgs> = {}>(args?: Subset<T, user$updatedrolepermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createduser<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdusers<T extends user$createdusersArgs<ExtArgs> = {}>(args?: Subset<T, user$createdusersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updateduser<T extends user$updateduserArgs<ExtArgs> = {}>(args?: Subset<T, user$updateduserArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updatedusers<T extends user$updatedusersArgs<ExtArgs> = {}>(args?: Subset<T, user$updatedusersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createduserpermissions<T extends user$createduserpermissionsArgs<ExtArgs> = {}>(args?: Subset<T, user$createduserpermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userpermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updateduserpermissions<T extends user$updateduserpermissionsArgs<ExtArgs> = {}>(args?: Subset<T, user$updateduserpermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userpermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userpermissions<T extends user$userpermissionsArgs<ExtArgs> = {}>(args?: Subset<T, user$userpermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userpermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createduserroles<T extends user$createduserrolesArgs<ExtArgs> = {}>(args?: Subset<T, user$createduserrolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updateduserroles<T extends user$updateduserrolesArgs<ExtArgs> = {}>(args?: Subset<T, user$updateduserrolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userroles<T extends user$userrolesArgs<ExtArgs> = {}>(args?: Subset<T, user$userrolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'String'>
    readonly firstname: FieldRef<"user", 'String'>
    readonly lastname: FieldRef<"user", 'String'>
    readonly email: FieldRef<"user", 'String'>
    readonly planId: FieldRef<"user", 'String'>
    readonly password: FieldRef<"user", 'String'>
    readonly companyName: FieldRef<"user", 'String'>
    readonly companyLogoUrl: FieldRef<"user", 'String'>
    readonly taxId: FieldRef<"user", 'String'>
    readonly address: FieldRef<"user", 'String'>
    readonly phone: FieldRef<"user", 'String'>
    readonly createdat: FieldRef<"user", 'DateTime'>
    readonly createdby: FieldRef<"user", 'String'>
    readonly updatedat: FieldRef<"user", 'DateTime'>
    readonly updatedby: FieldRef<"user", 'String'>
    readonly status: FieldRef<"user", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user createManyAndReturn
   */
  export type userCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user updateManyAndReturn
   */
  export type userUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user.invoices
   */
  export type user$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    where?: invoiceWhereInput
    orderBy?: invoiceOrderByWithRelationInput | invoiceOrderByWithRelationInput[]
    cursor?: invoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * user.subscriptions
   */
  export type user$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionInclude<ExtArgs> | null
    where?: subscriptionWhereInput
    orderBy?: subscriptionOrderByWithRelationInput | subscriptionOrderByWithRelationInput[]
    cursor?: subscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * user.customers
   */
  export type user$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    where?: customerWhereInput
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    cursor?: customerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * user.parameters
   */
  export type user$parametersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parameters
     */
    select?: parametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parameters
     */
    omit?: parametersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parametersInclude<ExtArgs> | null
    where?: parametersWhereInput
    orderBy?: parametersOrderByWithRelationInput | parametersOrderByWithRelationInput[]
    cursor?: parametersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParametersScalarFieldEnum | ParametersScalarFieldEnum[]
  }

  /**
   * user.entrances
   */
  export type user$entrancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entrance
     */
    select?: entranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entrance
     */
    omit?: entranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entranceInclude<ExtArgs> | null
    where?: entranceWhereInput
    orderBy?: entranceOrderByWithRelationInput | entranceOrderByWithRelationInput[]
    cursor?: entranceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntranceScalarFieldEnum | EntranceScalarFieldEnum[]
  }

  /**
   * user.payments
   */
  export type user$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    where?: paymentWhereInput
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    cursor?: paymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * user.plan
   */
  export type user$planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planInclude<ExtArgs> | null
    where?: planWhereInput
  }

  /**
   * user.transactions
   */
  export type user$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    where?: transactionWhereInput
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    cursor?: transactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * user.notificationuser
   */
  export type user$notificationuserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    where?: notificationWhereInput
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    cursor?: notificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * user.createdapiclients
   */
  export type user$createdapiclientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apiclient
     */
    select?: apiclientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apiclient
     */
    omit?: apiclientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: apiclientInclude<ExtArgs> | null
    where?: apiclientWhereInput
    orderBy?: apiclientOrderByWithRelationInput | apiclientOrderByWithRelationInput[]
    cursor?: apiclientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiclientScalarFieldEnum | ApiclientScalarFieldEnum[]
  }

  /**
   * user.updatedapiclients
   */
  export type user$updatedapiclientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apiclient
     */
    select?: apiclientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apiclient
     */
    omit?: apiclientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: apiclientInclude<ExtArgs> | null
    where?: apiclientWhereInput
    orderBy?: apiclientOrderByWithRelationInput | apiclientOrderByWithRelationInput[]
    cursor?: apiclientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiclientScalarFieldEnum | ApiclientScalarFieldEnum[]
  }

  /**
   * user.createdpermissions
   */
  export type user$createdpermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    where?: permissionWhereInput
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    cursor?: permissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * user.updatedpermissions
   */
  export type user$updatedpermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    where?: permissionWhereInput
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    cursor?: permissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * user.refreshtokens
   */
  export type user$refreshtokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the refreshtoken
     */
    omit?: refreshtokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    where?: refreshtokenWhereInput
    orderBy?: refreshtokenOrderByWithRelationInput | refreshtokenOrderByWithRelationInput[]
    cursor?: refreshtokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshtokenScalarFieldEnum | RefreshtokenScalarFieldEnum[]
  }

  /**
   * user.createdroles
   */
  export type user$createdrolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    where?: roleWhereInput
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    cursor?: roleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * user.updatedroles
   */
  export type user$updatedrolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    where?: roleWhereInput
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    cursor?: roleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * user.createdrolepermissions
   */
  export type user$createdrolepermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
    where?: rolepermissionWhereInput
    orderBy?: rolepermissionOrderByWithRelationInput | rolepermissionOrderByWithRelationInput[]
    cursor?: rolepermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolepermissionScalarFieldEnum | RolepermissionScalarFieldEnum[]
  }

  /**
   * user.updatedrolepermissions
   */
  export type user$updatedrolepermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
    where?: rolepermissionWhereInput
    orderBy?: rolepermissionOrderByWithRelationInput | rolepermissionOrderByWithRelationInput[]
    cursor?: rolepermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolepermissionScalarFieldEnum | RolepermissionScalarFieldEnum[]
  }

  /**
   * user.createdusers
   */
  export type user$createdusersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    cursor?: userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user.updateduser
   */
  export type user$updateduserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * user.updatedusers
   */
  export type user$updatedusersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    cursor?: userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user.createduserpermissions
   */
  export type user$createduserpermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userpermission
     */
    select?: userpermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userpermission
     */
    omit?: userpermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userpermissionInclude<ExtArgs> | null
    where?: userpermissionWhereInput
    orderBy?: userpermissionOrderByWithRelationInput | userpermissionOrderByWithRelationInput[]
    cursor?: userpermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserpermissionScalarFieldEnum | UserpermissionScalarFieldEnum[]
  }

  /**
   * user.updateduserpermissions
   */
  export type user$updateduserpermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userpermission
     */
    select?: userpermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userpermission
     */
    omit?: userpermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userpermissionInclude<ExtArgs> | null
    where?: userpermissionWhereInput
    orderBy?: userpermissionOrderByWithRelationInput | userpermissionOrderByWithRelationInput[]
    cursor?: userpermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserpermissionScalarFieldEnum | UserpermissionScalarFieldEnum[]
  }

  /**
   * user.userpermissions
   */
  export type user$userpermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userpermission
     */
    select?: userpermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userpermission
     */
    omit?: userpermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userpermissionInclude<ExtArgs> | null
    where?: userpermissionWhereInput
    orderBy?: userpermissionOrderByWithRelationInput | userpermissionOrderByWithRelationInput[]
    cursor?: userpermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserpermissionScalarFieldEnum | UserpermissionScalarFieldEnum[]
  }

  /**
   * user.createduserroles
   */
  export type user$createduserrolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    where?: userroleWhereInput
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    cursor?: userroleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * user.updateduserroles
   */
  export type user$updateduserrolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    where?: userroleWhereInput
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    cursor?: userroleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * user.userroles
   */
  export type user$userrolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    where?: userroleWhereInput
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    cursor?: userroleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Model plan
   */

  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    price: string | null
    currency: string | null
    interval: string | null
    description: string | null
    stripePriceId: string | null
    stripeProductId: string | null
    createdat: Date | null
  }

  export type PlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    price: string | null
    currency: string | null
    interval: string | null
    description: string | null
    stripePriceId: string | null
    stripeProductId: string | null
    createdat: Date | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    name: number
    price: number
    currency: number
    interval: number
    description: number
    stripePriceId: number
    stripeProductId: number
    createdat: number
    _all: number
  }


  export type PlanMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    currency?: true
    interval?: true
    description?: true
    stripePriceId?: true
    stripeProductId?: true
    createdat?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    currency?: true
    interval?: true
    description?: true
    stripePriceId?: true
    stripeProductId?: true
    createdat?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    currency?: true
    interval?: true
    description?: true
    stripePriceId?: true
    stripeProductId?: true
    createdat?: true
    _all?: true
  }

  export type PlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plan to aggregate.
     */
    where?: planWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plans to fetch.
     */
    orderBy?: planOrderByWithRelationInput | planOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: planWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type planGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: planWhereInput
    orderBy?: planOrderByWithAggregationInput | planOrderByWithAggregationInput[]
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum
    having?: planScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }

  export type PlanGroupByOutputType = {
    id: string
    name: string
    price: string
    currency: string
    interval: string
    description: string | null
    stripePriceId: string | null
    stripeProductId: string | null
    createdat: Date
    _count: PlanCountAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends planGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type planSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    currency?: boolean
    interval?: boolean
    description?: boolean
    stripePriceId?: boolean
    stripeProductId?: boolean
    createdat?: boolean
    subscriptions?: boolean | plan$subscriptionsArgs<ExtArgs>
    users?: boolean | plan$usersArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>

  export type planSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    currency?: boolean
    interval?: boolean
    description?: boolean
    stripePriceId?: boolean
    stripeProductId?: boolean
    createdat?: boolean
  }, ExtArgs["result"]["plan"]>

  export type planSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    currency?: boolean
    interval?: boolean
    description?: boolean
    stripePriceId?: boolean
    stripeProductId?: boolean
    createdat?: boolean
  }, ExtArgs["result"]["plan"]>

  export type planSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
    currency?: boolean
    interval?: boolean
    description?: boolean
    stripePriceId?: boolean
    stripeProductId?: boolean
    createdat?: boolean
  }

  export type planOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "price" | "currency" | "interval" | "description" | "stripePriceId" | "stripeProductId" | "createdat", ExtArgs["result"]["plan"]>
  export type planInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | plan$subscriptionsArgs<ExtArgs>
    users?: boolean | plan$usersArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type planIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type planIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $planPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "plan"
    objects: {
      subscriptions: Prisma.$subscriptionPayload<ExtArgs>[]
      users: Prisma.$userPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      price: string
      currency: string
      interval: string
      description: string | null
      stripePriceId: string | null
      stripeProductId: string | null
      createdat: Date
    }, ExtArgs["result"]["plan"]>
    composites: {}
  }

  type planGetPayload<S extends boolean | null | undefined | planDefaultArgs> = $Result.GetResult<Prisma.$planPayload, S>

  type planCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<planFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanCountAggregateInputType | true
    }

  export interface planDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['plan'], meta: { name: 'plan' } }
    /**
     * Find zero or one Plan that matches the filter.
     * @param {planFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends planFindUniqueArgs>(args: SelectSubset<T, planFindUniqueArgs<ExtArgs>>): Prisma__planClient<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {planFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends planFindUniqueOrThrowArgs>(args: SelectSubset<T, planFindUniqueOrThrowArgs<ExtArgs>>): Prisma__planClient<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends planFindFirstArgs>(args?: SelectSubset<T, planFindFirstArgs<ExtArgs>>): Prisma__planClient<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends planFindFirstOrThrowArgs>(args?: SelectSubset<T, planFindFirstOrThrowArgs<ExtArgs>>): Prisma__planClient<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends planFindManyArgs>(args?: SelectSubset<T, planFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plan.
     * @param {planCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
     */
    create<T extends planCreateArgs>(args: SelectSubset<T, planCreateArgs<ExtArgs>>): Prisma__planClient<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plans.
     * @param {planCreateManyArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends planCreateManyArgs>(args?: SelectSubset<T, planCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plans and returns the data saved in the database.
     * @param {planCreateManyAndReturnArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends planCreateManyAndReturnArgs>(args?: SelectSubset<T, planCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Plan.
     * @param {planDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
     */
    delete<T extends planDeleteArgs>(args: SelectSubset<T, planDeleteArgs<ExtArgs>>): Prisma__planClient<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plan.
     * @param {planUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends planUpdateArgs>(args: SelectSubset<T, planUpdateArgs<ExtArgs>>): Prisma__planClient<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plans.
     * @param {planDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends planDeleteManyArgs>(args?: SelectSubset<T, planDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends planUpdateManyArgs>(args: SelectSubset<T, planUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans and returns the data updated in the database.
     * @param {planUpdateManyAndReturnArgs} args - Arguments to update many Plans.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends planUpdateManyAndReturnArgs>(args: SelectSubset<T, planUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Plan.
     * @param {planUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
     */
    upsert<T extends planUpsertArgs>(args: SelectSubset<T, planUpsertArgs<ExtArgs>>): Prisma__planClient<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends planCountArgs>(
      args?: Subset<T, planCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): Prisma.PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends planGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: planGroupByArgs['orderBy'] }
        : { orderBy?: planGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, planGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the plan model
   */
  readonly fields: planFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__planClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptions<T extends plan$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, plan$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends plan$usersArgs<ExtArgs> = {}>(args?: Subset<T, plan$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the plan model
   */
  interface planFieldRefs {
    readonly id: FieldRef<"plan", 'String'>
    readonly name: FieldRef<"plan", 'String'>
    readonly price: FieldRef<"plan", 'String'>
    readonly currency: FieldRef<"plan", 'String'>
    readonly interval: FieldRef<"plan", 'String'>
    readonly description: FieldRef<"plan", 'String'>
    readonly stripePriceId: FieldRef<"plan", 'String'>
    readonly stripeProductId: FieldRef<"plan", 'String'>
    readonly createdat: FieldRef<"plan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * plan findUnique
   */
  export type planFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planInclude<ExtArgs> | null
    /**
     * Filter, which plan to fetch.
     */
    where: planWhereUniqueInput
  }

  /**
   * plan findUniqueOrThrow
   */
  export type planFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planInclude<ExtArgs> | null
    /**
     * Filter, which plan to fetch.
     */
    where: planWhereUniqueInput
  }

  /**
   * plan findFirst
   */
  export type planFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planInclude<ExtArgs> | null
    /**
     * Filter, which plan to fetch.
     */
    where?: planWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plans to fetch.
     */
    orderBy?: planOrderByWithRelationInput | planOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plans.
     */
    cursor?: planWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * plan findFirstOrThrow
   */
  export type planFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planInclude<ExtArgs> | null
    /**
     * Filter, which plan to fetch.
     */
    where?: planWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plans to fetch.
     */
    orderBy?: planOrderByWithRelationInput | planOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plans.
     */
    cursor?: planWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * plan findMany
   */
  export type planFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planInclude<ExtArgs> | null
    /**
     * Filter, which plans to fetch.
     */
    where?: planWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plans to fetch.
     */
    orderBy?: planOrderByWithRelationInput | planOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plans.
     */
    cursor?: planWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plans.
     */
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * plan create
   */
  export type planCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planInclude<ExtArgs> | null
    /**
     * The data needed to create a plan.
     */
    data: XOR<planCreateInput, planUncheckedCreateInput>
  }

  /**
   * plan createMany
   */
  export type planCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many plans.
     */
    data: planCreateManyInput | planCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * plan createManyAndReturn
   */
  export type planCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * The data used to create many plans.
     */
    data: planCreateManyInput | planCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * plan update
   */
  export type planUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planInclude<ExtArgs> | null
    /**
     * The data needed to update a plan.
     */
    data: XOR<planUpdateInput, planUncheckedUpdateInput>
    /**
     * Choose, which plan to update.
     */
    where: planWhereUniqueInput
  }

  /**
   * plan updateMany
   */
  export type planUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update plans.
     */
    data: XOR<planUpdateManyMutationInput, planUncheckedUpdateManyInput>
    /**
     * Filter which plans to update
     */
    where?: planWhereInput
    /**
     * Limit how many plans to update.
     */
    limit?: number
  }

  /**
   * plan updateManyAndReturn
   */
  export type planUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * The data used to update plans.
     */
    data: XOR<planUpdateManyMutationInput, planUncheckedUpdateManyInput>
    /**
     * Filter which plans to update
     */
    where?: planWhereInput
    /**
     * Limit how many plans to update.
     */
    limit?: number
  }

  /**
   * plan upsert
   */
  export type planUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planInclude<ExtArgs> | null
    /**
     * The filter to search for the plan to update in case it exists.
     */
    where: planWhereUniqueInput
    /**
     * In case the plan found by the `where` argument doesn't exist, create a new plan with this data.
     */
    create: XOR<planCreateInput, planUncheckedCreateInput>
    /**
     * In case the plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<planUpdateInput, planUncheckedUpdateInput>
  }

  /**
   * plan delete
   */
  export type planDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planInclude<ExtArgs> | null
    /**
     * Filter which plan to delete.
     */
    where: planWhereUniqueInput
  }

  /**
   * plan deleteMany
   */
  export type planDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plans to delete
     */
    where?: planWhereInput
    /**
     * Limit how many plans to delete.
     */
    limit?: number
  }

  /**
   * plan.subscriptions
   */
  export type plan$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionInclude<ExtArgs> | null
    where?: subscriptionWhereInput
    orderBy?: subscriptionOrderByWithRelationInput | subscriptionOrderByWithRelationInput[]
    cursor?: subscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * plan.users
   */
  export type plan$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    cursor?: userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * plan without action
   */
  export type planDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planInclude<ExtArgs> | null
  }


  /**
   * Model subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    planId: string | null
    stripeId: string | null
    status: string | null
    startedat: Date | null
    endedat: Date | null
    canceledat: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    planId: string | null
    stripeId: string | null
    status: string | null
    startedat: Date | null
    endedat: Date | null
    canceledat: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    planId: number
    stripeId: number
    status: number
    startedat: number
    endedat: number
    canceledat: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    stripeId?: true
    status?: true
    startedat?: true
    endedat?: true
    canceledat?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    stripeId?: true
    status?: true
    startedat?: true
    endedat?: true
    canceledat?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    stripeId?: true
    status?: true
    startedat?: true
    endedat?: true
    canceledat?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscription to aggregate.
     */
    where?: subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionOrderByWithRelationInput | subscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type subscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subscriptionWhereInput
    orderBy?: subscriptionOrderByWithAggregationInput | subscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: subscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    userId: string
    planId: string
    stripeId: string | null
    status: string
    startedat: Date
    endedat: Date | null
    canceledat: Date | null
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends subscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type subscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    stripeId?: boolean
    status?: boolean
    startedat?: boolean
    endedat?: boolean
    canceledat?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    plan?: boolean | planDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type subscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    stripeId?: boolean
    status?: boolean
    startedat?: boolean
    endedat?: boolean
    canceledat?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    plan?: boolean | planDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type subscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    stripeId?: boolean
    status?: boolean
    startedat?: boolean
    endedat?: boolean
    canceledat?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    plan?: boolean | planDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type subscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    planId?: boolean
    stripeId?: boolean
    status?: boolean
    startedat?: boolean
    endedat?: boolean
    canceledat?: boolean
  }

  export type subscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "planId" | "stripeId" | "status" | "startedat" | "endedat" | "canceledat", ExtArgs["result"]["subscription"]>
  export type subscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    plan?: boolean | planDefaultArgs<ExtArgs>
  }
  export type subscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    plan?: boolean | planDefaultArgs<ExtArgs>
  }
  export type subscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    plan?: boolean | planDefaultArgs<ExtArgs>
  }

  export type $subscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "subscription"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      plan: Prisma.$planPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      planId: string
      stripeId: string | null
      status: string
      startedat: Date
      endedat: Date | null
      canceledat: Date | null
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type subscriptionGetPayload<S extends boolean | null | undefined | subscriptionDefaultArgs> = $Result.GetResult<Prisma.$subscriptionPayload, S>

  type subscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<subscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface subscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['subscription'], meta: { name: 'subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {subscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subscriptionFindUniqueArgs>(args: SelectSubset<T, subscriptionFindUniqueArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {subscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, subscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subscriptionFindFirstArgs>(args?: SelectSubset<T, subscriptionFindFirstArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, subscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends subscriptionFindManyArgs>(args?: SelectSubset<T, subscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {subscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends subscriptionCreateArgs>(args: SelectSubset<T, subscriptionCreateArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {subscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends subscriptionCreateManyArgs>(args?: SelectSubset<T, subscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {subscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends subscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, subscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {subscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends subscriptionDeleteArgs>(args: SelectSubset<T, subscriptionDeleteArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {subscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends subscriptionUpdateArgs>(args: SelectSubset<T, subscriptionUpdateArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {subscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends subscriptionDeleteManyArgs>(args?: SelectSubset<T, subscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends subscriptionUpdateManyArgs>(args: SelectSubset<T, subscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {subscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends subscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, subscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {subscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends subscriptionUpsertArgs>(args: SelectSubset<T, subscriptionUpsertArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends subscriptionCountArgs>(
      args?: Subset<T, subscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends subscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subscriptionGroupByArgs['orderBy'] }
        : { orderBy?: subscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, subscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the subscription model
   */
  readonly fields: subscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plan<T extends planDefaultArgs<ExtArgs> = {}>(args?: Subset<T, planDefaultArgs<ExtArgs>>): Prisma__planClient<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the subscription model
   */
  interface subscriptionFieldRefs {
    readonly id: FieldRef<"subscription", 'String'>
    readonly userId: FieldRef<"subscription", 'String'>
    readonly planId: FieldRef<"subscription", 'String'>
    readonly stripeId: FieldRef<"subscription", 'String'>
    readonly status: FieldRef<"subscription", 'String'>
    readonly startedat: FieldRef<"subscription", 'DateTime'>
    readonly endedat: FieldRef<"subscription", 'DateTime'>
    readonly canceledat: FieldRef<"subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * subscription findUnique
   */
  export type subscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * Filter, which subscription to fetch.
     */
    where: subscriptionWhereUniqueInput
  }

  /**
   * subscription findUniqueOrThrow
   */
  export type subscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * Filter, which subscription to fetch.
     */
    where: subscriptionWhereUniqueInput
  }

  /**
   * subscription findFirst
   */
  export type subscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * Filter, which subscription to fetch.
     */
    where?: subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionOrderByWithRelationInput | subscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * subscription findFirstOrThrow
   */
  export type subscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * Filter, which subscription to fetch.
     */
    where?: subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionOrderByWithRelationInput | subscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * subscription findMany
   */
  export type subscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionOrderByWithRelationInput | subscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subscriptions.
     */
    cursor?: subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * subscription create
   */
  export type subscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a subscription.
     */
    data: XOR<subscriptionCreateInput, subscriptionUncheckedCreateInput>
  }

  /**
   * subscription createMany
   */
  export type subscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many subscriptions.
     */
    data: subscriptionCreateManyInput | subscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * subscription createManyAndReturn
   */
  export type subscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many subscriptions.
     */
    data: subscriptionCreateManyInput | subscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * subscription update
   */
  export type subscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a subscription.
     */
    data: XOR<subscriptionUpdateInput, subscriptionUncheckedUpdateInput>
    /**
     * Choose, which subscription to update.
     */
    where: subscriptionWhereUniqueInput
  }

  /**
   * subscription updateMany
   */
  export type subscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update subscriptions.
     */
    data: XOR<subscriptionUpdateManyMutationInput, subscriptionUncheckedUpdateManyInput>
    /**
     * Filter which subscriptions to update
     */
    where?: subscriptionWhereInput
    /**
     * Limit how many subscriptions to update.
     */
    limit?: number
  }

  /**
   * subscription updateManyAndReturn
   */
  export type subscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * The data used to update subscriptions.
     */
    data: XOR<subscriptionUpdateManyMutationInput, subscriptionUncheckedUpdateManyInput>
    /**
     * Filter which subscriptions to update
     */
    where?: subscriptionWhereInput
    /**
     * Limit how many subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * subscription upsert
   */
  export type subscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the subscription to update in case it exists.
     */
    where: subscriptionWhereUniqueInput
    /**
     * In case the subscription found by the `where` argument doesn't exist, create a new subscription with this data.
     */
    create: XOR<subscriptionCreateInput, subscriptionUncheckedCreateInput>
    /**
     * In case the subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subscriptionUpdateInput, subscriptionUncheckedUpdateInput>
  }

  /**
   * subscription delete
   */
  export type subscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * Filter which subscription to delete.
     */
    where: subscriptionWhereUniqueInput
  }

  /**
   * subscription deleteMany
   */
  export type subscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscriptions to delete
     */
    where?: subscriptionWhereInput
    /**
     * Limit how many subscriptions to delete.
     */
    limit?: number
  }

  /**
   * subscription without action
   */
  export type subscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionInclude<ExtArgs> | null
  }


  /**
   * Model customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    email: string | null
    createdat: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    email: string | null
    createdat: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    email: number
    createdat: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    email?: true
    createdat?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    email?: true
    createdat?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    email?: true
    createdat?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customer to aggregate.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type customerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerWhereInput
    orderBy?: customerOrderByWithAggregationInput | customerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: customerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    userId: string
    name: string
    email: string
    createdat: Date
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends customerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type customerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    email?: boolean
    createdat?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    invoices?: boolean | customer$invoicesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type customerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    email?: boolean
    createdat?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type customerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    email?: boolean
    createdat?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type customerSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    email?: boolean
    createdat?: boolean
  }

  export type customerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "email" | "createdat", ExtArgs["result"]["customer"]>
  export type customerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    invoices?: boolean | customer$invoicesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type customerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type customerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $customerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customer"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      invoices: Prisma.$invoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      email: string
      createdat: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type customerGetPayload<S extends boolean | null | undefined | customerDefaultArgs> = $Result.GetResult<Prisma.$customerPayload, S>

  type customerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<customerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface customerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customer'], meta: { name: 'customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {customerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends customerFindUniqueArgs>(args: SelectSubset<T, customerFindUniqueArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {customerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends customerFindUniqueOrThrowArgs>(args: SelectSubset<T, customerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends customerFindFirstArgs>(args?: SelectSubset<T, customerFindFirstArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends customerFindFirstOrThrowArgs>(args?: SelectSubset<T, customerFindFirstOrThrowArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends customerFindManyArgs>(args?: SelectSubset<T, customerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {customerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends customerCreateArgs>(args: SelectSubset<T, customerCreateArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {customerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends customerCreateManyArgs>(args?: SelectSubset<T, customerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {customerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends customerCreateManyAndReturnArgs>(args?: SelectSubset<T, customerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {customerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends customerDeleteArgs>(args: SelectSubset<T, customerDeleteArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {customerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends customerUpdateArgs>(args: SelectSubset<T, customerUpdateArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {customerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends customerDeleteManyArgs>(args?: SelectSubset<T, customerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends customerUpdateManyArgs>(args: SelectSubset<T, customerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {customerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends customerUpdateManyAndReturnArgs>(args: SelectSubset<T, customerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {customerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends customerUpsertArgs>(args: SelectSubset<T, customerUpsertArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends customerCountArgs>(
      args?: Subset<T, customerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customerGroupByArgs['orderBy'] }
        : { orderBy?: customerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customer model
   */
  readonly fields: customerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoices<T extends customer$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, customer$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the customer model
   */
  interface customerFieldRefs {
    readonly id: FieldRef<"customer", 'String'>
    readonly userId: FieldRef<"customer", 'String'>
    readonly name: FieldRef<"customer", 'String'>
    readonly email: FieldRef<"customer", 'String'>
    readonly createdat: FieldRef<"customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * customer findUnique
   */
  export type customerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer findUniqueOrThrow
   */
  export type customerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer findFirst
   */
  export type customerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer findFirstOrThrow
   */
  export type customerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer findMany
   */
  export type customerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer create
   */
  export type customerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The data needed to create a customer.
     */
    data: XOR<customerCreateInput, customerUncheckedCreateInput>
  }

  /**
   * customer createMany
   */
  export type customerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customers.
     */
    data: customerCreateManyInput | customerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customer createManyAndReturn
   */
  export type customerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * The data used to create many customers.
     */
    data: customerCreateManyInput | customerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * customer update
   */
  export type customerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The data needed to update a customer.
     */
    data: XOR<customerUpdateInput, customerUncheckedUpdateInput>
    /**
     * Choose, which customer to update.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer updateMany
   */
  export type customerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customers.
     */
    data: XOR<customerUpdateManyMutationInput, customerUncheckedUpdateManyInput>
    /**
     * Filter which customers to update
     */
    where?: customerWhereInput
    /**
     * Limit how many customers to update.
     */
    limit?: number
  }

  /**
   * customer updateManyAndReturn
   */
  export type customerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * The data used to update customers.
     */
    data: XOR<customerUpdateManyMutationInput, customerUncheckedUpdateManyInput>
    /**
     * Filter which customers to update
     */
    where?: customerWhereInput
    /**
     * Limit how many customers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * customer upsert
   */
  export type customerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The filter to search for the customer to update in case it exists.
     */
    where: customerWhereUniqueInput
    /**
     * In case the customer found by the `where` argument doesn't exist, create a new customer with this data.
     */
    create: XOR<customerCreateInput, customerUncheckedCreateInput>
    /**
     * In case the customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customerUpdateInput, customerUncheckedUpdateInput>
  }

  /**
   * customer delete
   */
  export type customerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter which customer to delete.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer deleteMany
   */
  export type customerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customers to delete
     */
    where?: customerWhereInput
    /**
     * Limit how many customers to delete.
     */
    limit?: number
  }

  /**
   * customer.invoices
   */
  export type customer$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    where?: invoiceWhereInput
    orderBy?: invoiceOrderByWithRelationInput | invoiceOrderByWithRelationInput[]
    cursor?: invoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * customer without action
   */
  export type customerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
  }


  /**
   * Model invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    amount: number | null
    userId: string | null
    customerId: string | null
    createdat: Date | null
    status: string | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    amount: number | null
    userId: string | null
    customerId: string | null
    createdat: Date | null
    status: string | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    title: number
    description: number
    amount: number
    userId: number
    customerId: number
    createdat: number
    status: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    amount?: true
  }

  export type InvoiceSumAggregateInputType = {
    amount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    amount?: true
    userId?: true
    customerId?: true
    createdat?: true
    status?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    amount?: true
    userId?: true
    customerId?: true
    createdat?: true
    status?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    amount?: true
    userId?: true
    customerId?: true
    createdat?: true
    status?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invoice to aggregate.
     */
    where?: invoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     */
    orderBy?: invoiceOrderByWithRelationInput | invoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type invoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoiceWhereInput
    orderBy?: invoiceOrderByWithAggregationInput | invoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: invoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    title: string
    description: string | null
    amount: number
    userId: string
    customerId: string
    createdat: Date
    status: string
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends invoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type invoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    amount?: boolean
    userId?: boolean
    customerId?: boolean
    createdat?: boolean
    status?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    customer?: boolean | customerDefaultArgs<ExtArgs>
    payments?: boolean | invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type invoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    amount?: boolean
    userId?: boolean
    customerId?: boolean
    createdat?: boolean
    status?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type invoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    amount?: boolean
    userId?: boolean
    customerId?: boolean
    createdat?: boolean
    status?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type invoiceSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    amount?: boolean
    userId?: boolean
    customerId?: boolean
    createdat?: boolean
    status?: boolean
  }

  export type invoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "amount" | "userId" | "customerId" | "createdat" | "status", ExtArgs["result"]["invoice"]>
  export type invoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    customer?: boolean | customerDefaultArgs<ExtArgs>
    payments?: boolean | invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type invoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }
  export type invoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }

  export type $invoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "invoice"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      customer: Prisma.$customerPayload<ExtArgs>
      payments: Prisma.$paymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      amount: number
      userId: string
      customerId: string
      createdat: Date
      status: string
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type invoiceGetPayload<S extends boolean | null | undefined | invoiceDefaultArgs> = $Result.GetResult<Prisma.$invoicePayload, S>

  type invoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<invoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface invoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invoice'], meta: { name: 'invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {invoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends invoiceFindUniqueArgs>(args: SelectSubset<T, invoiceFindUniqueArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {invoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends invoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, invoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends invoiceFindFirstArgs>(args?: SelectSubset<T, invoiceFindFirstArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends invoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, invoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends invoiceFindManyArgs>(args?: SelectSubset<T, invoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {invoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends invoiceCreateArgs>(args: SelectSubset<T, invoiceCreateArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {invoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends invoiceCreateManyArgs>(args?: SelectSubset<T, invoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {invoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends invoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, invoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {invoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends invoiceDeleteArgs>(args: SelectSubset<T, invoiceDeleteArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {invoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends invoiceUpdateArgs>(args: SelectSubset<T, invoiceUpdateArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {invoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends invoiceDeleteManyArgs>(args?: SelectSubset<T, invoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends invoiceUpdateManyArgs>(args: SelectSubset<T, invoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {invoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends invoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, invoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {invoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends invoiceUpsertArgs>(args: SelectSubset<T, invoiceUpsertArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends invoiceCountArgs>(
      args?: Subset<T, invoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invoiceGroupByArgs['orderBy'] }
        : { orderBy?: invoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invoice model
   */
  readonly fields: invoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends customerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, customerDefaultArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the invoice model
   */
  interface invoiceFieldRefs {
    readonly id: FieldRef<"invoice", 'String'>
    readonly title: FieldRef<"invoice", 'String'>
    readonly description: FieldRef<"invoice", 'String'>
    readonly amount: FieldRef<"invoice", 'Int'>
    readonly userId: FieldRef<"invoice", 'String'>
    readonly customerId: FieldRef<"invoice", 'String'>
    readonly createdat: FieldRef<"invoice", 'DateTime'>
    readonly status: FieldRef<"invoice", 'String'>
  }
    

  // Custom InputTypes
  /**
   * invoice findUnique
   */
  export type invoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * Filter, which invoice to fetch.
     */
    where: invoiceWhereUniqueInput
  }

  /**
   * invoice findUniqueOrThrow
   */
  export type invoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * Filter, which invoice to fetch.
     */
    where: invoiceWhereUniqueInput
  }

  /**
   * invoice findFirst
   */
  export type invoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * Filter, which invoice to fetch.
     */
    where?: invoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     */
    orderBy?: invoiceOrderByWithRelationInput | invoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invoices.
     */
    cursor?: invoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * invoice findFirstOrThrow
   */
  export type invoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * Filter, which invoice to fetch.
     */
    where?: invoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     */
    orderBy?: invoiceOrderByWithRelationInput | invoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invoices.
     */
    cursor?: invoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * invoice findMany
   */
  export type invoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * Filter, which invoices to fetch.
     */
    where?: invoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     */
    orderBy?: invoiceOrderByWithRelationInput | invoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invoices.
     */
    cursor?: invoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * invoice create
   */
  export type invoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a invoice.
     */
    data: XOR<invoiceCreateInput, invoiceUncheckedCreateInput>
  }

  /**
   * invoice createMany
   */
  export type invoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invoices.
     */
    data: invoiceCreateManyInput | invoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * invoice createManyAndReturn
   */
  export type invoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * The data used to create many invoices.
     */
    data: invoiceCreateManyInput | invoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * invoice update
   */
  export type invoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a invoice.
     */
    data: XOR<invoiceUpdateInput, invoiceUncheckedUpdateInput>
    /**
     * Choose, which invoice to update.
     */
    where: invoiceWhereUniqueInput
  }

  /**
   * invoice updateMany
   */
  export type invoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invoices.
     */
    data: XOR<invoiceUpdateManyMutationInput, invoiceUncheckedUpdateManyInput>
    /**
     * Filter which invoices to update
     */
    where?: invoiceWhereInput
    /**
     * Limit how many invoices to update.
     */
    limit?: number
  }

  /**
   * invoice updateManyAndReturn
   */
  export type invoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * The data used to update invoices.
     */
    data: XOR<invoiceUpdateManyMutationInput, invoiceUncheckedUpdateManyInput>
    /**
     * Filter which invoices to update
     */
    where?: invoiceWhereInput
    /**
     * Limit how many invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * invoice upsert
   */
  export type invoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the invoice to update in case it exists.
     */
    where: invoiceWhereUniqueInput
    /**
     * In case the invoice found by the `where` argument doesn't exist, create a new invoice with this data.
     */
    create: XOR<invoiceCreateInput, invoiceUncheckedCreateInput>
    /**
     * In case the invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invoiceUpdateInput, invoiceUncheckedUpdateInput>
  }

  /**
   * invoice delete
   */
  export type invoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * Filter which invoice to delete.
     */
    where: invoiceWhereUniqueInput
  }

  /**
   * invoice deleteMany
   */
  export type invoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invoices to delete
     */
    where?: invoiceWhereInput
    /**
     * Limit how many invoices to delete.
     */
    limit?: number
  }

  /**
   * invoice.payments
   */
  export type invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    where?: paymentWhereInput
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    cursor?: paymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * invoice without action
   */
  export type invoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoice
     */
    omit?: invoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
  }


  /**
   * Model payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: string | null
    currency: string | null
    invoiceId: string | null
    stripeId: string | null
    status: string | null
    createdat: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: string | null
    currency: string | null
    invoiceId: string | null
    stripeId: string | null
    status: string | null
    createdat: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    currency: number
    invoiceId: number
    stripeId: number
    status: number
    createdat: number
    _all: number
  }


  export type PaymentMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    invoiceId?: true
    stripeId?: true
    status?: true
    createdat?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    invoiceId?: true
    stripeId?: true
    status?: true
    createdat?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    invoiceId?: true
    stripeId?: true
    status?: true
    createdat?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment to aggregate.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type paymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentWhereInput
    orderBy?: paymentOrderByWithAggregationInput | paymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: paymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    userId: string
    amount: string
    currency: string
    invoiceId: string
    stripeId: string | null
    status: string
    createdat: Date
    _count: PaymentCountAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends paymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type paymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    invoiceId?: boolean
    stripeId?: boolean
    status?: boolean
    createdat?: boolean
    invoice?: boolean | invoiceDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type paymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    invoiceId?: boolean
    stripeId?: boolean
    status?: boolean
    createdat?: boolean
    invoice?: boolean | invoiceDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type paymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    invoiceId?: boolean
    stripeId?: boolean
    status?: boolean
    createdat?: boolean
    invoice?: boolean | invoiceDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type paymentSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    invoiceId?: boolean
    stripeId?: boolean
    status?: boolean
    createdat?: boolean
  }

  export type paymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "amount" | "currency" | "invoiceId" | "stripeId" | "status" | "createdat", ExtArgs["result"]["payment"]>
  export type paymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | invoiceDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type paymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | invoiceDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type paymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | invoiceDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $paymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment"
    objects: {
      invoice: Prisma.$invoicePayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      amount: string
      currency: string
      invoiceId: string
      stripeId: string | null
      status: string
      createdat: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type paymentGetPayload<S extends boolean | null | undefined | paymentDefaultArgs> = $Result.GetResult<Prisma.$paymentPayload, S>

  type paymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface paymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment'], meta: { name: 'payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {paymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentFindUniqueArgs>(args: SelectSubset<T, paymentFindUniqueArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentFindFirstArgs>(args?: SelectSubset<T, paymentFindFirstArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends paymentFindManyArgs>(args?: SelectSubset<T, paymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {paymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends paymentCreateArgs>(args: SelectSubset<T, paymentCreateArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {paymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentCreateManyArgs>(args?: SelectSubset<T, paymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {paymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paymentCreateManyAndReturnArgs>(args?: SelectSubset<T, paymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {paymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends paymentDeleteArgs>(args: SelectSubset<T, paymentDeleteArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {paymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentUpdateArgs>(args: SelectSubset<T, paymentUpdateArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {paymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentDeleteManyArgs>(args?: SelectSubset<T, paymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentUpdateManyArgs>(args: SelectSubset<T, paymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {paymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends paymentUpdateManyAndReturnArgs>(args: SelectSubset<T, paymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {paymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends paymentUpsertArgs>(args: SelectSubset<T, paymentUpsertArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentCountArgs>(
      args?: Subset<T, paymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentGroupByArgs['orderBy'] }
        : { orderBy?: paymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment model
   */
  readonly fields: paymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends invoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, invoiceDefaultArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment model
   */
  interface paymentFieldRefs {
    readonly id: FieldRef<"payment", 'String'>
    readonly userId: FieldRef<"payment", 'String'>
    readonly amount: FieldRef<"payment", 'String'>
    readonly currency: FieldRef<"payment", 'String'>
    readonly invoiceId: FieldRef<"payment", 'String'>
    readonly stripeId: FieldRef<"payment", 'String'>
    readonly status: FieldRef<"payment", 'String'>
    readonly createdat: FieldRef<"payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * payment findUnique
   */
  export type paymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment findUniqueOrThrow
   */
  export type paymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment findFirst
   */
  export type paymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment findFirstOrThrow
   */
  export type paymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment findMany
   */
  export type paymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment create
   */
  export type paymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * The data needed to create a payment.
     */
    data: XOR<paymentCreateInput, paymentUncheckedCreateInput>
  }

  /**
   * payment createMany
   */
  export type paymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentCreateManyInput | paymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment createManyAndReturn
   */
  export type paymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * The data used to create many payments.
     */
    data: paymentCreateManyInput | paymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payment update
   */
  export type paymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * The data needed to update a payment.
     */
    data: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
    /**
     * Choose, which payment to update.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment updateMany
   */
  export type paymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
  }

  /**
   * payment updateManyAndReturn
   */
  export type paymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * The data used to update payments.
     */
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * payment upsert
   */
  export type paymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * The filter to search for the payment to update in case it exists.
     */
    where: paymentWhereUniqueInput
    /**
     * In case the payment found by the `where` argument doesn't exist, create a new payment with this data.
     */
    create: XOR<paymentCreateInput, paymentUncheckedCreateInput>
    /**
     * In case the payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
  }

  /**
   * payment delete
   */
  export type paymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter which payment to delete.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment deleteMany
   */
  export type paymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentWhereInput
    /**
     * Limit how many payments to delete.
     */
    limit?: number
  }

  /**
   * payment without action
   */
  export type paymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
  }


  /**
   * Model parameters
   */

  export type AggregateParameters = {
    _count: ParametersCountAggregateOutputType | null
    _avg: ParametersAvgAggregateOutputType | null
    _sum: ParametersSumAggregateOutputType | null
    _min: ParametersMinAggregateOutputType | null
    _max: ParametersMaxAggregateOutputType | null
  }

  export type ParametersAvgAggregateOutputType = {
    status: number | null
  }

  export type ParametersSumAggregateOutputType = {
    status: number | null
  }

  export type ParametersMinAggregateOutputType = {
    id: string | null
    key: string | null
    name: string | null
    value: string | null
    createdat: Date | null
    status: number | null
    userId: string | null
  }

  export type ParametersMaxAggregateOutputType = {
    id: string | null
    key: string | null
    name: string | null
    value: string | null
    createdat: Date | null
    status: number | null
    userId: string | null
  }

  export type ParametersCountAggregateOutputType = {
    id: number
    key: number
    name: number
    value: number
    createdat: number
    status: number
    userId: number
    _all: number
  }


  export type ParametersAvgAggregateInputType = {
    status?: true
  }

  export type ParametersSumAggregateInputType = {
    status?: true
  }

  export type ParametersMinAggregateInputType = {
    id?: true
    key?: true
    name?: true
    value?: true
    createdat?: true
    status?: true
    userId?: true
  }

  export type ParametersMaxAggregateInputType = {
    id?: true
    key?: true
    name?: true
    value?: true
    createdat?: true
    status?: true
    userId?: true
  }

  export type ParametersCountAggregateInputType = {
    id?: true
    key?: true
    name?: true
    value?: true
    createdat?: true
    status?: true
    userId?: true
    _all?: true
  }

  export type ParametersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which parameters to aggregate.
     */
    where?: parametersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parameters to fetch.
     */
    orderBy?: parametersOrderByWithRelationInput | parametersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: parametersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned parameters
    **/
    _count?: true | ParametersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParametersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParametersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParametersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParametersMaxAggregateInputType
  }

  export type GetParametersAggregateType<T extends ParametersAggregateArgs> = {
        [P in keyof T & keyof AggregateParameters]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParameters[P]>
      : GetScalarType<T[P], AggregateParameters[P]>
  }




  export type parametersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: parametersWhereInput
    orderBy?: parametersOrderByWithAggregationInput | parametersOrderByWithAggregationInput[]
    by: ParametersScalarFieldEnum[] | ParametersScalarFieldEnum
    having?: parametersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParametersCountAggregateInputType | true
    _avg?: ParametersAvgAggregateInputType
    _sum?: ParametersSumAggregateInputType
    _min?: ParametersMinAggregateInputType
    _max?: ParametersMaxAggregateInputType
  }

  export type ParametersGroupByOutputType = {
    id: string
    key: string
    name: string
    value: string
    createdat: Date
    status: number
    userId: string
    _count: ParametersCountAggregateOutputType | null
    _avg: ParametersAvgAggregateOutputType | null
    _sum: ParametersSumAggregateOutputType | null
    _min: ParametersMinAggregateOutputType | null
    _max: ParametersMaxAggregateOutputType | null
  }

  type GetParametersGroupByPayload<T extends parametersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParametersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParametersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParametersGroupByOutputType[P]>
            : GetScalarType<T[P], ParametersGroupByOutputType[P]>
        }
      >
    >


  export type parametersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    value?: boolean
    createdat?: boolean
    status?: boolean
    userId?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parameters"]>

  export type parametersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    value?: boolean
    createdat?: boolean
    status?: boolean
    userId?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parameters"]>

  export type parametersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    value?: boolean
    createdat?: boolean
    status?: boolean
    userId?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parameters"]>

  export type parametersSelectScalar = {
    id?: boolean
    key?: boolean
    name?: boolean
    value?: boolean
    createdat?: boolean
    status?: boolean
    userId?: boolean
  }

  export type parametersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "name" | "value" | "createdat" | "status" | "userId", ExtArgs["result"]["parameters"]>
  export type parametersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type parametersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type parametersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $parametersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "parameters"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      name: string
      value: string
      createdat: Date
      status: number
      userId: string
    }, ExtArgs["result"]["parameters"]>
    composites: {}
  }

  type parametersGetPayload<S extends boolean | null | undefined | parametersDefaultArgs> = $Result.GetResult<Prisma.$parametersPayload, S>

  type parametersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<parametersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParametersCountAggregateInputType | true
    }

  export interface parametersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['parameters'], meta: { name: 'parameters' } }
    /**
     * Find zero or one Parameters that matches the filter.
     * @param {parametersFindUniqueArgs} args - Arguments to find a Parameters
     * @example
     * // Get one Parameters
     * const parameters = await prisma.parameters.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends parametersFindUniqueArgs>(args: SelectSubset<T, parametersFindUniqueArgs<ExtArgs>>): Prisma__parametersClient<$Result.GetResult<Prisma.$parametersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Parameters that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {parametersFindUniqueOrThrowArgs} args - Arguments to find a Parameters
     * @example
     * // Get one Parameters
     * const parameters = await prisma.parameters.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends parametersFindUniqueOrThrowArgs>(args: SelectSubset<T, parametersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__parametersClient<$Result.GetResult<Prisma.$parametersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parameters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parametersFindFirstArgs} args - Arguments to find a Parameters
     * @example
     * // Get one Parameters
     * const parameters = await prisma.parameters.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends parametersFindFirstArgs>(args?: SelectSubset<T, parametersFindFirstArgs<ExtArgs>>): Prisma__parametersClient<$Result.GetResult<Prisma.$parametersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parameters that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parametersFindFirstOrThrowArgs} args - Arguments to find a Parameters
     * @example
     * // Get one Parameters
     * const parameters = await prisma.parameters.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends parametersFindFirstOrThrowArgs>(args?: SelectSubset<T, parametersFindFirstOrThrowArgs<ExtArgs>>): Prisma__parametersClient<$Result.GetResult<Prisma.$parametersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parameters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parametersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parameters
     * const parameters = await prisma.parameters.findMany()
     * 
     * // Get first 10 Parameters
     * const parameters = await prisma.parameters.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parametersWithIdOnly = await prisma.parameters.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends parametersFindManyArgs>(args?: SelectSubset<T, parametersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parametersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Parameters.
     * @param {parametersCreateArgs} args - Arguments to create a Parameters.
     * @example
     * // Create one Parameters
     * const Parameters = await prisma.parameters.create({
     *   data: {
     *     // ... data to create a Parameters
     *   }
     * })
     * 
     */
    create<T extends parametersCreateArgs>(args: SelectSubset<T, parametersCreateArgs<ExtArgs>>): Prisma__parametersClient<$Result.GetResult<Prisma.$parametersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Parameters.
     * @param {parametersCreateManyArgs} args - Arguments to create many Parameters.
     * @example
     * // Create many Parameters
     * const parameters = await prisma.parameters.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends parametersCreateManyArgs>(args?: SelectSubset<T, parametersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Parameters and returns the data saved in the database.
     * @param {parametersCreateManyAndReturnArgs} args - Arguments to create many Parameters.
     * @example
     * // Create many Parameters
     * const parameters = await prisma.parameters.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Parameters and only return the `id`
     * const parametersWithIdOnly = await prisma.parameters.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends parametersCreateManyAndReturnArgs>(args?: SelectSubset<T, parametersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parametersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Parameters.
     * @param {parametersDeleteArgs} args - Arguments to delete one Parameters.
     * @example
     * // Delete one Parameters
     * const Parameters = await prisma.parameters.delete({
     *   where: {
     *     // ... filter to delete one Parameters
     *   }
     * })
     * 
     */
    delete<T extends parametersDeleteArgs>(args: SelectSubset<T, parametersDeleteArgs<ExtArgs>>): Prisma__parametersClient<$Result.GetResult<Prisma.$parametersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Parameters.
     * @param {parametersUpdateArgs} args - Arguments to update one Parameters.
     * @example
     * // Update one Parameters
     * const parameters = await prisma.parameters.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends parametersUpdateArgs>(args: SelectSubset<T, parametersUpdateArgs<ExtArgs>>): Prisma__parametersClient<$Result.GetResult<Prisma.$parametersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Parameters.
     * @param {parametersDeleteManyArgs} args - Arguments to filter Parameters to delete.
     * @example
     * // Delete a few Parameters
     * const { count } = await prisma.parameters.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends parametersDeleteManyArgs>(args?: SelectSubset<T, parametersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parametersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parameters
     * const parameters = await prisma.parameters.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends parametersUpdateManyArgs>(args: SelectSubset<T, parametersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parameters and returns the data updated in the database.
     * @param {parametersUpdateManyAndReturnArgs} args - Arguments to update many Parameters.
     * @example
     * // Update many Parameters
     * const parameters = await prisma.parameters.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Parameters and only return the `id`
     * const parametersWithIdOnly = await prisma.parameters.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends parametersUpdateManyAndReturnArgs>(args: SelectSubset<T, parametersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parametersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Parameters.
     * @param {parametersUpsertArgs} args - Arguments to update or create a Parameters.
     * @example
     * // Update or create a Parameters
     * const parameters = await prisma.parameters.upsert({
     *   create: {
     *     // ... data to create a Parameters
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parameters we want to update
     *   }
     * })
     */
    upsert<T extends parametersUpsertArgs>(args: SelectSubset<T, parametersUpsertArgs<ExtArgs>>): Prisma__parametersClient<$Result.GetResult<Prisma.$parametersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Parameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parametersCountArgs} args - Arguments to filter Parameters to count.
     * @example
     * // Count the number of Parameters
     * const count = await prisma.parameters.count({
     *   where: {
     *     // ... the filter for the Parameters we want to count
     *   }
     * })
    **/
    count<T extends parametersCountArgs>(
      args?: Subset<T, parametersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParametersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParametersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParametersAggregateArgs>(args: Subset<T, ParametersAggregateArgs>): Prisma.PrismaPromise<GetParametersAggregateType<T>>

    /**
     * Group by Parameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parametersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends parametersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: parametersGroupByArgs['orderBy'] }
        : { orderBy?: parametersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, parametersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParametersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the parameters model
   */
  readonly fields: parametersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for parameters.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__parametersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the parameters model
   */
  interface parametersFieldRefs {
    readonly id: FieldRef<"parameters", 'String'>
    readonly key: FieldRef<"parameters", 'String'>
    readonly name: FieldRef<"parameters", 'String'>
    readonly value: FieldRef<"parameters", 'String'>
    readonly createdat: FieldRef<"parameters", 'DateTime'>
    readonly status: FieldRef<"parameters", 'Int'>
    readonly userId: FieldRef<"parameters", 'String'>
  }
    

  // Custom InputTypes
  /**
   * parameters findUnique
   */
  export type parametersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parameters
     */
    select?: parametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parameters
     */
    omit?: parametersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parametersInclude<ExtArgs> | null
    /**
     * Filter, which parameters to fetch.
     */
    where: parametersWhereUniqueInput
  }

  /**
   * parameters findUniqueOrThrow
   */
  export type parametersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parameters
     */
    select?: parametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parameters
     */
    omit?: parametersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parametersInclude<ExtArgs> | null
    /**
     * Filter, which parameters to fetch.
     */
    where: parametersWhereUniqueInput
  }

  /**
   * parameters findFirst
   */
  export type parametersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parameters
     */
    select?: parametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parameters
     */
    omit?: parametersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parametersInclude<ExtArgs> | null
    /**
     * Filter, which parameters to fetch.
     */
    where?: parametersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parameters to fetch.
     */
    orderBy?: parametersOrderByWithRelationInput | parametersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parameters.
     */
    cursor?: parametersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parameters.
     */
    distinct?: ParametersScalarFieldEnum | ParametersScalarFieldEnum[]
  }

  /**
   * parameters findFirstOrThrow
   */
  export type parametersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parameters
     */
    select?: parametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parameters
     */
    omit?: parametersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parametersInclude<ExtArgs> | null
    /**
     * Filter, which parameters to fetch.
     */
    where?: parametersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parameters to fetch.
     */
    orderBy?: parametersOrderByWithRelationInput | parametersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parameters.
     */
    cursor?: parametersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parameters.
     */
    distinct?: ParametersScalarFieldEnum | ParametersScalarFieldEnum[]
  }

  /**
   * parameters findMany
   */
  export type parametersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parameters
     */
    select?: parametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parameters
     */
    omit?: parametersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parametersInclude<ExtArgs> | null
    /**
     * Filter, which parameters to fetch.
     */
    where?: parametersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parameters to fetch.
     */
    orderBy?: parametersOrderByWithRelationInput | parametersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing parameters.
     */
    cursor?: parametersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parameters.
     */
    skip?: number
    distinct?: ParametersScalarFieldEnum | ParametersScalarFieldEnum[]
  }

  /**
   * parameters create
   */
  export type parametersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parameters
     */
    select?: parametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parameters
     */
    omit?: parametersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parametersInclude<ExtArgs> | null
    /**
     * The data needed to create a parameters.
     */
    data: XOR<parametersCreateInput, parametersUncheckedCreateInput>
  }

  /**
   * parameters createMany
   */
  export type parametersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many parameters.
     */
    data: parametersCreateManyInput | parametersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * parameters createManyAndReturn
   */
  export type parametersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parameters
     */
    select?: parametersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the parameters
     */
    omit?: parametersOmit<ExtArgs> | null
    /**
     * The data used to create many parameters.
     */
    data: parametersCreateManyInput | parametersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parametersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * parameters update
   */
  export type parametersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parameters
     */
    select?: parametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parameters
     */
    omit?: parametersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parametersInclude<ExtArgs> | null
    /**
     * The data needed to update a parameters.
     */
    data: XOR<parametersUpdateInput, parametersUncheckedUpdateInput>
    /**
     * Choose, which parameters to update.
     */
    where: parametersWhereUniqueInput
  }

  /**
   * parameters updateMany
   */
  export type parametersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update parameters.
     */
    data: XOR<parametersUpdateManyMutationInput, parametersUncheckedUpdateManyInput>
    /**
     * Filter which parameters to update
     */
    where?: parametersWhereInput
    /**
     * Limit how many parameters to update.
     */
    limit?: number
  }

  /**
   * parameters updateManyAndReturn
   */
  export type parametersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parameters
     */
    select?: parametersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the parameters
     */
    omit?: parametersOmit<ExtArgs> | null
    /**
     * The data used to update parameters.
     */
    data: XOR<parametersUpdateManyMutationInput, parametersUncheckedUpdateManyInput>
    /**
     * Filter which parameters to update
     */
    where?: parametersWhereInput
    /**
     * Limit how many parameters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parametersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * parameters upsert
   */
  export type parametersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parameters
     */
    select?: parametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parameters
     */
    omit?: parametersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parametersInclude<ExtArgs> | null
    /**
     * The filter to search for the parameters to update in case it exists.
     */
    where: parametersWhereUniqueInput
    /**
     * In case the parameters found by the `where` argument doesn't exist, create a new parameters with this data.
     */
    create: XOR<parametersCreateInput, parametersUncheckedCreateInput>
    /**
     * In case the parameters was found with the provided `where` argument, update it with this data.
     */
    update: XOR<parametersUpdateInput, parametersUncheckedUpdateInput>
  }

  /**
   * parameters delete
   */
  export type parametersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parameters
     */
    select?: parametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parameters
     */
    omit?: parametersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parametersInclude<ExtArgs> | null
    /**
     * Filter which parameters to delete.
     */
    where: parametersWhereUniqueInput
  }

  /**
   * parameters deleteMany
   */
  export type parametersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which parameters to delete
     */
    where?: parametersWhereInput
    /**
     * Limit how many parameters to delete.
     */
    limit?: number
  }

  /**
   * parameters without action
   */
  export type parametersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parameters
     */
    select?: parametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parameters
     */
    omit?: parametersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parametersInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ApiclientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    key: 'key',
    secret: 'secret',
    type: 'type',
    createdat: 'createdat',
    createdby: 'createdby',
    updatedat: 'updatedat',
    updatedby: 'updatedby',
    isactive: 'isactive'
  };

  export type ApiclientScalarFieldEnum = (typeof ApiclientScalarFieldEnum)[keyof typeof ApiclientScalarFieldEnum]


  export const RefreshtokenScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    token: 'token',
    createdat: 'createdat',
    updatedat: 'updatedat',
    expiresat: 'expiresat'
  };

  export type RefreshtokenScalarFieldEnum = (typeof RefreshtokenScalarFieldEnum)[keyof typeof RefreshtokenScalarFieldEnum]


  export const RevokedtokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    date: 'date'
  };

  export type RevokedtokenScalarFieldEnum = (typeof RevokedtokenScalarFieldEnum)[keyof typeof RevokedtokenScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdby: 'createdby',
    createdat: 'createdat',
    updatedby: 'updatedby',
    updatedat: 'updatedat',
    issystemrole: 'issystemrole'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    touserid: 'touserid',
    message: 'message',
    url: 'url',
    createdby: 'createdby',
    createdat: 'createdat',
    readedat: 'readedat'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    value: 'value',
    group: 'group',
    description: 'description',
    createdby: 'createdby',
    createdat: 'createdat',
    updatedby: 'updatedby',
    updatedat: 'updatedat'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const RolepermissionScalarFieldEnum: {
    id: 'id',
    roleid: 'roleid',
    permissionid: 'permissionid',
    createdat: 'createdat',
    createdby: 'createdby',
    updatedby: 'updatedby',
    updatedat: 'updatedat'
  };

  export type RolepermissionScalarFieldEnum = (typeof RolepermissionScalarFieldEnum)[keyof typeof RolepermissionScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    useragent: 'useragent',
    ipaddress: 'ipaddress',
    userid: 'userid',
    createdat: 'createdat'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const EntranceScalarFieldEnum: {
    id: 'id',
    type: 'type',
    useragent: 'useragent',
    ipaddress: 'ipaddress',
    userid: 'userid',
    createdat: 'createdat'
  };

  export type EntranceScalarFieldEnum = (typeof EntranceScalarFieldEnum)[keyof typeof EntranceScalarFieldEnum]


  export const UserpermissionScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    permissionid: 'permissionid',
    createdby: 'createdby',
    createdat: 'createdat',
    updatedby: 'updatedby',
    updatedat: 'updatedat'
  };

  export type UserpermissionScalarFieldEnum = (typeof UserpermissionScalarFieldEnum)[keyof typeof UserpermissionScalarFieldEnum]


  export const UserroleScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    roleid: 'roleid',
    createdby: 'createdby',
    createdat: 'createdat',
    updatedby: 'updatedby',
    updatedat: 'updatedat'
  };

  export type UserroleScalarFieldEnum = (typeof UserroleScalarFieldEnum)[keyof typeof UserroleScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstname: 'firstname',
    lastname: 'lastname',
    email: 'email',
    planId: 'planId',
    password: 'password',
    companyName: 'companyName',
    companyLogoUrl: 'companyLogoUrl',
    taxId: 'taxId',
    address: 'address',
    phone: 'phone',
    createdat: 'createdat',
    createdby: 'createdby',
    updatedat: 'updatedat',
    updatedby: 'updatedby',
    status: 'status'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    currency: 'currency',
    interval: 'interval',
    description: 'description',
    stripePriceId: 'stripePriceId',
    stripeProductId: 'stripeProductId',
    createdat: 'createdat'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    planId: 'planId',
    stripeId: 'stripeId',
    status: 'status',
    startedat: 'startedat',
    endedat: 'endedat',
    canceledat: 'canceledat'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    email: 'email',
    createdat: 'createdat'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    amount: 'amount',
    userId: 'userId',
    customerId: 'customerId',
    createdat: 'createdat',
    status: 'status'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    currency: 'currency',
    invoiceId: 'invoiceId',
    stripeId: 'stripeId',
    status: 'status',
    createdat: 'createdat'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const ParametersScalarFieldEnum: {
    id: 'id',
    key: 'key',
    name: 'name',
    value: 'value',
    createdat: 'createdat',
    status: 'status',
    userId: 'userId'
  };

  export type ParametersScalarFieldEnum = (typeof ParametersScalarFieldEnum)[keyof typeof ParametersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type apiclientWhereInput = {
    AND?: apiclientWhereInput | apiclientWhereInput[]
    OR?: apiclientWhereInput[]
    NOT?: apiclientWhereInput | apiclientWhereInput[]
    id?: StringFilter<"apiclient"> | string
    name?: StringFilter<"apiclient"> | string
    key?: StringFilter<"apiclient"> | string
    secret?: StringFilter<"apiclient"> | string
    type?: IntFilter<"apiclient"> | number
    createdat?: DateTimeFilter<"apiclient"> | Date | string
    createdby?: StringFilter<"apiclient"> | string
    updatedat?: DateTimeNullableFilter<"apiclient"> | Date | string | null
    updatedby?: StringNullableFilter<"apiclient"> | string | null
    isactive?: BoolFilter<"apiclient"> | boolean
    createduser?: XOR<UserScalarRelationFilter, userWhereInput>
    updateduser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type apiclientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    secret?: SortOrder
    type?: SortOrder
    createdat?: SortOrder
    createdby?: SortOrder
    updatedat?: SortOrderInput | SortOrder
    updatedby?: SortOrderInput | SortOrder
    isactive?: SortOrder
    createduser?: userOrderByWithRelationInput
    updateduser?: userOrderByWithRelationInput
  }

  export type apiclientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    secret?: string
    AND?: apiclientWhereInput | apiclientWhereInput[]
    OR?: apiclientWhereInput[]
    NOT?: apiclientWhereInput | apiclientWhereInput[]
    name?: StringFilter<"apiclient"> | string
    type?: IntFilter<"apiclient"> | number
    createdat?: DateTimeFilter<"apiclient"> | Date | string
    createdby?: StringFilter<"apiclient"> | string
    updatedat?: DateTimeNullableFilter<"apiclient"> | Date | string | null
    updatedby?: StringNullableFilter<"apiclient"> | string | null
    isactive?: BoolFilter<"apiclient"> | boolean
    createduser?: XOR<UserScalarRelationFilter, userWhereInput>
    updateduser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id" | "key" | "secret">

  export type apiclientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    secret?: SortOrder
    type?: SortOrder
    createdat?: SortOrder
    createdby?: SortOrder
    updatedat?: SortOrderInput | SortOrder
    updatedby?: SortOrderInput | SortOrder
    isactive?: SortOrder
    _count?: apiclientCountOrderByAggregateInput
    _avg?: apiclientAvgOrderByAggregateInput
    _max?: apiclientMaxOrderByAggregateInput
    _min?: apiclientMinOrderByAggregateInput
    _sum?: apiclientSumOrderByAggregateInput
  }

  export type apiclientScalarWhereWithAggregatesInput = {
    AND?: apiclientScalarWhereWithAggregatesInput | apiclientScalarWhereWithAggregatesInput[]
    OR?: apiclientScalarWhereWithAggregatesInput[]
    NOT?: apiclientScalarWhereWithAggregatesInput | apiclientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"apiclient"> | string
    name?: StringWithAggregatesFilter<"apiclient"> | string
    key?: StringWithAggregatesFilter<"apiclient"> | string
    secret?: StringWithAggregatesFilter<"apiclient"> | string
    type?: IntWithAggregatesFilter<"apiclient"> | number
    createdat?: DateTimeWithAggregatesFilter<"apiclient"> | Date | string
    createdby?: StringWithAggregatesFilter<"apiclient"> | string
    updatedat?: DateTimeNullableWithAggregatesFilter<"apiclient"> | Date | string | null
    updatedby?: StringNullableWithAggregatesFilter<"apiclient"> | string | null
    isactive?: BoolWithAggregatesFilter<"apiclient"> | boolean
  }

  export type refreshtokenWhereInput = {
    AND?: refreshtokenWhereInput | refreshtokenWhereInput[]
    OR?: refreshtokenWhereInput[]
    NOT?: refreshtokenWhereInput | refreshtokenWhereInput[]
    id?: StringFilter<"refreshtoken"> | string
    userid?: StringFilter<"refreshtoken"> | string
    token?: StringFilter<"refreshtoken"> | string
    createdat?: DateTimeFilter<"refreshtoken"> | Date | string
    updatedat?: DateTimeNullableFilter<"refreshtoken"> | Date | string | null
    expiresat?: DateTimeNullableFilter<"refreshtoken"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type refreshtokenOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrder
    token?: SortOrder
    createdat?: SortOrder
    updatedat?: SortOrderInput | SortOrder
    expiresat?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type refreshtokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: refreshtokenWhereInput | refreshtokenWhereInput[]
    OR?: refreshtokenWhereInput[]
    NOT?: refreshtokenWhereInput | refreshtokenWhereInput[]
    userid?: StringFilter<"refreshtoken"> | string
    token?: StringFilter<"refreshtoken"> | string
    createdat?: DateTimeFilter<"refreshtoken"> | Date | string
    updatedat?: DateTimeNullableFilter<"refreshtoken"> | Date | string | null
    expiresat?: DateTimeNullableFilter<"refreshtoken"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type refreshtokenOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrder
    token?: SortOrder
    createdat?: SortOrder
    updatedat?: SortOrderInput | SortOrder
    expiresat?: SortOrderInput | SortOrder
    _count?: refreshtokenCountOrderByAggregateInput
    _max?: refreshtokenMaxOrderByAggregateInput
    _min?: refreshtokenMinOrderByAggregateInput
  }

  export type refreshtokenScalarWhereWithAggregatesInput = {
    AND?: refreshtokenScalarWhereWithAggregatesInput | refreshtokenScalarWhereWithAggregatesInput[]
    OR?: refreshtokenScalarWhereWithAggregatesInput[]
    NOT?: refreshtokenScalarWhereWithAggregatesInput | refreshtokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"refreshtoken"> | string
    userid?: StringWithAggregatesFilter<"refreshtoken"> | string
    token?: StringWithAggregatesFilter<"refreshtoken"> | string
    createdat?: DateTimeWithAggregatesFilter<"refreshtoken"> | Date | string
    updatedat?: DateTimeNullableWithAggregatesFilter<"refreshtoken"> | Date | string | null
    expiresat?: DateTimeNullableWithAggregatesFilter<"refreshtoken"> | Date | string | null
  }

  export type revokedtokenWhereInput = {
    AND?: revokedtokenWhereInput | revokedtokenWhereInput[]
    OR?: revokedtokenWhereInput[]
    NOT?: revokedtokenWhereInput | revokedtokenWhereInput[]
    id?: StringFilter<"revokedtoken"> | string
    token?: StringFilter<"revokedtoken"> | string
    date?: DateTimeFilter<"revokedtoken"> | Date | string
  }

  export type revokedtokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    date?: SortOrder
  }

  export type revokedtokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: revokedtokenWhereInput | revokedtokenWhereInput[]
    OR?: revokedtokenWhereInput[]
    NOT?: revokedtokenWhereInput | revokedtokenWhereInput[]
    date?: DateTimeFilter<"revokedtoken"> | Date | string
  }, "id" | "token">

  export type revokedtokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    date?: SortOrder
    _count?: revokedtokenCountOrderByAggregateInput
    _max?: revokedtokenMaxOrderByAggregateInput
    _min?: revokedtokenMinOrderByAggregateInput
  }

  export type revokedtokenScalarWhereWithAggregatesInput = {
    AND?: revokedtokenScalarWhereWithAggregatesInput | revokedtokenScalarWhereWithAggregatesInput[]
    OR?: revokedtokenScalarWhereWithAggregatesInput[]
    NOT?: revokedtokenScalarWhereWithAggregatesInput | revokedtokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"revokedtoken"> | string
    token?: StringWithAggregatesFilter<"revokedtoken"> | string
    date?: DateTimeWithAggregatesFilter<"revokedtoken"> | Date | string
  }

  export type roleWhereInput = {
    AND?: roleWhereInput | roleWhereInput[]
    OR?: roleWhereInput[]
    NOT?: roleWhereInput | roleWhereInput[]
    id?: StringFilter<"role"> | string
    name?: StringFilter<"role"> | string
    createdby?: StringFilter<"role"> | string
    createdat?: DateTimeFilter<"role"> | Date | string
    updatedby?: StringNullableFilter<"role"> | string | null
    updatedat?: DateTimeNullableFilter<"role"> | Date | string | null
    issystemrole?: BoolFilter<"role"> | boolean
    createduser?: XOR<UserScalarRelationFilter, userWhereInput>
    updateduser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    rolepermissions?: RolepermissionListRelationFilter
    userroles?: UserroleListRelationFilter
  }

  export type roleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdby?: SortOrder
    createdat?: SortOrder
    updatedby?: SortOrderInput | SortOrder
    updatedat?: SortOrderInput | SortOrder
    issystemrole?: SortOrder
    createduser?: userOrderByWithRelationInput
    updateduser?: userOrderByWithRelationInput
    rolepermissions?: rolepermissionOrderByRelationAggregateInput
    userroles?: userroleOrderByRelationAggregateInput
  }

  export type roleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: roleWhereInput | roleWhereInput[]
    OR?: roleWhereInput[]
    NOT?: roleWhereInput | roleWhereInput[]
    name?: StringFilter<"role"> | string
    createdby?: StringFilter<"role"> | string
    createdat?: DateTimeFilter<"role"> | Date | string
    updatedby?: StringNullableFilter<"role"> | string | null
    updatedat?: DateTimeNullableFilter<"role"> | Date | string | null
    issystemrole?: BoolFilter<"role"> | boolean
    createduser?: XOR<UserScalarRelationFilter, userWhereInput>
    updateduser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    rolepermissions?: RolepermissionListRelationFilter
    userroles?: UserroleListRelationFilter
  }, "id">

  export type roleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdby?: SortOrder
    createdat?: SortOrder
    updatedby?: SortOrderInput | SortOrder
    updatedat?: SortOrderInput | SortOrder
    issystemrole?: SortOrder
    _count?: roleCountOrderByAggregateInput
    _max?: roleMaxOrderByAggregateInput
    _min?: roleMinOrderByAggregateInput
  }

  export type roleScalarWhereWithAggregatesInput = {
    AND?: roleScalarWhereWithAggregatesInput | roleScalarWhereWithAggregatesInput[]
    OR?: roleScalarWhereWithAggregatesInput[]
    NOT?: roleScalarWhereWithAggregatesInput | roleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"role"> | string
    name?: StringWithAggregatesFilter<"role"> | string
    createdby?: StringWithAggregatesFilter<"role"> | string
    createdat?: DateTimeWithAggregatesFilter<"role"> | Date | string
    updatedby?: StringNullableWithAggregatesFilter<"role"> | string | null
    updatedat?: DateTimeNullableWithAggregatesFilter<"role"> | Date | string | null
    issystemrole?: BoolWithAggregatesFilter<"role"> | boolean
  }

  export type notificationWhereInput = {
    AND?: notificationWhereInput | notificationWhereInput[]
    OR?: notificationWhereInput[]
    NOT?: notificationWhereInput | notificationWhereInput[]
    id?: StringFilter<"notification"> | string
    touserid?: StringFilter<"notification"> | string
    message?: StringFilter<"notification"> | string
    url?: StringFilter<"notification"> | string
    createdby?: StringFilter<"notification"> | string
    createdat?: DateTimeFilter<"notification"> | Date | string
    readedat?: DateTimeNullableFilter<"notification"> | Date | string | null
    to?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type notificationOrderByWithRelationInput = {
    id?: SortOrder
    touserid?: SortOrder
    message?: SortOrder
    url?: SortOrder
    createdby?: SortOrder
    createdat?: SortOrder
    readedat?: SortOrderInput | SortOrder
    to?: userOrderByWithRelationInput
  }

  export type notificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: notificationWhereInput | notificationWhereInput[]
    OR?: notificationWhereInput[]
    NOT?: notificationWhereInput | notificationWhereInput[]
    touserid?: StringFilter<"notification"> | string
    message?: StringFilter<"notification"> | string
    url?: StringFilter<"notification"> | string
    createdby?: StringFilter<"notification"> | string
    createdat?: DateTimeFilter<"notification"> | Date | string
    readedat?: DateTimeNullableFilter<"notification"> | Date | string | null
    to?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type notificationOrderByWithAggregationInput = {
    id?: SortOrder
    touserid?: SortOrder
    message?: SortOrder
    url?: SortOrder
    createdby?: SortOrder
    createdat?: SortOrder
    readedat?: SortOrderInput | SortOrder
    _count?: notificationCountOrderByAggregateInput
    _max?: notificationMaxOrderByAggregateInput
    _min?: notificationMinOrderByAggregateInput
  }

  export type notificationScalarWhereWithAggregatesInput = {
    AND?: notificationScalarWhereWithAggregatesInput | notificationScalarWhereWithAggregatesInput[]
    OR?: notificationScalarWhereWithAggregatesInput[]
    NOT?: notificationScalarWhereWithAggregatesInput | notificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"notification"> | string
    touserid?: StringWithAggregatesFilter<"notification"> | string
    message?: StringWithAggregatesFilter<"notification"> | string
    url?: StringWithAggregatesFilter<"notification"> | string
    createdby?: StringWithAggregatesFilter<"notification"> | string
    createdat?: DateTimeWithAggregatesFilter<"notification"> | Date | string
    readedat?: DateTimeNullableWithAggregatesFilter<"notification"> | Date | string | null
  }

  export type permissionWhereInput = {
    AND?: permissionWhereInput | permissionWhereInput[]
    OR?: permissionWhereInput[]
    NOT?: permissionWhereInput | permissionWhereInput[]
    id?: StringFilter<"permission"> | string
    name?: StringFilter<"permission"> | string
    value?: StringFilter<"permission"> | string
    group?: StringFilter<"permission"> | string
    description?: StringFilter<"permission"> | string
    createdby?: StringFilter<"permission"> | string
    createdat?: DateTimeFilter<"permission"> | Date | string
    updatedby?: StringNullableFilter<"permission"> | string | null
    updatedat?: DateTimeNullableFilter<"permission"> | Date | string | null
    createduser?: XOR<UserScalarRelationFilter, userWhereInput>
    updateduser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    rolepermissions?: RolepermissionListRelationFilter
    userpermissions?: UserpermissionListRelationFilter
  }

  export type permissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    group?: SortOrder
    description?: SortOrder
    createdby?: SortOrder
    createdat?: SortOrder
    updatedby?: SortOrderInput | SortOrder
    updatedat?: SortOrderInput | SortOrder
    createduser?: userOrderByWithRelationInput
    updateduser?: userOrderByWithRelationInput
    rolepermissions?: rolepermissionOrderByRelationAggregateInput
    userpermissions?: userpermissionOrderByRelationAggregateInput
  }

  export type permissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    value?: string
    AND?: permissionWhereInput | permissionWhereInput[]
    OR?: permissionWhereInput[]
    NOT?: permissionWhereInput | permissionWhereInput[]
    name?: StringFilter<"permission"> | string
    group?: StringFilter<"permission"> | string
    description?: StringFilter<"permission"> | string
    createdby?: StringFilter<"permission"> | string
    createdat?: DateTimeFilter<"permission"> | Date | string
    updatedby?: StringNullableFilter<"permission"> | string | null
    updatedat?: DateTimeNullableFilter<"permission"> | Date | string | null
    createduser?: XOR<UserScalarRelationFilter, userWhereInput>
    updateduser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    rolepermissions?: RolepermissionListRelationFilter
    userpermissions?: UserpermissionListRelationFilter
  }, "id" | "value">

  export type permissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    group?: SortOrder
    description?: SortOrder
    createdby?: SortOrder
    createdat?: SortOrder
    updatedby?: SortOrderInput | SortOrder
    updatedat?: SortOrderInput | SortOrder
    _count?: permissionCountOrderByAggregateInput
    _max?: permissionMaxOrderByAggregateInput
    _min?: permissionMinOrderByAggregateInput
  }

  export type permissionScalarWhereWithAggregatesInput = {
    AND?: permissionScalarWhereWithAggregatesInput | permissionScalarWhereWithAggregatesInput[]
    OR?: permissionScalarWhereWithAggregatesInput[]
    NOT?: permissionScalarWhereWithAggregatesInput | permissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"permission"> | string
    name?: StringWithAggregatesFilter<"permission"> | string
    value?: StringWithAggregatesFilter<"permission"> | string
    group?: StringWithAggregatesFilter<"permission"> | string
    description?: StringWithAggregatesFilter<"permission"> | string
    createdby?: StringWithAggregatesFilter<"permission"> | string
    createdat?: DateTimeWithAggregatesFilter<"permission"> | Date | string
    updatedby?: StringNullableWithAggregatesFilter<"permission"> | string | null
    updatedat?: DateTimeNullableWithAggregatesFilter<"permission"> | Date | string | null
  }

  export type rolepermissionWhereInput = {
    AND?: rolepermissionWhereInput | rolepermissionWhereInput[]
    OR?: rolepermissionWhereInput[]
    NOT?: rolepermissionWhereInput | rolepermissionWhereInput[]
    id?: StringFilter<"rolepermission"> | string
    roleid?: StringFilter<"rolepermission"> | string
    permissionid?: StringFilter<"rolepermission"> | string
    createdat?: DateTimeFilter<"rolepermission"> | Date | string
    createdby?: StringFilter<"rolepermission"> | string
    updatedby?: StringNullableFilter<"rolepermission"> | string | null
    updatedat?: DateTimeNullableFilter<"rolepermission"> | Date | string | null
    createduser?: XOR<UserScalarRelationFilter, userWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, permissionWhereInput>
    role?: XOR<RoleScalarRelationFilter, roleWhereInput>
    updateduser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type rolepermissionOrderByWithRelationInput = {
    id?: SortOrder
    roleid?: SortOrder
    permissionid?: SortOrder
    createdat?: SortOrder
    createdby?: SortOrder
    updatedby?: SortOrderInput | SortOrder
    updatedat?: SortOrderInput | SortOrder
    createduser?: userOrderByWithRelationInput
    permission?: permissionOrderByWithRelationInput
    role?: roleOrderByWithRelationInput
    updateduser?: userOrderByWithRelationInput
  }

  export type rolepermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: rolepermissionWhereInput | rolepermissionWhereInput[]
    OR?: rolepermissionWhereInput[]
    NOT?: rolepermissionWhereInput | rolepermissionWhereInput[]
    roleid?: StringFilter<"rolepermission"> | string
    permissionid?: StringFilter<"rolepermission"> | string
    createdat?: DateTimeFilter<"rolepermission"> | Date | string
    createdby?: StringFilter<"rolepermission"> | string
    updatedby?: StringNullableFilter<"rolepermission"> | string | null
    updatedat?: DateTimeNullableFilter<"rolepermission"> | Date | string | null
    createduser?: XOR<UserScalarRelationFilter, userWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, permissionWhereInput>
    role?: XOR<RoleScalarRelationFilter, roleWhereInput>
    updateduser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type rolepermissionOrderByWithAggregationInput = {
    id?: SortOrder
    roleid?: SortOrder
    permissionid?: SortOrder
    createdat?: SortOrder
    createdby?: SortOrder
    updatedby?: SortOrderInput | SortOrder
    updatedat?: SortOrderInput | SortOrder
    _count?: rolepermissionCountOrderByAggregateInput
    _max?: rolepermissionMaxOrderByAggregateInput
    _min?: rolepermissionMinOrderByAggregateInput
  }

  export type rolepermissionScalarWhereWithAggregatesInput = {
    AND?: rolepermissionScalarWhereWithAggregatesInput | rolepermissionScalarWhereWithAggregatesInput[]
    OR?: rolepermissionScalarWhereWithAggregatesInput[]
    NOT?: rolepermissionScalarWhereWithAggregatesInput | rolepermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"rolepermission"> | string
    roleid?: StringWithAggregatesFilter<"rolepermission"> | string
    permissionid?: StringWithAggregatesFilter<"rolepermission"> | string
    createdat?: DateTimeWithAggregatesFilter<"rolepermission"> | Date | string
    createdby?: StringWithAggregatesFilter<"rolepermission"> | string
    updatedby?: StringNullableWithAggregatesFilter<"rolepermission"> | string | null
    updatedat?: DateTimeNullableWithAggregatesFilter<"rolepermission"> | Date | string | null
  }

  export type transactionWhereInput = {
    AND?: transactionWhereInput | transactionWhereInput[]
    OR?: transactionWhereInput[]
    NOT?: transactionWhereInput | transactionWhereInput[]
    id?: StringFilter<"transaction"> | string
    type?: IntFilter<"transaction"> | number
    useragent?: StringFilter<"transaction"> | string
    ipaddress?: StringFilter<"transaction"> | string
    userid?: StringFilter<"transaction"> | string
    createdat?: DateTimeFilter<"transaction"> | Date | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type transactionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    useragent?: SortOrder
    ipaddress?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type transactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: transactionWhereInput | transactionWhereInput[]
    OR?: transactionWhereInput[]
    NOT?: transactionWhereInput | transactionWhereInput[]
    type?: IntFilter<"transaction"> | number
    useragent?: StringFilter<"transaction"> | string
    ipaddress?: StringFilter<"transaction"> | string
    userid?: StringFilter<"transaction"> | string
    createdat?: DateTimeFilter<"transaction"> | Date | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type transactionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    useragent?: SortOrder
    ipaddress?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
    _count?: transactionCountOrderByAggregateInput
    _avg?: transactionAvgOrderByAggregateInput
    _max?: transactionMaxOrderByAggregateInput
    _min?: transactionMinOrderByAggregateInput
    _sum?: transactionSumOrderByAggregateInput
  }

  export type transactionScalarWhereWithAggregatesInput = {
    AND?: transactionScalarWhereWithAggregatesInput | transactionScalarWhereWithAggregatesInput[]
    OR?: transactionScalarWhereWithAggregatesInput[]
    NOT?: transactionScalarWhereWithAggregatesInput | transactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"transaction"> | string
    type?: IntWithAggregatesFilter<"transaction"> | number
    useragent?: StringWithAggregatesFilter<"transaction"> | string
    ipaddress?: StringWithAggregatesFilter<"transaction"> | string
    userid?: StringWithAggregatesFilter<"transaction"> | string
    createdat?: DateTimeWithAggregatesFilter<"transaction"> | Date | string
  }

  export type entranceWhereInput = {
    AND?: entranceWhereInput | entranceWhereInput[]
    OR?: entranceWhereInput[]
    NOT?: entranceWhereInput | entranceWhereInput[]
    id?: StringFilter<"entrance"> | string
    type?: StringFilter<"entrance"> | string
    useragent?: StringFilter<"entrance"> | string
    ipaddress?: StringFilter<"entrance"> | string
    userid?: StringFilter<"entrance"> | string
    createdat?: DateTimeFilter<"entrance"> | Date | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type entranceOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    useragent?: SortOrder
    ipaddress?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type entranceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: entranceWhereInput | entranceWhereInput[]
    OR?: entranceWhereInput[]
    NOT?: entranceWhereInput | entranceWhereInput[]
    type?: StringFilter<"entrance"> | string
    useragent?: StringFilter<"entrance"> | string
    ipaddress?: StringFilter<"entrance"> | string
    userid?: StringFilter<"entrance"> | string
    createdat?: DateTimeFilter<"entrance"> | Date | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type entranceOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    useragent?: SortOrder
    ipaddress?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
    _count?: entranceCountOrderByAggregateInput
    _max?: entranceMaxOrderByAggregateInput
    _min?: entranceMinOrderByAggregateInput
  }

  export type entranceScalarWhereWithAggregatesInput = {
    AND?: entranceScalarWhereWithAggregatesInput | entranceScalarWhereWithAggregatesInput[]
    OR?: entranceScalarWhereWithAggregatesInput[]
    NOT?: entranceScalarWhereWithAggregatesInput | entranceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"entrance"> | string
    type?: StringWithAggregatesFilter<"entrance"> | string
    useragent?: StringWithAggregatesFilter<"entrance"> | string
    ipaddress?: StringWithAggregatesFilter<"entrance"> | string
    userid?: StringWithAggregatesFilter<"entrance"> | string
    createdat?: DateTimeWithAggregatesFilter<"entrance"> | Date | string
  }

  export type userpermissionWhereInput = {
    AND?: userpermissionWhereInput | userpermissionWhereInput[]
    OR?: userpermissionWhereInput[]
    NOT?: userpermissionWhereInput | userpermissionWhereInput[]
    id?: StringFilter<"userpermission"> | string
    userid?: StringFilter<"userpermission"> | string
    permissionid?: StringFilter<"userpermission"> | string
    createdby?: StringFilter<"userpermission"> | string
    createdat?: DateTimeFilter<"userpermission"> | Date | string
    updatedby?: StringNullableFilter<"userpermission"> | string | null
    updatedat?: DateTimeNullableFilter<"userpermission"> | Date | string | null
    createduser?: XOR<UserScalarRelationFilter, userWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, permissionWhereInput>
    updateduser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type userpermissionOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrder
    permissionid?: SortOrder
    createdby?: SortOrder
    createdat?: SortOrder
    updatedby?: SortOrderInput | SortOrder
    updatedat?: SortOrderInput | SortOrder
    createduser?: userOrderByWithRelationInput
    permission?: permissionOrderByWithRelationInput
    updateduser?: userOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type userpermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: userpermissionWhereInput | userpermissionWhereInput[]
    OR?: userpermissionWhereInput[]
    NOT?: userpermissionWhereInput | userpermissionWhereInput[]
    userid?: StringFilter<"userpermission"> | string
    permissionid?: StringFilter<"userpermission"> | string
    createdby?: StringFilter<"userpermission"> | string
    createdat?: DateTimeFilter<"userpermission"> | Date | string
    updatedby?: StringNullableFilter<"userpermission"> | string | null
    updatedat?: DateTimeNullableFilter<"userpermission"> | Date | string | null
    createduser?: XOR<UserScalarRelationFilter, userWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, permissionWhereInput>
    updateduser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type userpermissionOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrder
    permissionid?: SortOrder
    createdby?: SortOrder
    createdat?: SortOrder
    updatedby?: SortOrderInput | SortOrder
    updatedat?: SortOrderInput | SortOrder
    _count?: userpermissionCountOrderByAggregateInput
    _max?: userpermissionMaxOrderByAggregateInput
    _min?: userpermissionMinOrderByAggregateInput
  }

  export type userpermissionScalarWhereWithAggregatesInput = {
    AND?: userpermissionScalarWhereWithAggregatesInput | userpermissionScalarWhereWithAggregatesInput[]
    OR?: userpermissionScalarWhereWithAggregatesInput[]
    NOT?: userpermissionScalarWhereWithAggregatesInput | userpermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"userpermission"> | string
    userid?: StringWithAggregatesFilter<"userpermission"> | string
    permissionid?: StringWithAggregatesFilter<"userpermission"> | string
    createdby?: StringWithAggregatesFilter<"userpermission"> | string
    createdat?: DateTimeWithAggregatesFilter<"userpermission"> | Date | string
    updatedby?: StringNullableWithAggregatesFilter<"userpermission"> | string | null
    updatedat?: DateTimeNullableWithAggregatesFilter<"userpermission"> | Date | string | null
  }

  export type userroleWhereInput = {
    AND?: userroleWhereInput | userroleWhereInput[]
    OR?: userroleWhereInput[]
    NOT?: userroleWhereInput | userroleWhereInput[]
    id?: StringFilter<"userrole"> | string
    userid?: StringFilter<"userrole"> | string
    roleid?: StringFilter<"userrole"> | string
    createdby?: StringFilter<"userrole"> | string
    createdat?: DateTimeFilter<"userrole"> | Date | string
    updatedby?: StringNullableFilter<"userrole"> | string | null
    updatedat?: DateTimeNullableFilter<"userrole"> | Date | string | null
    createduser?: XOR<UserScalarRelationFilter, userWhereInput>
    role?: XOR<RoleScalarRelationFilter, roleWhereInput>
    updateduser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type userroleOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrder
    roleid?: SortOrder
    createdby?: SortOrder
    createdat?: SortOrder
    updatedby?: SortOrderInput | SortOrder
    updatedat?: SortOrderInput | SortOrder
    createduser?: userOrderByWithRelationInput
    role?: roleOrderByWithRelationInput
    updateduser?: userOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type userroleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: userroleWhereInput | userroleWhereInput[]
    OR?: userroleWhereInput[]
    NOT?: userroleWhereInput | userroleWhereInput[]
    userid?: StringFilter<"userrole"> | string
    roleid?: StringFilter<"userrole"> | string
    createdby?: StringFilter<"userrole"> | string
    createdat?: DateTimeFilter<"userrole"> | Date | string
    updatedby?: StringNullableFilter<"userrole"> | string | null
    updatedat?: DateTimeNullableFilter<"userrole"> | Date | string | null
    createduser?: XOR<UserScalarRelationFilter, userWhereInput>
    role?: XOR<RoleScalarRelationFilter, roleWhereInput>
    updateduser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type userroleOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrder
    roleid?: SortOrder
    createdby?: SortOrder
    createdat?: SortOrder
    updatedby?: SortOrderInput | SortOrder
    updatedat?: SortOrderInput | SortOrder
    _count?: userroleCountOrderByAggregateInput
    _max?: userroleMaxOrderByAggregateInput
    _min?: userroleMinOrderByAggregateInput
  }

  export type userroleScalarWhereWithAggregatesInput = {
    AND?: userroleScalarWhereWithAggregatesInput | userroleScalarWhereWithAggregatesInput[]
    OR?: userroleScalarWhereWithAggregatesInput[]
    NOT?: userroleScalarWhereWithAggregatesInput | userroleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"userrole"> | string
    userid?: StringWithAggregatesFilter<"userrole"> | string
    roleid?: StringWithAggregatesFilter<"userrole"> | string
    createdby?: StringWithAggregatesFilter<"userrole"> | string
    createdat?: DateTimeWithAggregatesFilter<"userrole"> | Date | string
    updatedby?: StringNullableWithAggregatesFilter<"userrole"> | string | null
    updatedat?: DateTimeNullableWithAggregatesFilter<"userrole"> | Date | string | null
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: StringFilter<"user"> | string
    firstname?: StringFilter<"user"> | string
    lastname?: StringFilter<"user"> | string
    email?: StringFilter<"user"> | string
    planId?: StringNullableFilter<"user"> | string | null
    password?: StringFilter<"user"> | string
    companyName?: StringNullableFilter<"user"> | string | null
    companyLogoUrl?: StringNullableFilter<"user"> | string | null
    taxId?: StringNullableFilter<"user"> | string | null
    address?: StringNullableFilter<"user"> | string | null
    phone?: StringNullableFilter<"user"> | string | null
    createdat?: DateTimeFilter<"user"> | Date | string
    createdby?: StringFilter<"user"> | string
    updatedat?: DateTimeNullableFilter<"user"> | Date | string | null
    updatedby?: StringNullableFilter<"user"> | string | null
    status?: BoolFilter<"user"> | boolean
    invoices?: InvoiceListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    customers?: CustomerListRelationFilter
    parameters?: ParametersListRelationFilter
    entrances?: EntranceListRelationFilter
    payments?: PaymentListRelationFilter
    plan?: XOR<PlanNullableScalarRelationFilter, planWhereInput> | null
    transactions?: TransactionListRelationFilter
    notificationuser?: NotificationListRelationFilter
    createdapiclients?: ApiclientListRelationFilter
    updatedapiclients?: ApiclientListRelationFilter
    createdpermissions?: PermissionListRelationFilter
    updatedpermissions?: PermissionListRelationFilter
    refreshtokens?: RefreshtokenListRelationFilter
    createdroles?: RoleListRelationFilter
    updatedroles?: RoleListRelationFilter
    createdrolepermissions?: RolepermissionListRelationFilter
    updatedrolepermissions?: RolepermissionListRelationFilter
    createduser?: XOR<UserScalarRelationFilter, userWhereInput>
    createdusers?: UserListRelationFilter
    updateduser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    updatedusers?: UserListRelationFilter
    createduserpermissions?: UserpermissionListRelationFilter
    updateduserpermissions?: UserpermissionListRelationFilter
    userpermissions?: UserpermissionListRelationFilter
    createduserroles?: UserroleListRelationFilter
    updateduserroles?: UserroleListRelationFilter
    userroles?: UserroleListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    planId?: SortOrderInput | SortOrder
    password?: SortOrder
    companyName?: SortOrderInput | SortOrder
    companyLogoUrl?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    createdat?: SortOrder
    createdby?: SortOrder
    updatedat?: SortOrderInput | SortOrder
    updatedby?: SortOrderInput | SortOrder
    status?: SortOrder
    invoices?: invoiceOrderByRelationAggregateInput
    subscriptions?: subscriptionOrderByRelationAggregateInput
    customers?: customerOrderByRelationAggregateInput
    parameters?: parametersOrderByRelationAggregateInput
    entrances?: entranceOrderByRelationAggregateInput
    payments?: paymentOrderByRelationAggregateInput
    plan?: planOrderByWithRelationInput
    transactions?: transactionOrderByRelationAggregateInput
    notificationuser?: notificationOrderByRelationAggregateInput
    createdapiclients?: apiclientOrderByRelationAggregateInput
    updatedapiclients?: apiclientOrderByRelationAggregateInput
    createdpermissions?: permissionOrderByRelationAggregateInput
    updatedpermissions?: permissionOrderByRelationAggregateInput
    refreshtokens?: refreshtokenOrderByRelationAggregateInput
    createdroles?: roleOrderByRelationAggregateInput
    updatedroles?: roleOrderByRelationAggregateInput
    createdrolepermissions?: rolepermissionOrderByRelationAggregateInput
    updatedrolepermissions?: rolepermissionOrderByRelationAggregateInput
    createduser?: userOrderByWithRelationInput
    createdusers?: userOrderByRelationAggregateInput
    updateduser?: userOrderByWithRelationInput
    updatedusers?: userOrderByRelationAggregateInput
    createduserpermissions?: userpermissionOrderByRelationAggregateInput
    updateduserpermissions?: userpermissionOrderByRelationAggregateInput
    userpermissions?: userpermissionOrderByRelationAggregateInput
    createduserroles?: userroleOrderByRelationAggregateInput
    updateduserroles?: userroleOrderByRelationAggregateInput
    userroles?: userroleOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    firstname?: StringFilter<"user"> | string
    lastname?: StringFilter<"user"> | string
    planId?: StringNullableFilter<"user"> | string | null
    password?: StringFilter<"user"> | string
    companyName?: StringNullableFilter<"user"> | string | null
    companyLogoUrl?: StringNullableFilter<"user"> | string | null
    taxId?: StringNullableFilter<"user"> | string | null
    address?: StringNullableFilter<"user"> | string | null
    phone?: StringNullableFilter<"user"> | string | null
    createdat?: DateTimeFilter<"user"> | Date | string
    createdby?: StringFilter<"user"> | string
    updatedat?: DateTimeNullableFilter<"user"> | Date | string | null
    updatedby?: StringNullableFilter<"user"> | string | null
    status?: BoolFilter<"user"> | boolean
    invoices?: InvoiceListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    customers?: CustomerListRelationFilter
    parameters?: ParametersListRelationFilter
    entrances?: EntranceListRelationFilter
    payments?: PaymentListRelationFilter
    plan?: XOR<PlanNullableScalarRelationFilter, planWhereInput> | null
    transactions?: TransactionListRelationFilter
    notificationuser?: NotificationListRelationFilter
    createdapiclients?: ApiclientListRelationFilter
    updatedapiclients?: ApiclientListRelationFilter
    createdpermissions?: PermissionListRelationFilter
    updatedpermissions?: PermissionListRelationFilter
    refreshtokens?: RefreshtokenListRelationFilter
    createdroles?: RoleListRelationFilter
    updatedroles?: RoleListRelationFilter
    createdrolepermissions?: RolepermissionListRelationFilter
    updatedrolepermissions?: RolepermissionListRelationFilter
    createduser?: XOR<UserScalarRelationFilter, userWhereInput>
    createdusers?: UserListRelationFilter
    updateduser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    updatedusers?: UserListRelationFilter
    createduserpermissions?: UserpermissionListRelationFilter
    updateduserpermissions?: UserpermissionListRelationFilter
    userpermissions?: UserpermissionListRelationFilter
    createduserroles?: UserroleListRelationFilter
    updateduserroles?: UserroleListRelationFilter
    userroles?: UserroleListRelationFilter
  }, "id" | "email">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    planId?: SortOrderInput | SortOrder
    password?: SortOrder
    companyName?: SortOrderInput | SortOrder
    companyLogoUrl?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    createdat?: SortOrder
    createdby?: SortOrder
    updatedat?: SortOrderInput | SortOrder
    updatedby?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: userCountOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user"> | string
    firstname?: StringWithAggregatesFilter<"user"> | string
    lastname?: StringWithAggregatesFilter<"user"> | string
    email?: StringWithAggregatesFilter<"user"> | string
    planId?: StringNullableWithAggregatesFilter<"user"> | string | null
    password?: StringWithAggregatesFilter<"user"> | string
    companyName?: StringNullableWithAggregatesFilter<"user"> | string | null
    companyLogoUrl?: StringNullableWithAggregatesFilter<"user"> | string | null
    taxId?: StringNullableWithAggregatesFilter<"user"> | string | null
    address?: StringNullableWithAggregatesFilter<"user"> | string | null
    phone?: StringNullableWithAggregatesFilter<"user"> | string | null
    createdat?: DateTimeWithAggregatesFilter<"user"> | Date | string
    createdby?: StringWithAggregatesFilter<"user"> | string
    updatedat?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    updatedby?: StringNullableWithAggregatesFilter<"user"> | string | null
    status?: BoolWithAggregatesFilter<"user"> | boolean
  }

  export type planWhereInput = {
    AND?: planWhereInput | planWhereInput[]
    OR?: planWhereInput[]
    NOT?: planWhereInput | planWhereInput[]
    id?: StringFilter<"plan"> | string
    name?: StringFilter<"plan"> | string
    price?: StringFilter<"plan"> | string
    currency?: StringFilter<"plan"> | string
    interval?: StringFilter<"plan"> | string
    description?: StringNullableFilter<"plan"> | string | null
    stripePriceId?: StringNullableFilter<"plan"> | string | null
    stripeProductId?: StringNullableFilter<"plan"> | string | null
    createdat?: DateTimeFilter<"plan"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
    users?: UserListRelationFilter
  }

  export type planOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    description?: SortOrderInput | SortOrder
    stripePriceId?: SortOrderInput | SortOrder
    stripeProductId?: SortOrderInput | SortOrder
    createdat?: SortOrder
    subscriptions?: subscriptionOrderByRelationAggregateInput
    users?: userOrderByRelationAggregateInput
  }

  export type planWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: planWhereInput | planWhereInput[]
    OR?: planWhereInput[]
    NOT?: planWhereInput | planWhereInput[]
    name?: StringFilter<"plan"> | string
    price?: StringFilter<"plan"> | string
    currency?: StringFilter<"plan"> | string
    interval?: StringFilter<"plan"> | string
    description?: StringNullableFilter<"plan"> | string | null
    stripePriceId?: StringNullableFilter<"plan"> | string | null
    stripeProductId?: StringNullableFilter<"plan"> | string | null
    createdat?: DateTimeFilter<"plan"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
    users?: UserListRelationFilter
  }, "id">

  export type planOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    description?: SortOrderInput | SortOrder
    stripePriceId?: SortOrderInput | SortOrder
    stripeProductId?: SortOrderInput | SortOrder
    createdat?: SortOrder
    _count?: planCountOrderByAggregateInput
    _max?: planMaxOrderByAggregateInput
    _min?: planMinOrderByAggregateInput
  }

  export type planScalarWhereWithAggregatesInput = {
    AND?: planScalarWhereWithAggregatesInput | planScalarWhereWithAggregatesInput[]
    OR?: planScalarWhereWithAggregatesInput[]
    NOT?: planScalarWhereWithAggregatesInput | planScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"plan"> | string
    name?: StringWithAggregatesFilter<"plan"> | string
    price?: StringWithAggregatesFilter<"plan"> | string
    currency?: StringWithAggregatesFilter<"plan"> | string
    interval?: StringWithAggregatesFilter<"plan"> | string
    description?: StringNullableWithAggregatesFilter<"plan"> | string | null
    stripePriceId?: StringNullableWithAggregatesFilter<"plan"> | string | null
    stripeProductId?: StringNullableWithAggregatesFilter<"plan"> | string | null
    createdat?: DateTimeWithAggregatesFilter<"plan"> | Date | string
  }

  export type subscriptionWhereInput = {
    AND?: subscriptionWhereInput | subscriptionWhereInput[]
    OR?: subscriptionWhereInput[]
    NOT?: subscriptionWhereInput | subscriptionWhereInput[]
    id?: StringFilter<"subscription"> | string
    userId?: StringFilter<"subscription"> | string
    planId?: StringFilter<"subscription"> | string
    stripeId?: StringNullableFilter<"subscription"> | string | null
    status?: StringFilter<"subscription"> | string
    startedat?: DateTimeFilter<"subscription"> | Date | string
    endedat?: DateTimeNullableFilter<"subscription"> | Date | string | null
    canceledat?: DateTimeNullableFilter<"subscription"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    plan?: XOR<PlanScalarRelationFilter, planWhereInput>
  }

  export type subscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    stripeId?: SortOrderInput | SortOrder
    status?: SortOrder
    startedat?: SortOrder
    endedat?: SortOrderInput | SortOrder
    canceledat?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    plan?: planOrderByWithRelationInput
  }

  export type subscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: subscriptionWhereInput | subscriptionWhereInput[]
    OR?: subscriptionWhereInput[]
    NOT?: subscriptionWhereInput | subscriptionWhereInput[]
    userId?: StringFilter<"subscription"> | string
    planId?: StringFilter<"subscription"> | string
    stripeId?: StringNullableFilter<"subscription"> | string | null
    status?: StringFilter<"subscription"> | string
    startedat?: DateTimeFilter<"subscription"> | Date | string
    endedat?: DateTimeNullableFilter<"subscription"> | Date | string | null
    canceledat?: DateTimeNullableFilter<"subscription"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    plan?: XOR<PlanScalarRelationFilter, planWhereInput>
  }, "id">

  export type subscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    stripeId?: SortOrderInput | SortOrder
    status?: SortOrder
    startedat?: SortOrder
    endedat?: SortOrderInput | SortOrder
    canceledat?: SortOrderInput | SortOrder
    _count?: subscriptionCountOrderByAggregateInput
    _max?: subscriptionMaxOrderByAggregateInput
    _min?: subscriptionMinOrderByAggregateInput
  }

  export type subscriptionScalarWhereWithAggregatesInput = {
    AND?: subscriptionScalarWhereWithAggregatesInput | subscriptionScalarWhereWithAggregatesInput[]
    OR?: subscriptionScalarWhereWithAggregatesInput[]
    NOT?: subscriptionScalarWhereWithAggregatesInput | subscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"subscription"> | string
    userId?: StringWithAggregatesFilter<"subscription"> | string
    planId?: StringWithAggregatesFilter<"subscription"> | string
    stripeId?: StringNullableWithAggregatesFilter<"subscription"> | string | null
    status?: StringWithAggregatesFilter<"subscription"> | string
    startedat?: DateTimeWithAggregatesFilter<"subscription"> | Date | string
    endedat?: DateTimeNullableWithAggregatesFilter<"subscription"> | Date | string | null
    canceledat?: DateTimeNullableWithAggregatesFilter<"subscription"> | Date | string | null
  }

  export type customerWhereInput = {
    AND?: customerWhereInput | customerWhereInput[]
    OR?: customerWhereInput[]
    NOT?: customerWhereInput | customerWhereInput[]
    id?: StringFilter<"customer"> | string
    userId?: StringFilter<"customer"> | string
    name?: StringFilter<"customer"> | string
    email?: StringFilter<"customer"> | string
    createdat?: DateTimeFilter<"customer"> | Date | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    invoices?: InvoiceListRelationFilter
  }

  export type customerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdat?: SortOrder
    user?: userOrderByWithRelationInput
    invoices?: invoiceOrderByRelationAggregateInput
  }

  export type customerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: customerWhereInput | customerWhereInput[]
    OR?: customerWhereInput[]
    NOT?: customerWhereInput | customerWhereInput[]
    userId?: StringFilter<"customer"> | string
    name?: StringFilter<"customer"> | string
    email?: StringFilter<"customer"> | string
    createdat?: DateTimeFilter<"customer"> | Date | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    invoices?: InvoiceListRelationFilter
  }, "id">

  export type customerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdat?: SortOrder
    _count?: customerCountOrderByAggregateInput
    _max?: customerMaxOrderByAggregateInput
    _min?: customerMinOrderByAggregateInput
  }

  export type customerScalarWhereWithAggregatesInput = {
    AND?: customerScalarWhereWithAggregatesInput | customerScalarWhereWithAggregatesInput[]
    OR?: customerScalarWhereWithAggregatesInput[]
    NOT?: customerScalarWhereWithAggregatesInput | customerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"customer"> | string
    userId?: StringWithAggregatesFilter<"customer"> | string
    name?: StringWithAggregatesFilter<"customer"> | string
    email?: StringWithAggregatesFilter<"customer"> | string
    createdat?: DateTimeWithAggregatesFilter<"customer"> | Date | string
  }

  export type invoiceWhereInput = {
    AND?: invoiceWhereInput | invoiceWhereInput[]
    OR?: invoiceWhereInput[]
    NOT?: invoiceWhereInput | invoiceWhereInput[]
    id?: StringFilter<"invoice"> | string
    title?: StringFilter<"invoice"> | string
    description?: StringNullableFilter<"invoice"> | string | null
    amount?: IntFilter<"invoice"> | number
    userId?: StringFilter<"invoice"> | string
    customerId?: StringFilter<"invoice"> | string
    createdat?: DateTimeFilter<"invoice"> | Date | string
    status?: StringFilter<"invoice"> | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, customerWhereInput>
    payments?: PaymentListRelationFilter
  }

  export type invoiceOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    userId?: SortOrder
    customerId?: SortOrder
    createdat?: SortOrder
    status?: SortOrder
    user?: userOrderByWithRelationInput
    customer?: customerOrderByWithRelationInput
    payments?: paymentOrderByRelationAggregateInput
  }

  export type invoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: invoiceWhereInput | invoiceWhereInput[]
    OR?: invoiceWhereInput[]
    NOT?: invoiceWhereInput | invoiceWhereInput[]
    title?: StringFilter<"invoice"> | string
    description?: StringNullableFilter<"invoice"> | string | null
    amount?: IntFilter<"invoice"> | number
    userId?: StringFilter<"invoice"> | string
    customerId?: StringFilter<"invoice"> | string
    createdat?: DateTimeFilter<"invoice"> | Date | string
    status?: StringFilter<"invoice"> | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, customerWhereInput>
    payments?: PaymentListRelationFilter
  }, "id">

  export type invoiceOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    userId?: SortOrder
    customerId?: SortOrder
    createdat?: SortOrder
    status?: SortOrder
    _count?: invoiceCountOrderByAggregateInput
    _avg?: invoiceAvgOrderByAggregateInput
    _max?: invoiceMaxOrderByAggregateInput
    _min?: invoiceMinOrderByAggregateInput
    _sum?: invoiceSumOrderByAggregateInput
  }

  export type invoiceScalarWhereWithAggregatesInput = {
    AND?: invoiceScalarWhereWithAggregatesInput | invoiceScalarWhereWithAggregatesInput[]
    OR?: invoiceScalarWhereWithAggregatesInput[]
    NOT?: invoiceScalarWhereWithAggregatesInput | invoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"invoice"> | string
    title?: StringWithAggregatesFilter<"invoice"> | string
    description?: StringNullableWithAggregatesFilter<"invoice"> | string | null
    amount?: IntWithAggregatesFilter<"invoice"> | number
    userId?: StringWithAggregatesFilter<"invoice"> | string
    customerId?: StringWithAggregatesFilter<"invoice"> | string
    createdat?: DateTimeWithAggregatesFilter<"invoice"> | Date | string
    status?: StringWithAggregatesFilter<"invoice"> | string
  }

  export type paymentWhereInput = {
    AND?: paymentWhereInput | paymentWhereInput[]
    OR?: paymentWhereInput[]
    NOT?: paymentWhereInput | paymentWhereInput[]
    id?: StringFilter<"payment"> | string
    userId?: StringFilter<"payment"> | string
    amount?: StringFilter<"payment"> | string
    currency?: StringFilter<"payment"> | string
    invoiceId?: StringFilter<"payment"> | string
    stripeId?: StringNullableFilter<"payment"> | string | null
    status?: StringFilter<"payment"> | string
    createdat?: DateTimeFilter<"payment"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, invoiceWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type paymentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    invoiceId?: SortOrder
    stripeId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdat?: SortOrder
    invoice?: invoiceOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type paymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: paymentWhereInput | paymentWhereInput[]
    OR?: paymentWhereInput[]
    NOT?: paymentWhereInput | paymentWhereInput[]
    userId?: StringFilter<"payment"> | string
    amount?: StringFilter<"payment"> | string
    currency?: StringFilter<"payment"> | string
    invoiceId?: StringFilter<"payment"> | string
    stripeId?: StringNullableFilter<"payment"> | string | null
    status?: StringFilter<"payment"> | string
    createdat?: DateTimeFilter<"payment"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, invoiceWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type paymentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    invoiceId?: SortOrder
    stripeId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdat?: SortOrder
    _count?: paymentCountOrderByAggregateInput
    _max?: paymentMaxOrderByAggregateInput
    _min?: paymentMinOrderByAggregateInput
  }

  export type paymentScalarWhereWithAggregatesInput = {
    AND?: paymentScalarWhereWithAggregatesInput | paymentScalarWhereWithAggregatesInput[]
    OR?: paymentScalarWhereWithAggregatesInput[]
    NOT?: paymentScalarWhereWithAggregatesInput | paymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"payment"> | string
    userId?: StringWithAggregatesFilter<"payment"> | string
    amount?: StringWithAggregatesFilter<"payment"> | string
    currency?: StringWithAggregatesFilter<"payment"> | string
    invoiceId?: StringWithAggregatesFilter<"payment"> | string
    stripeId?: StringNullableWithAggregatesFilter<"payment"> | string | null
    status?: StringWithAggregatesFilter<"payment"> | string
    createdat?: DateTimeWithAggregatesFilter<"payment"> | Date | string
  }

  export type parametersWhereInput = {
    AND?: parametersWhereInput | parametersWhereInput[]
    OR?: parametersWhereInput[]
    NOT?: parametersWhereInput | parametersWhereInput[]
    id?: StringFilter<"parameters"> | string
    key?: StringFilter<"parameters"> | string
    name?: StringFilter<"parameters"> | string
    value?: StringFilter<"parameters"> | string
    createdat?: DateTimeFilter<"parameters"> | Date | string
    status?: IntFilter<"parameters"> | number
    userId?: StringFilter<"parameters"> | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type parametersOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    value?: SortOrder
    createdat?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type parametersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: parametersWhereInput | parametersWhereInput[]
    OR?: parametersWhereInput[]
    NOT?: parametersWhereInput | parametersWhereInput[]
    key?: StringFilter<"parameters"> | string
    name?: StringFilter<"parameters"> | string
    value?: StringFilter<"parameters"> | string
    createdat?: DateTimeFilter<"parameters"> | Date | string
    status?: IntFilter<"parameters"> | number
    userId?: StringFilter<"parameters"> | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type parametersOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    value?: SortOrder
    createdat?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    _count?: parametersCountOrderByAggregateInput
    _avg?: parametersAvgOrderByAggregateInput
    _max?: parametersMaxOrderByAggregateInput
    _min?: parametersMinOrderByAggregateInput
    _sum?: parametersSumOrderByAggregateInput
  }

  export type parametersScalarWhereWithAggregatesInput = {
    AND?: parametersScalarWhereWithAggregatesInput | parametersScalarWhereWithAggregatesInput[]
    OR?: parametersScalarWhereWithAggregatesInput[]
    NOT?: parametersScalarWhereWithAggregatesInput | parametersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"parameters"> | string
    key?: StringWithAggregatesFilter<"parameters"> | string
    name?: StringWithAggregatesFilter<"parameters"> | string
    value?: StringWithAggregatesFilter<"parameters"> | string
    createdat?: DateTimeWithAggregatesFilter<"parameters"> | Date | string
    status?: IntWithAggregatesFilter<"parameters"> | number
    userId?: StringWithAggregatesFilter<"parameters"> | string
  }

  export type apiclientCreateInput = {
    id?: string
    name: string
    key: string
    secret: string
    type: number
    createdat?: Date | string
    updatedat?: Date | string | null
    isactive: boolean
    createduser: userCreateNestedOneWithoutCreatedapiclientsInput
    updateduser?: userCreateNestedOneWithoutUpdatedapiclientsInput
  }

  export type apiclientUncheckedCreateInput = {
    id?: string
    name: string
    key: string
    secret: string
    type: number
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    isactive: boolean
  }

  export type apiclientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isactive?: BoolFieldUpdateOperationsInput | boolean
    createduser?: userUpdateOneRequiredWithoutCreatedapiclientsNestedInput
    updateduser?: userUpdateOneWithoutUpdatedapiclientsNestedInput
  }

  export type apiclientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type apiclientCreateManyInput = {
    id?: string
    name: string
    key: string
    secret: string
    type: number
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    isactive: boolean
  }

  export type apiclientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isactive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type apiclientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type refreshtokenCreateInput = {
    id?: string
    token: string
    createdat?: Date | string
    updatedat?: Date | string | null
    expiresat?: Date | string | null
    user: userCreateNestedOneWithoutRefreshtokensInput
  }

  export type refreshtokenUncheckedCreateInput = {
    id?: string
    userid: string
    token: string
    createdat?: Date | string
    updatedat?: Date | string | null
    expiresat?: Date | string | null
  }

  export type refreshtokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutRefreshtokensNestedInput
  }

  export type refreshtokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type refreshtokenCreateManyInput = {
    id?: string
    userid: string
    token: string
    createdat?: Date | string
    updatedat?: Date | string | null
    expiresat?: Date | string | null
  }

  export type refreshtokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type refreshtokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type revokedtokenCreateInput = {
    id?: string
    token: string
    date?: Date | string
  }

  export type revokedtokenUncheckedCreateInput = {
    id?: string
    token: string
    date?: Date | string
  }

  export type revokedtokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type revokedtokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type revokedtokenCreateManyInput = {
    id?: string
    token: string
    date?: Date | string
  }

  export type revokedtokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type revokedtokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type roleCreateInput = {
    id?: string
    name: string
    createdat?: Date | string
    updatedat?: Date | string | null
    issystemrole?: boolean
    createduser: userCreateNestedOneWithoutCreatedrolesInput
    updateduser?: userCreateNestedOneWithoutUpdatedrolesInput
    rolepermissions?: rolepermissionCreateNestedManyWithoutRoleInput
    userroles?: userroleCreateNestedManyWithoutRoleInput
  }

  export type roleUncheckedCreateInput = {
    id?: string
    name: string
    createdby: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
    issystemrole?: boolean
    rolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutRoleInput
    userroles?: userroleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type roleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issystemrole?: BoolFieldUpdateOperationsInput | boolean
    createduser?: userUpdateOneRequiredWithoutCreatedrolesNestedInput
    updateduser?: userUpdateOneWithoutUpdatedrolesNestedInput
    rolepermissions?: rolepermissionUpdateManyWithoutRoleNestedInput
    userroles?: userroleUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issystemrole?: BoolFieldUpdateOperationsInput | boolean
    rolepermissions?: rolepermissionUncheckedUpdateManyWithoutRoleNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type roleCreateManyInput = {
    id?: string
    name: string
    createdby: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
    issystemrole?: boolean
  }

  export type roleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issystemrole?: BoolFieldUpdateOperationsInput | boolean
  }

  export type roleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issystemrole?: BoolFieldUpdateOperationsInput | boolean
  }

  export type notificationCreateInput = {
    id?: string
    message: string
    url: string
    createdby: string
    createdat?: Date | string
    readedat?: Date | string | null
    to: userCreateNestedOneWithoutNotificationuserInput
  }

  export type notificationUncheckedCreateInput = {
    id?: string
    touserid: string
    message: string
    url: string
    createdby: string
    createdat?: Date | string
    readedat?: Date | string | null
  }

  export type notificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    readedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    to?: userUpdateOneRequiredWithoutNotificationuserNestedInput
  }

  export type notificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    touserid?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    readedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationCreateManyInput = {
    id?: string
    touserid: string
    message: string
    url: string
    createdby: string
    createdat?: Date | string
    readedat?: Date | string | null
  }

  export type notificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    readedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    touserid?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    readedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type permissionCreateInput = {
    id?: string
    name: string
    value: string
    group: string
    description: string
    createdat?: Date | string
    updatedat?: Date | string | null
    createduser: userCreateNestedOneWithoutCreatedpermissionsInput
    updateduser?: userCreateNestedOneWithoutUpdatedpermissionsInput
    rolepermissions?: rolepermissionCreateNestedManyWithoutPermissionInput
    userpermissions?: userpermissionCreateNestedManyWithoutPermissionInput
  }

  export type permissionUncheckedCreateInput = {
    id?: string
    name: string
    value: string
    group: string
    description: string
    createdby: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
    rolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutPermissionInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type permissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createduser?: userUpdateOneRequiredWithoutCreatedpermissionsNestedInput
    updateduser?: userUpdateOneWithoutUpdatedpermissionsNestedInput
    rolepermissions?: rolepermissionUpdateManyWithoutPermissionNestedInput
    userpermissions?: userpermissionUpdateManyWithoutPermissionNestedInput
  }

  export type permissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rolepermissions?: rolepermissionUncheckedUpdateManyWithoutPermissionNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type permissionCreateManyInput = {
    id?: string
    name: string
    value: string
    group: string
    description: string
    createdby: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type permissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type permissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolepermissionCreateInput = {
    id?: string
    createdat?: Date | string
    updatedat?: Date | string | null
    createduser: userCreateNestedOneWithoutCreatedrolepermissionsInput
    permission: permissionCreateNestedOneWithoutRolepermissionsInput
    role: roleCreateNestedOneWithoutRolepermissionsInput
    updateduser?: userCreateNestedOneWithoutUpdatedrolepermissionsInput
  }

  export type rolepermissionUncheckedCreateInput = {
    id?: string
    roleid: string
    permissionid: string
    createdat?: Date | string
    createdby: string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type rolepermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createduser?: userUpdateOneRequiredWithoutCreatedrolepermissionsNestedInput
    permission?: permissionUpdateOneRequiredWithoutRolepermissionsNestedInput
    role?: roleUpdateOneRequiredWithoutRolepermissionsNestedInput
    updateduser?: userUpdateOneWithoutUpdatedrolepermissionsNestedInput
  }

  export type rolepermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleid?: StringFieldUpdateOperationsInput | string
    permissionid?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolepermissionCreateManyInput = {
    id?: string
    roleid: string
    permissionid: string
    createdat?: Date | string
    createdby: string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type rolepermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolepermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleid?: StringFieldUpdateOperationsInput | string
    permissionid?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transactionCreateInput = {
    id?: string
    type: number
    useragent: string
    ipaddress: string
    createdat?: Date | string
    user: userCreateNestedOneWithoutTransactionsInput
  }

  export type transactionUncheckedCreateInput = {
    id?: string
    type: number
    useragent: string
    ipaddress: string
    userid: string
    createdat?: Date | string
  }

  export type transactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    useragent?: StringFieldUpdateOperationsInput | string
    ipaddress?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type transactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    useragent?: StringFieldUpdateOperationsInput | string
    ipaddress?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionCreateManyInput = {
    id?: string
    type: number
    useragent: string
    ipaddress: string
    userid: string
    createdat?: Date | string
  }

  export type transactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    useragent?: StringFieldUpdateOperationsInput | string
    ipaddress?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    useragent?: StringFieldUpdateOperationsInput | string
    ipaddress?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type entranceCreateInput = {
    id?: string
    type: string
    useragent: string
    ipaddress: string
    createdat?: Date | string
    user: userCreateNestedOneWithoutEntrancesInput
  }

  export type entranceUncheckedCreateInput = {
    id?: string
    type: string
    useragent: string
    ipaddress: string
    userid: string
    createdat?: Date | string
  }

  export type entranceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    useragent?: StringFieldUpdateOperationsInput | string
    ipaddress?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutEntrancesNestedInput
  }

  export type entranceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    useragent?: StringFieldUpdateOperationsInput | string
    ipaddress?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type entranceCreateManyInput = {
    id?: string
    type: string
    useragent: string
    ipaddress: string
    userid: string
    createdat?: Date | string
  }

  export type entranceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    useragent?: StringFieldUpdateOperationsInput | string
    ipaddress?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type entranceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    useragent?: StringFieldUpdateOperationsInput | string
    ipaddress?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userpermissionCreateInput = {
    id?: string
    createdat?: Date | string
    updatedat?: Date | string | null
    createduser: userCreateNestedOneWithoutCreateduserpermissionsInput
    permission: permissionCreateNestedOneWithoutUserpermissionsInput
    updateduser?: userCreateNestedOneWithoutUpdateduserpermissionsInput
    user: userCreateNestedOneWithoutUserpermissionsInput
  }

  export type userpermissionUncheckedCreateInput = {
    id?: string
    userid: string
    permissionid: string
    createdby: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type userpermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createduser?: userUpdateOneRequiredWithoutCreateduserpermissionsNestedInput
    permission?: permissionUpdateOneRequiredWithoutUserpermissionsNestedInput
    updateduser?: userUpdateOneWithoutUpdateduserpermissionsNestedInput
    user?: userUpdateOneRequiredWithoutUserpermissionsNestedInput
  }

  export type userpermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    permissionid?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userpermissionCreateManyInput = {
    id?: string
    userid: string
    permissionid: string
    createdby: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type userpermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userpermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    permissionid?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userroleCreateInput = {
    id?: string
    createdat?: Date | string
    updatedat?: Date | string | null
    createduser: userCreateNestedOneWithoutCreateduserrolesInput
    role: roleCreateNestedOneWithoutUserrolesInput
    updateduser?: userCreateNestedOneWithoutUpdateduserrolesInput
    user: userCreateNestedOneWithoutUserrolesInput
  }

  export type userroleUncheckedCreateInput = {
    id?: string
    userid: string
    roleid: string
    createdby: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type userroleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createduser?: userUpdateOneRequiredWithoutCreateduserrolesNestedInput
    role?: roleUpdateOneRequiredWithoutUserrolesNestedInput
    updateduser?: userUpdateOneWithoutUpdateduserrolesNestedInput
    user?: userUpdateOneRequiredWithoutUserrolesNestedInput
  }

  export type userroleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    roleid?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userroleCreateManyInput = {
    id?: string
    userid: string
    roleid: string
    createdby: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type userroleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userroleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    roleid?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userCreateInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
  }

  export type userUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type userUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type planCreateInput = {
    id?: string
    name: string
    price: string
    currency: string
    interval: string
    description?: string | null
    stripePriceId?: string | null
    stripeProductId?: string | null
    createdat?: Date | string
    subscriptions?: subscriptionCreateNestedManyWithoutPlanInput
    users?: userCreateNestedManyWithoutPlanInput
  }

  export type planUncheckedCreateInput = {
    id?: string
    name: string
    price: string
    currency: string
    interval: string
    description?: string | null
    stripePriceId?: string | null
    stripeProductId?: string | null
    createdat?: Date | string
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutPlanInput
    users?: userUncheckedCreateNestedManyWithoutPlanInput
  }

  export type planUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: subscriptionUpdateManyWithoutPlanNestedInput
    users?: userUpdateManyWithoutPlanNestedInput
  }

  export type planUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: subscriptionUncheckedUpdateManyWithoutPlanNestedInput
    users?: userUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type planCreateManyInput = {
    id?: string
    name: string
    price: string
    currency: string
    interval: string
    description?: string | null
    stripePriceId?: string | null
    stripeProductId?: string | null
    createdat?: Date | string
  }

  export type planUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type planUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subscriptionCreateInput = {
    id?: string
    stripeId?: string | null
    status?: string
    startedat?: Date | string
    endedat?: Date | string | null
    canceledat?: Date | string | null
    user: userCreateNestedOneWithoutSubscriptionsInput
    plan: planCreateNestedOneWithoutSubscriptionsInput
  }

  export type subscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    planId: string
    stripeId?: string | null
    status?: string
    startedat?: Date | string
    endedat?: Date | string | null
    canceledat?: Date | string | null
  }

  export type subscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedat?: DateTimeFieldUpdateOperationsInput | Date | string
    endedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: planUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type subscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedat?: DateTimeFieldUpdateOperationsInput | Date | string
    endedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subscriptionCreateManyInput = {
    id?: string
    userId: string
    planId: string
    stripeId?: string | null
    status?: string
    startedat?: Date | string
    endedat?: Date | string | null
    canceledat?: Date | string | null
  }

  export type subscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedat?: DateTimeFieldUpdateOperationsInput | Date | string
    endedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedat?: DateTimeFieldUpdateOperationsInput | Date | string
    endedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type customerCreateInput = {
    id?: string
    name: string
    email: string
    createdat?: Date | string
    user: userCreateNestedOneWithoutCustomersInput
    invoices?: invoiceCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    email: string
    createdat?: Date | string
    invoices?: invoiceUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutCustomersNestedInput
    invoices?: invoiceUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: invoiceUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type customerCreateManyInput = {
    id?: string
    userId: string
    name: string
    email: string
    createdat?: Date | string
  }

  export type customerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invoiceCreateInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    createdat?: Date | string
    status?: string
    user: userCreateNestedOneWithoutInvoicesInput
    customer: customerCreateNestedOneWithoutInvoicesInput
    payments?: paymentCreateNestedManyWithoutInvoiceInput
  }

  export type invoiceUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    userId: string
    customerId: string
    createdat?: Date | string
    status?: string
    payments?: paymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type invoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    user?: userUpdateOneRequiredWithoutInvoicesNestedInput
    customer?: customerUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: paymentUpdateManyWithoutInvoiceNestedInput
  }

  export type invoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    payments?: paymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type invoiceCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    userId: string
    customerId: string
    createdat?: Date | string
    status?: string
  }

  export type invoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type invoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type paymentCreateInput = {
    id?: string
    amount: string
    currency: string
    stripeId?: string | null
    status?: string
    createdat?: Date | string
    invoice: invoiceCreateNestedOneWithoutPaymentsInput
    user: userCreateNestedOneWithoutPaymentsInput
  }

  export type paymentUncheckedCreateInput = {
    id?: string
    userId: string
    amount: string
    currency: string
    invoiceId: string
    stripeId?: string | null
    status?: string
    createdat?: Date | string
  }

  export type paymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: invoiceUpdateOneRequiredWithoutPaymentsNestedInput
    user?: userUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type paymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentCreateManyInput = {
    id?: string
    userId: string
    amount: string
    currency: string
    invoiceId: string
    stripeId?: string | null
    status?: string
    createdat?: Date | string
  }

  export type paymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type parametersCreateInput = {
    id?: string
    key: string
    name: string
    value: string
    createdat?: Date | string
    status?: number
    user: userCreateNestedOneWithoutParametersInput
  }

  export type parametersUncheckedCreateInput = {
    id?: string
    key: string
    name: string
    value: string
    createdat?: Date | string
    status?: number
    userId: string
  }

  export type parametersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    user?: userUpdateOneRequiredWithoutParametersNestedInput
  }

  export type parametersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type parametersCreateManyInput = {
    id?: string
    key: string
    name: string
    value: string
    createdat?: Date | string
    status?: number
    userId: string
  }

  export type parametersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type parametersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserScalarRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type apiclientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    secret?: SortOrder
    type?: SortOrder
    createdat?: SortOrder
    createdby?: SortOrder
    updatedat?: SortOrder
    updatedby?: SortOrder
    isactive?: SortOrder
  }

  export type apiclientAvgOrderByAggregateInput = {
    type?: SortOrder
  }

  export type apiclientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    secret?: SortOrder
    type?: SortOrder
    createdat?: SortOrder
    createdby?: SortOrder
    updatedat?: SortOrder
    updatedby?: SortOrder
    isactive?: SortOrder
  }

  export type apiclientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    key?: SortOrder
    secret?: SortOrder
    type?: SortOrder
    createdat?: SortOrder
    createdby?: SortOrder
    updatedat?: SortOrder
    updatedby?: SortOrder
    isactive?: SortOrder
  }

  export type apiclientSumOrderByAggregateInput = {
    type?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type refreshtokenCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    token?: SortOrder
    createdat?: SortOrder
    updatedat?: SortOrder
    expiresat?: SortOrder
  }

  export type refreshtokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    token?: SortOrder
    createdat?: SortOrder
    updatedat?: SortOrder
    expiresat?: SortOrder
  }

  export type refreshtokenMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    token?: SortOrder
    createdat?: SortOrder
    updatedat?: SortOrder
    expiresat?: SortOrder
  }

  export type revokedtokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    date?: SortOrder
  }

  export type revokedtokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    date?: SortOrder
  }

  export type revokedtokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    date?: SortOrder
  }

  export type RolepermissionListRelationFilter = {
    every?: rolepermissionWhereInput
    some?: rolepermissionWhereInput
    none?: rolepermissionWhereInput
  }

  export type UserroleListRelationFilter = {
    every?: userroleWhereInput
    some?: userroleWhereInput
    none?: userroleWhereInput
  }

  export type rolepermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userroleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type roleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdby?: SortOrder
    createdat?: SortOrder
    updatedby?: SortOrder
    updatedat?: SortOrder
    issystemrole?: SortOrder
  }

  export type roleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdby?: SortOrder
    createdat?: SortOrder
    updatedby?: SortOrder
    updatedat?: SortOrder
    issystemrole?: SortOrder
  }

  export type roleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdby?: SortOrder
    createdat?: SortOrder
    updatedby?: SortOrder
    updatedat?: SortOrder
    issystemrole?: SortOrder
  }

  export type notificationCountOrderByAggregateInput = {
    id?: SortOrder
    touserid?: SortOrder
    message?: SortOrder
    url?: SortOrder
    createdby?: SortOrder
    createdat?: SortOrder
    readedat?: SortOrder
  }

  export type notificationMaxOrderByAggregateInput = {
    id?: SortOrder
    touserid?: SortOrder
    message?: SortOrder
    url?: SortOrder
    createdby?: SortOrder
    createdat?: SortOrder
    readedat?: SortOrder
  }

  export type notificationMinOrderByAggregateInput = {
    id?: SortOrder
    touserid?: SortOrder
    message?: SortOrder
    url?: SortOrder
    createdby?: SortOrder
    createdat?: SortOrder
    readedat?: SortOrder
  }

  export type UserpermissionListRelationFilter = {
    every?: userpermissionWhereInput
    some?: userpermissionWhereInput
    none?: userpermissionWhereInput
  }

  export type userpermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type permissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    group?: SortOrder
    description?: SortOrder
    createdby?: SortOrder
    createdat?: SortOrder
    updatedby?: SortOrder
    updatedat?: SortOrder
  }

  export type permissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    group?: SortOrder
    description?: SortOrder
    createdby?: SortOrder
    createdat?: SortOrder
    updatedby?: SortOrder
    updatedat?: SortOrder
  }

  export type permissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    group?: SortOrder
    description?: SortOrder
    createdby?: SortOrder
    createdat?: SortOrder
    updatedby?: SortOrder
    updatedat?: SortOrder
  }

  export type PermissionScalarRelationFilter = {
    is?: permissionWhereInput
    isNot?: permissionWhereInput
  }

  export type RoleScalarRelationFilter = {
    is?: roleWhereInput
    isNot?: roleWhereInput
  }

  export type rolepermissionCountOrderByAggregateInput = {
    id?: SortOrder
    roleid?: SortOrder
    permissionid?: SortOrder
    createdat?: SortOrder
    createdby?: SortOrder
    updatedby?: SortOrder
    updatedat?: SortOrder
  }

  export type rolepermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleid?: SortOrder
    permissionid?: SortOrder
    createdat?: SortOrder
    createdby?: SortOrder
    updatedby?: SortOrder
    updatedat?: SortOrder
  }

  export type rolepermissionMinOrderByAggregateInput = {
    id?: SortOrder
    roleid?: SortOrder
    permissionid?: SortOrder
    createdat?: SortOrder
    createdby?: SortOrder
    updatedby?: SortOrder
    updatedat?: SortOrder
  }

  export type transactionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    useragent?: SortOrder
    ipaddress?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
  }

  export type transactionAvgOrderByAggregateInput = {
    type?: SortOrder
  }

  export type transactionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    useragent?: SortOrder
    ipaddress?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
  }

  export type transactionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    useragent?: SortOrder
    ipaddress?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
  }

  export type transactionSumOrderByAggregateInput = {
    type?: SortOrder
  }

  export type entranceCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    useragent?: SortOrder
    ipaddress?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
  }

  export type entranceMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    useragent?: SortOrder
    ipaddress?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
  }

  export type entranceMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    useragent?: SortOrder
    ipaddress?: SortOrder
    userid?: SortOrder
    createdat?: SortOrder
  }

  export type userpermissionCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    permissionid?: SortOrder
    createdby?: SortOrder
    createdat?: SortOrder
    updatedby?: SortOrder
    updatedat?: SortOrder
  }

  export type userpermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    permissionid?: SortOrder
    createdby?: SortOrder
    createdat?: SortOrder
    updatedby?: SortOrder
    updatedat?: SortOrder
  }

  export type userpermissionMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    permissionid?: SortOrder
    createdby?: SortOrder
    createdat?: SortOrder
    updatedby?: SortOrder
    updatedat?: SortOrder
  }

  export type userroleCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    roleid?: SortOrder
    createdby?: SortOrder
    createdat?: SortOrder
    updatedby?: SortOrder
    updatedat?: SortOrder
  }

  export type userroleMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    roleid?: SortOrder
    createdby?: SortOrder
    createdat?: SortOrder
    updatedby?: SortOrder
    updatedat?: SortOrder
  }

  export type userroleMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    roleid?: SortOrder
    createdby?: SortOrder
    createdat?: SortOrder
    updatedby?: SortOrder
    updatedat?: SortOrder
  }

  export type InvoiceListRelationFilter = {
    every?: invoiceWhereInput
    some?: invoiceWhereInput
    none?: invoiceWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: subscriptionWhereInput
    some?: subscriptionWhereInput
    none?: subscriptionWhereInput
  }

  export type CustomerListRelationFilter = {
    every?: customerWhereInput
    some?: customerWhereInput
    none?: customerWhereInput
  }

  export type ParametersListRelationFilter = {
    every?: parametersWhereInput
    some?: parametersWhereInput
    none?: parametersWhereInput
  }

  export type EntranceListRelationFilter = {
    every?: entranceWhereInput
    some?: entranceWhereInput
    none?: entranceWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: paymentWhereInput
    some?: paymentWhereInput
    none?: paymentWhereInput
  }

  export type PlanNullableScalarRelationFilter = {
    is?: planWhereInput | null
    isNot?: planWhereInput | null
  }

  export type TransactionListRelationFilter = {
    every?: transactionWhereInput
    some?: transactionWhereInput
    none?: transactionWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: notificationWhereInput
    some?: notificationWhereInput
    none?: notificationWhereInput
  }

  export type ApiclientListRelationFilter = {
    every?: apiclientWhereInput
    some?: apiclientWhereInput
    none?: apiclientWhereInput
  }

  export type PermissionListRelationFilter = {
    every?: permissionWhereInput
    some?: permissionWhereInput
    none?: permissionWhereInput
  }

  export type RefreshtokenListRelationFilter = {
    every?: refreshtokenWhereInput
    some?: refreshtokenWhereInput
    none?: refreshtokenWhereInput
  }

  export type RoleListRelationFilter = {
    every?: roleWhereInput
    some?: roleWhereInput
    none?: roleWhereInput
  }

  export type UserListRelationFilter = {
    every?: userWhereInput
    some?: userWhereInput
    none?: userWhereInput
  }

  export type invoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type subscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type customerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type parametersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type entranceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type paymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type transactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type apiclientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type permissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type refreshtokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type roleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    planId?: SortOrder
    password?: SortOrder
    companyName?: SortOrder
    companyLogoUrl?: SortOrder
    taxId?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdat?: SortOrder
    createdby?: SortOrder
    updatedat?: SortOrder
    updatedby?: SortOrder
    status?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    planId?: SortOrder
    password?: SortOrder
    companyName?: SortOrder
    companyLogoUrl?: SortOrder
    taxId?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdat?: SortOrder
    createdby?: SortOrder
    updatedat?: SortOrder
    updatedby?: SortOrder
    status?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    planId?: SortOrder
    password?: SortOrder
    companyName?: SortOrder
    companyLogoUrl?: SortOrder
    taxId?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdat?: SortOrder
    createdby?: SortOrder
    updatedat?: SortOrder
    updatedby?: SortOrder
    status?: SortOrder
  }

  export type planCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    description?: SortOrder
    stripePriceId?: SortOrder
    stripeProductId?: SortOrder
    createdat?: SortOrder
  }

  export type planMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    description?: SortOrder
    stripePriceId?: SortOrder
    stripeProductId?: SortOrder
    createdat?: SortOrder
  }

  export type planMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    description?: SortOrder
    stripePriceId?: SortOrder
    stripeProductId?: SortOrder
    createdat?: SortOrder
  }

  export type PlanScalarRelationFilter = {
    is?: planWhereInput
    isNot?: planWhereInput
  }

  export type subscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    stripeId?: SortOrder
    status?: SortOrder
    startedat?: SortOrder
    endedat?: SortOrder
    canceledat?: SortOrder
  }

  export type subscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    stripeId?: SortOrder
    status?: SortOrder
    startedat?: SortOrder
    endedat?: SortOrder
    canceledat?: SortOrder
  }

  export type subscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    stripeId?: SortOrder
    status?: SortOrder
    startedat?: SortOrder
    endedat?: SortOrder
    canceledat?: SortOrder
  }

  export type customerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdat?: SortOrder
  }

  export type customerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdat?: SortOrder
  }

  export type customerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdat?: SortOrder
  }

  export type CustomerScalarRelationFilter = {
    is?: customerWhereInput
    isNot?: customerWhereInput
  }

  export type invoiceCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    userId?: SortOrder
    customerId?: SortOrder
    createdat?: SortOrder
    status?: SortOrder
  }

  export type invoiceAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type invoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    userId?: SortOrder
    customerId?: SortOrder
    createdat?: SortOrder
    status?: SortOrder
  }

  export type invoiceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    userId?: SortOrder
    customerId?: SortOrder
    createdat?: SortOrder
    status?: SortOrder
  }

  export type invoiceSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceScalarRelationFilter = {
    is?: invoiceWhereInput
    isNot?: invoiceWhereInput
  }

  export type paymentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    invoiceId?: SortOrder
    stripeId?: SortOrder
    status?: SortOrder
    createdat?: SortOrder
  }

  export type paymentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    invoiceId?: SortOrder
    stripeId?: SortOrder
    status?: SortOrder
    createdat?: SortOrder
  }

  export type paymentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    invoiceId?: SortOrder
    stripeId?: SortOrder
    status?: SortOrder
    createdat?: SortOrder
  }

  export type parametersCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    value?: SortOrder
    createdat?: SortOrder
    status?: SortOrder
    userId?: SortOrder
  }

  export type parametersAvgOrderByAggregateInput = {
    status?: SortOrder
  }

  export type parametersMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    value?: SortOrder
    createdat?: SortOrder
    status?: SortOrder
    userId?: SortOrder
  }

  export type parametersMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    value?: SortOrder
    createdat?: SortOrder
    status?: SortOrder
    userId?: SortOrder
  }

  export type parametersSumOrderByAggregateInput = {
    status?: SortOrder
  }

  export type userCreateNestedOneWithoutCreatedapiclientsInput = {
    create?: XOR<userCreateWithoutCreatedapiclientsInput, userUncheckedCreateWithoutCreatedapiclientsInput>
    connectOrCreate?: userCreateOrConnectWithoutCreatedapiclientsInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutUpdatedapiclientsInput = {
    create?: XOR<userCreateWithoutUpdatedapiclientsInput, userUncheckedCreateWithoutUpdatedapiclientsInput>
    connectOrCreate?: userCreateOrConnectWithoutUpdatedapiclientsInput
    connect?: userWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type userUpdateOneRequiredWithoutCreatedapiclientsNestedInput = {
    create?: XOR<userCreateWithoutCreatedapiclientsInput, userUncheckedCreateWithoutCreatedapiclientsInput>
    connectOrCreate?: userCreateOrConnectWithoutCreatedapiclientsInput
    upsert?: userUpsertWithoutCreatedapiclientsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutCreatedapiclientsInput, userUpdateWithoutCreatedapiclientsInput>, userUncheckedUpdateWithoutCreatedapiclientsInput>
  }

  export type userUpdateOneWithoutUpdatedapiclientsNestedInput = {
    create?: XOR<userCreateWithoutUpdatedapiclientsInput, userUncheckedCreateWithoutUpdatedapiclientsInput>
    connectOrCreate?: userCreateOrConnectWithoutUpdatedapiclientsInput
    upsert?: userUpsertWithoutUpdatedapiclientsInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUpdatedapiclientsInput, userUpdateWithoutUpdatedapiclientsInput>, userUncheckedUpdateWithoutUpdatedapiclientsInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type userCreateNestedOneWithoutRefreshtokensInput = {
    create?: XOR<userCreateWithoutRefreshtokensInput, userUncheckedCreateWithoutRefreshtokensInput>
    connectOrCreate?: userCreateOrConnectWithoutRefreshtokensInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutRefreshtokensNestedInput = {
    create?: XOR<userCreateWithoutRefreshtokensInput, userUncheckedCreateWithoutRefreshtokensInput>
    connectOrCreate?: userCreateOrConnectWithoutRefreshtokensInput
    upsert?: userUpsertWithoutRefreshtokensInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutRefreshtokensInput, userUpdateWithoutRefreshtokensInput>, userUncheckedUpdateWithoutRefreshtokensInput>
  }

  export type userCreateNestedOneWithoutCreatedrolesInput = {
    create?: XOR<userCreateWithoutCreatedrolesInput, userUncheckedCreateWithoutCreatedrolesInput>
    connectOrCreate?: userCreateOrConnectWithoutCreatedrolesInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutUpdatedrolesInput = {
    create?: XOR<userCreateWithoutUpdatedrolesInput, userUncheckedCreateWithoutUpdatedrolesInput>
    connectOrCreate?: userCreateOrConnectWithoutUpdatedrolesInput
    connect?: userWhereUniqueInput
  }

  export type rolepermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<rolepermissionCreateWithoutRoleInput, rolepermissionUncheckedCreateWithoutRoleInput> | rolepermissionCreateWithoutRoleInput[] | rolepermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: rolepermissionCreateOrConnectWithoutRoleInput | rolepermissionCreateOrConnectWithoutRoleInput[]
    createMany?: rolepermissionCreateManyRoleInputEnvelope
    connect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
  }

  export type userroleCreateNestedManyWithoutRoleInput = {
    create?: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput> | userroleCreateWithoutRoleInput[] | userroleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutRoleInput | userroleCreateOrConnectWithoutRoleInput[]
    createMany?: userroleCreateManyRoleInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type rolepermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<rolepermissionCreateWithoutRoleInput, rolepermissionUncheckedCreateWithoutRoleInput> | rolepermissionCreateWithoutRoleInput[] | rolepermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: rolepermissionCreateOrConnectWithoutRoleInput | rolepermissionCreateOrConnectWithoutRoleInput[]
    createMany?: rolepermissionCreateManyRoleInputEnvelope
    connect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
  }

  export type userroleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput> | userroleCreateWithoutRoleInput[] | userroleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutRoleInput | userroleCreateOrConnectWithoutRoleInput[]
    createMany?: userroleCreateManyRoleInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type userUpdateOneRequiredWithoutCreatedrolesNestedInput = {
    create?: XOR<userCreateWithoutCreatedrolesInput, userUncheckedCreateWithoutCreatedrolesInput>
    connectOrCreate?: userCreateOrConnectWithoutCreatedrolesInput
    upsert?: userUpsertWithoutCreatedrolesInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutCreatedrolesInput, userUpdateWithoutCreatedrolesInput>, userUncheckedUpdateWithoutCreatedrolesInput>
  }

  export type userUpdateOneWithoutUpdatedrolesNestedInput = {
    create?: XOR<userCreateWithoutUpdatedrolesInput, userUncheckedCreateWithoutUpdatedrolesInput>
    connectOrCreate?: userCreateOrConnectWithoutUpdatedrolesInput
    upsert?: userUpsertWithoutUpdatedrolesInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUpdatedrolesInput, userUpdateWithoutUpdatedrolesInput>, userUncheckedUpdateWithoutUpdatedrolesInput>
  }

  export type rolepermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<rolepermissionCreateWithoutRoleInput, rolepermissionUncheckedCreateWithoutRoleInput> | rolepermissionCreateWithoutRoleInput[] | rolepermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: rolepermissionCreateOrConnectWithoutRoleInput | rolepermissionCreateOrConnectWithoutRoleInput[]
    upsert?: rolepermissionUpsertWithWhereUniqueWithoutRoleInput | rolepermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: rolepermissionCreateManyRoleInputEnvelope
    set?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    disconnect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    delete?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    connect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    update?: rolepermissionUpdateWithWhereUniqueWithoutRoleInput | rolepermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: rolepermissionUpdateManyWithWhereWithoutRoleInput | rolepermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: rolepermissionScalarWhereInput | rolepermissionScalarWhereInput[]
  }

  export type userroleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput> | userroleCreateWithoutRoleInput[] | userroleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutRoleInput | userroleCreateOrConnectWithoutRoleInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutRoleInput | userroleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: userroleCreateManyRoleInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutRoleInput | userroleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutRoleInput | userroleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type rolepermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<rolepermissionCreateWithoutRoleInput, rolepermissionUncheckedCreateWithoutRoleInput> | rolepermissionCreateWithoutRoleInput[] | rolepermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: rolepermissionCreateOrConnectWithoutRoleInput | rolepermissionCreateOrConnectWithoutRoleInput[]
    upsert?: rolepermissionUpsertWithWhereUniqueWithoutRoleInput | rolepermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: rolepermissionCreateManyRoleInputEnvelope
    set?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    disconnect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    delete?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    connect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    update?: rolepermissionUpdateWithWhereUniqueWithoutRoleInput | rolepermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: rolepermissionUpdateManyWithWhereWithoutRoleInput | rolepermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: rolepermissionScalarWhereInput | rolepermissionScalarWhereInput[]
  }

  export type userroleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput> | userroleCreateWithoutRoleInput[] | userroleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutRoleInput | userroleCreateOrConnectWithoutRoleInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutRoleInput | userroleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: userroleCreateManyRoleInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutRoleInput | userroleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutRoleInput | userroleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutNotificationuserInput = {
    create?: XOR<userCreateWithoutNotificationuserInput, userUncheckedCreateWithoutNotificationuserInput>
    connectOrCreate?: userCreateOrConnectWithoutNotificationuserInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutNotificationuserNestedInput = {
    create?: XOR<userCreateWithoutNotificationuserInput, userUncheckedCreateWithoutNotificationuserInput>
    connectOrCreate?: userCreateOrConnectWithoutNotificationuserInput
    upsert?: userUpsertWithoutNotificationuserInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutNotificationuserInput, userUpdateWithoutNotificationuserInput>, userUncheckedUpdateWithoutNotificationuserInput>
  }

  export type userCreateNestedOneWithoutCreatedpermissionsInput = {
    create?: XOR<userCreateWithoutCreatedpermissionsInput, userUncheckedCreateWithoutCreatedpermissionsInput>
    connectOrCreate?: userCreateOrConnectWithoutCreatedpermissionsInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutUpdatedpermissionsInput = {
    create?: XOR<userCreateWithoutUpdatedpermissionsInput, userUncheckedCreateWithoutUpdatedpermissionsInput>
    connectOrCreate?: userCreateOrConnectWithoutUpdatedpermissionsInput
    connect?: userWhereUniqueInput
  }

  export type rolepermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<rolepermissionCreateWithoutPermissionInput, rolepermissionUncheckedCreateWithoutPermissionInput> | rolepermissionCreateWithoutPermissionInput[] | rolepermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: rolepermissionCreateOrConnectWithoutPermissionInput | rolepermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: rolepermissionCreateManyPermissionInputEnvelope
    connect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
  }

  export type userpermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<userpermissionCreateWithoutPermissionInput, userpermissionUncheckedCreateWithoutPermissionInput> | userpermissionCreateWithoutPermissionInput[] | userpermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: userpermissionCreateOrConnectWithoutPermissionInput | userpermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: userpermissionCreateManyPermissionInputEnvelope
    connect?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
  }

  export type rolepermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<rolepermissionCreateWithoutPermissionInput, rolepermissionUncheckedCreateWithoutPermissionInput> | rolepermissionCreateWithoutPermissionInput[] | rolepermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: rolepermissionCreateOrConnectWithoutPermissionInput | rolepermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: rolepermissionCreateManyPermissionInputEnvelope
    connect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
  }

  export type userpermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<userpermissionCreateWithoutPermissionInput, userpermissionUncheckedCreateWithoutPermissionInput> | userpermissionCreateWithoutPermissionInput[] | userpermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: userpermissionCreateOrConnectWithoutPermissionInput | userpermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: userpermissionCreateManyPermissionInputEnvelope
    connect?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
  }

  export type userUpdateOneRequiredWithoutCreatedpermissionsNestedInput = {
    create?: XOR<userCreateWithoutCreatedpermissionsInput, userUncheckedCreateWithoutCreatedpermissionsInput>
    connectOrCreate?: userCreateOrConnectWithoutCreatedpermissionsInput
    upsert?: userUpsertWithoutCreatedpermissionsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutCreatedpermissionsInput, userUpdateWithoutCreatedpermissionsInput>, userUncheckedUpdateWithoutCreatedpermissionsInput>
  }

  export type userUpdateOneWithoutUpdatedpermissionsNestedInput = {
    create?: XOR<userCreateWithoutUpdatedpermissionsInput, userUncheckedCreateWithoutUpdatedpermissionsInput>
    connectOrCreate?: userCreateOrConnectWithoutUpdatedpermissionsInput
    upsert?: userUpsertWithoutUpdatedpermissionsInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUpdatedpermissionsInput, userUpdateWithoutUpdatedpermissionsInput>, userUncheckedUpdateWithoutUpdatedpermissionsInput>
  }

  export type rolepermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<rolepermissionCreateWithoutPermissionInput, rolepermissionUncheckedCreateWithoutPermissionInput> | rolepermissionCreateWithoutPermissionInput[] | rolepermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: rolepermissionCreateOrConnectWithoutPermissionInput | rolepermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: rolepermissionUpsertWithWhereUniqueWithoutPermissionInput | rolepermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: rolepermissionCreateManyPermissionInputEnvelope
    set?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    disconnect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    delete?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    connect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    update?: rolepermissionUpdateWithWhereUniqueWithoutPermissionInput | rolepermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: rolepermissionUpdateManyWithWhereWithoutPermissionInput | rolepermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: rolepermissionScalarWhereInput | rolepermissionScalarWhereInput[]
  }

  export type userpermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<userpermissionCreateWithoutPermissionInput, userpermissionUncheckedCreateWithoutPermissionInput> | userpermissionCreateWithoutPermissionInput[] | userpermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: userpermissionCreateOrConnectWithoutPermissionInput | userpermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: userpermissionUpsertWithWhereUniqueWithoutPermissionInput | userpermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: userpermissionCreateManyPermissionInputEnvelope
    set?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    disconnect?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    delete?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    connect?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    update?: userpermissionUpdateWithWhereUniqueWithoutPermissionInput | userpermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: userpermissionUpdateManyWithWhereWithoutPermissionInput | userpermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: userpermissionScalarWhereInput | userpermissionScalarWhereInput[]
  }

  export type rolepermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<rolepermissionCreateWithoutPermissionInput, rolepermissionUncheckedCreateWithoutPermissionInput> | rolepermissionCreateWithoutPermissionInput[] | rolepermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: rolepermissionCreateOrConnectWithoutPermissionInput | rolepermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: rolepermissionUpsertWithWhereUniqueWithoutPermissionInput | rolepermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: rolepermissionCreateManyPermissionInputEnvelope
    set?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    disconnect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    delete?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    connect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    update?: rolepermissionUpdateWithWhereUniqueWithoutPermissionInput | rolepermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: rolepermissionUpdateManyWithWhereWithoutPermissionInput | rolepermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: rolepermissionScalarWhereInput | rolepermissionScalarWhereInput[]
  }

  export type userpermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<userpermissionCreateWithoutPermissionInput, userpermissionUncheckedCreateWithoutPermissionInput> | userpermissionCreateWithoutPermissionInput[] | userpermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: userpermissionCreateOrConnectWithoutPermissionInput | userpermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: userpermissionUpsertWithWhereUniqueWithoutPermissionInput | userpermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: userpermissionCreateManyPermissionInputEnvelope
    set?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    disconnect?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    delete?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    connect?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    update?: userpermissionUpdateWithWhereUniqueWithoutPermissionInput | userpermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: userpermissionUpdateManyWithWhereWithoutPermissionInput | userpermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: userpermissionScalarWhereInput | userpermissionScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutCreatedrolepermissionsInput = {
    create?: XOR<userCreateWithoutCreatedrolepermissionsInput, userUncheckedCreateWithoutCreatedrolepermissionsInput>
    connectOrCreate?: userCreateOrConnectWithoutCreatedrolepermissionsInput
    connect?: userWhereUniqueInput
  }

  export type permissionCreateNestedOneWithoutRolepermissionsInput = {
    create?: XOR<permissionCreateWithoutRolepermissionsInput, permissionUncheckedCreateWithoutRolepermissionsInput>
    connectOrCreate?: permissionCreateOrConnectWithoutRolepermissionsInput
    connect?: permissionWhereUniqueInput
  }

  export type roleCreateNestedOneWithoutRolepermissionsInput = {
    create?: XOR<roleCreateWithoutRolepermissionsInput, roleUncheckedCreateWithoutRolepermissionsInput>
    connectOrCreate?: roleCreateOrConnectWithoutRolepermissionsInput
    connect?: roleWhereUniqueInput
  }

  export type userCreateNestedOneWithoutUpdatedrolepermissionsInput = {
    create?: XOR<userCreateWithoutUpdatedrolepermissionsInput, userUncheckedCreateWithoutUpdatedrolepermissionsInput>
    connectOrCreate?: userCreateOrConnectWithoutUpdatedrolepermissionsInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutCreatedrolepermissionsNestedInput = {
    create?: XOR<userCreateWithoutCreatedrolepermissionsInput, userUncheckedCreateWithoutCreatedrolepermissionsInput>
    connectOrCreate?: userCreateOrConnectWithoutCreatedrolepermissionsInput
    upsert?: userUpsertWithoutCreatedrolepermissionsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutCreatedrolepermissionsInput, userUpdateWithoutCreatedrolepermissionsInput>, userUncheckedUpdateWithoutCreatedrolepermissionsInput>
  }

  export type permissionUpdateOneRequiredWithoutRolepermissionsNestedInput = {
    create?: XOR<permissionCreateWithoutRolepermissionsInput, permissionUncheckedCreateWithoutRolepermissionsInput>
    connectOrCreate?: permissionCreateOrConnectWithoutRolepermissionsInput
    upsert?: permissionUpsertWithoutRolepermissionsInput
    connect?: permissionWhereUniqueInput
    update?: XOR<XOR<permissionUpdateToOneWithWhereWithoutRolepermissionsInput, permissionUpdateWithoutRolepermissionsInput>, permissionUncheckedUpdateWithoutRolepermissionsInput>
  }

  export type roleUpdateOneRequiredWithoutRolepermissionsNestedInput = {
    create?: XOR<roleCreateWithoutRolepermissionsInput, roleUncheckedCreateWithoutRolepermissionsInput>
    connectOrCreate?: roleCreateOrConnectWithoutRolepermissionsInput
    upsert?: roleUpsertWithoutRolepermissionsInput
    connect?: roleWhereUniqueInput
    update?: XOR<XOR<roleUpdateToOneWithWhereWithoutRolepermissionsInput, roleUpdateWithoutRolepermissionsInput>, roleUncheckedUpdateWithoutRolepermissionsInput>
  }

  export type userUpdateOneWithoutUpdatedrolepermissionsNestedInput = {
    create?: XOR<userCreateWithoutUpdatedrolepermissionsInput, userUncheckedCreateWithoutUpdatedrolepermissionsInput>
    connectOrCreate?: userCreateOrConnectWithoutUpdatedrolepermissionsInput
    upsert?: userUpsertWithoutUpdatedrolepermissionsInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUpdatedrolepermissionsInput, userUpdateWithoutUpdatedrolepermissionsInput>, userUncheckedUpdateWithoutUpdatedrolepermissionsInput>
  }

  export type userCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<userCreateWithoutTransactionsInput, userUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: userCreateOrConnectWithoutTransactionsInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<userCreateWithoutTransactionsInput, userUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: userCreateOrConnectWithoutTransactionsInput
    upsert?: userUpsertWithoutTransactionsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutTransactionsInput, userUpdateWithoutTransactionsInput>, userUncheckedUpdateWithoutTransactionsInput>
  }

  export type userCreateNestedOneWithoutEntrancesInput = {
    create?: XOR<userCreateWithoutEntrancesInput, userUncheckedCreateWithoutEntrancesInput>
    connectOrCreate?: userCreateOrConnectWithoutEntrancesInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutEntrancesNestedInput = {
    create?: XOR<userCreateWithoutEntrancesInput, userUncheckedCreateWithoutEntrancesInput>
    connectOrCreate?: userCreateOrConnectWithoutEntrancesInput
    upsert?: userUpsertWithoutEntrancesInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutEntrancesInput, userUpdateWithoutEntrancesInput>, userUncheckedUpdateWithoutEntrancesInput>
  }

  export type userCreateNestedOneWithoutCreateduserpermissionsInput = {
    create?: XOR<userCreateWithoutCreateduserpermissionsInput, userUncheckedCreateWithoutCreateduserpermissionsInput>
    connectOrCreate?: userCreateOrConnectWithoutCreateduserpermissionsInput
    connect?: userWhereUniqueInput
  }

  export type permissionCreateNestedOneWithoutUserpermissionsInput = {
    create?: XOR<permissionCreateWithoutUserpermissionsInput, permissionUncheckedCreateWithoutUserpermissionsInput>
    connectOrCreate?: permissionCreateOrConnectWithoutUserpermissionsInput
    connect?: permissionWhereUniqueInput
  }

  export type userCreateNestedOneWithoutUpdateduserpermissionsInput = {
    create?: XOR<userCreateWithoutUpdateduserpermissionsInput, userUncheckedCreateWithoutUpdateduserpermissionsInput>
    connectOrCreate?: userCreateOrConnectWithoutUpdateduserpermissionsInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutUserpermissionsInput = {
    create?: XOR<userCreateWithoutUserpermissionsInput, userUncheckedCreateWithoutUserpermissionsInput>
    connectOrCreate?: userCreateOrConnectWithoutUserpermissionsInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutCreateduserpermissionsNestedInput = {
    create?: XOR<userCreateWithoutCreateduserpermissionsInput, userUncheckedCreateWithoutCreateduserpermissionsInput>
    connectOrCreate?: userCreateOrConnectWithoutCreateduserpermissionsInput
    upsert?: userUpsertWithoutCreateduserpermissionsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutCreateduserpermissionsInput, userUpdateWithoutCreateduserpermissionsInput>, userUncheckedUpdateWithoutCreateduserpermissionsInput>
  }

  export type permissionUpdateOneRequiredWithoutUserpermissionsNestedInput = {
    create?: XOR<permissionCreateWithoutUserpermissionsInput, permissionUncheckedCreateWithoutUserpermissionsInput>
    connectOrCreate?: permissionCreateOrConnectWithoutUserpermissionsInput
    upsert?: permissionUpsertWithoutUserpermissionsInput
    connect?: permissionWhereUniqueInput
    update?: XOR<XOR<permissionUpdateToOneWithWhereWithoutUserpermissionsInput, permissionUpdateWithoutUserpermissionsInput>, permissionUncheckedUpdateWithoutUserpermissionsInput>
  }

  export type userUpdateOneWithoutUpdateduserpermissionsNestedInput = {
    create?: XOR<userCreateWithoutUpdateduserpermissionsInput, userUncheckedCreateWithoutUpdateduserpermissionsInput>
    connectOrCreate?: userCreateOrConnectWithoutUpdateduserpermissionsInput
    upsert?: userUpsertWithoutUpdateduserpermissionsInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUpdateduserpermissionsInput, userUpdateWithoutUpdateduserpermissionsInput>, userUncheckedUpdateWithoutUpdateduserpermissionsInput>
  }

  export type userUpdateOneRequiredWithoutUserpermissionsNestedInput = {
    create?: XOR<userCreateWithoutUserpermissionsInput, userUncheckedCreateWithoutUserpermissionsInput>
    connectOrCreate?: userCreateOrConnectWithoutUserpermissionsInput
    upsert?: userUpsertWithoutUserpermissionsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUserpermissionsInput, userUpdateWithoutUserpermissionsInput>, userUncheckedUpdateWithoutUserpermissionsInput>
  }

  export type userCreateNestedOneWithoutCreateduserrolesInput = {
    create?: XOR<userCreateWithoutCreateduserrolesInput, userUncheckedCreateWithoutCreateduserrolesInput>
    connectOrCreate?: userCreateOrConnectWithoutCreateduserrolesInput
    connect?: userWhereUniqueInput
  }

  export type roleCreateNestedOneWithoutUserrolesInput = {
    create?: XOR<roleCreateWithoutUserrolesInput, roleUncheckedCreateWithoutUserrolesInput>
    connectOrCreate?: roleCreateOrConnectWithoutUserrolesInput
    connect?: roleWhereUniqueInput
  }

  export type userCreateNestedOneWithoutUpdateduserrolesInput = {
    create?: XOR<userCreateWithoutUpdateduserrolesInput, userUncheckedCreateWithoutUpdateduserrolesInput>
    connectOrCreate?: userCreateOrConnectWithoutUpdateduserrolesInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutUserrolesInput = {
    create?: XOR<userCreateWithoutUserrolesInput, userUncheckedCreateWithoutUserrolesInput>
    connectOrCreate?: userCreateOrConnectWithoutUserrolesInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutCreateduserrolesNestedInput = {
    create?: XOR<userCreateWithoutCreateduserrolesInput, userUncheckedCreateWithoutCreateduserrolesInput>
    connectOrCreate?: userCreateOrConnectWithoutCreateduserrolesInput
    upsert?: userUpsertWithoutCreateduserrolesInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutCreateduserrolesInput, userUpdateWithoutCreateduserrolesInput>, userUncheckedUpdateWithoutCreateduserrolesInput>
  }

  export type roleUpdateOneRequiredWithoutUserrolesNestedInput = {
    create?: XOR<roleCreateWithoutUserrolesInput, roleUncheckedCreateWithoutUserrolesInput>
    connectOrCreate?: roleCreateOrConnectWithoutUserrolesInput
    upsert?: roleUpsertWithoutUserrolesInput
    connect?: roleWhereUniqueInput
    update?: XOR<XOR<roleUpdateToOneWithWhereWithoutUserrolesInput, roleUpdateWithoutUserrolesInput>, roleUncheckedUpdateWithoutUserrolesInput>
  }

  export type userUpdateOneWithoutUpdateduserrolesNestedInput = {
    create?: XOR<userCreateWithoutUpdateduserrolesInput, userUncheckedCreateWithoutUpdateduserrolesInput>
    connectOrCreate?: userCreateOrConnectWithoutUpdateduserrolesInput
    upsert?: userUpsertWithoutUpdateduserrolesInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUpdateduserrolesInput, userUpdateWithoutUpdateduserrolesInput>, userUncheckedUpdateWithoutUpdateduserrolesInput>
  }

  export type userUpdateOneRequiredWithoutUserrolesNestedInput = {
    create?: XOR<userCreateWithoutUserrolesInput, userUncheckedCreateWithoutUserrolesInput>
    connectOrCreate?: userCreateOrConnectWithoutUserrolesInput
    upsert?: userUpsertWithoutUserrolesInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUserrolesInput, userUpdateWithoutUserrolesInput>, userUncheckedUpdateWithoutUserrolesInput>
  }

  export type invoiceCreateNestedManyWithoutUserInput = {
    create?: XOR<invoiceCreateWithoutUserInput, invoiceUncheckedCreateWithoutUserInput> | invoiceCreateWithoutUserInput[] | invoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: invoiceCreateOrConnectWithoutUserInput | invoiceCreateOrConnectWithoutUserInput[]
    createMany?: invoiceCreateManyUserInputEnvelope
    connect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
  }

  export type subscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<subscriptionCreateWithoutUserInput, subscriptionUncheckedCreateWithoutUserInput> | subscriptionCreateWithoutUserInput[] | subscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: subscriptionCreateOrConnectWithoutUserInput | subscriptionCreateOrConnectWithoutUserInput[]
    createMany?: subscriptionCreateManyUserInputEnvelope
    connect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
  }

  export type customerCreateNestedManyWithoutUserInput = {
    create?: XOR<customerCreateWithoutUserInput, customerUncheckedCreateWithoutUserInput> | customerCreateWithoutUserInput[] | customerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: customerCreateOrConnectWithoutUserInput | customerCreateOrConnectWithoutUserInput[]
    createMany?: customerCreateManyUserInputEnvelope
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
  }

  export type parametersCreateNestedManyWithoutUserInput = {
    create?: XOR<parametersCreateWithoutUserInput, parametersUncheckedCreateWithoutUserInput> | parametersCreateWithoutUserInput[] | parametersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: parametersCreateOrConnectWithoutUserInput | parametersCreateOrConnectWithoutUserInput[]
    createMany?: parametersCreateManyUserInputEnvelope
    connect?: parametersWhereUniqueInput | parametersWhereUniqueInput[]
  }

  export type entranceCreateNestedManyWithoutUserInput = {
    create?: XOR<entranceCreateWithoutUserInput, entranceUncheckedCreateWithoutUserInput> | entranceCreateWithoutUserInput[] | entranceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: entranceCreateOrConnectWithoutUserInput | entranceCreateOrConnectWithoutUserInput[]
    createMany?: entranceCreateManyUserInputEnvelope
    connect?: entranceWhereUniqueInput | entranceWhereUniqueInput[]
  }

  export type paymentCreateNestedManyWithoutUserInput = {
    create?: XOR<paymentCreateWithoutUserInput, paymentUncheckedCreateWithoutUserInput> | paymentCreateWithoutUserInput[] | paymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutUserInput | paymentCreateOrConnectWithoutUserInput[]
    createMany?: paymentCreateManyUserInputEnvelope
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
  }

  export type planCreateNestedOneWithoutUsersInput = {
    create?: XOR<planCreateWithoutUsersInput, planUncheckedCreateWithoutUsersInput>
    connectOrCreate?: planCreateOrConnectWithoutUsersInput
    connect?: planWhereUniqueInput
  }

  export type transactionCreateNestedManyWithoutUserInput = {
    create?: XOR<transactionCreateWithoutUserInput, transactionUncheckedCreateWithoutUserInput> | transactionCreateWithoutUserInput[] | transactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutUserInput | transactionCreateOrConnectWithoutUserInput[]
    createMany?: transactionCreateManyUserInputEnvelope
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
  }

  export type notificationCreateNestedManyWithoutToInput = {
    create?: XOR<notificationCreateWithoutToInput, notificationUncheckedCreateWithoutToInput> | notificationCreateWithoutToInput[] | notificationUncheckedCreateWithoutToInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutToInput | notificationCreateOrConnectWithoutToInput[]
    createMany?: notificationCreateManyToInputEnvelope
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
  }

  export type apiclientCreateNestedManyWithoutCreateduserInput = {
    create?: XOR<apiclientCreateWithoutCreateduserInput, apiclientUncheckedCreateWithoutCreateduserInput> | apiclientCreateWithoutCreateduserInput[] | apiclientUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: apiclientCreateOrConnectWithoutCreateduserInput | apiclientCreateOrConnectWithoutCreateduserInput[]
    createMany?: apiclientCreateManyCreateduserInputEnvelope
    connect?: apiclientWhereUniqueInput | apiclientWhereUniqueInput[]
  }

  export type apiclientCreateNestedManyWithoutUpdateduserInput = {
    create?: XOR<apiclientCreateWithoutUpdateduserInput, apiclientUncheckedCreateWithoutUpdateduserInput> | apiclientCreateWithoutUpdateduserInput[] | apiclientUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: apiclientCreateOrConnectWithoutUpdateduserInput | apiclientCreateOrConnectWithoutUpdateduserInput[]
    createMany?: apiclientCreateManyUpdateduserInputEnvelope
    connect?: apiclientWhereUniqueInput | apiclientWhereUniqueInput[]
  }

  export type permissionCreateNestedManyWithoutCreateduserInput = {
    create?: XOR<permissionCreateWithoutCreateduserInput, permissionUncheckedCreateWithoutCreateduserInput> | permissionCreateWithoutCreateduserInput[] | permissionUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: permissionCreateOrConnectWithoutCreateduserInput | permissionCreateOrConnectWithoutCreateduserInput[]
    createMany?: permissionCreateManyCreateduserInputEnvelope
    connect?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
  }

  export type permissionCreateNestedManyWithoutUpdateduserInput = {
    create?: XOR<permissionCreateWithoutUpdateduserInput, permissionUncheckedCreateWithoutUpdateduserInput> | permissionCreateWithoutUpdateduserInput[] | permissionUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: permissionCreateOrConnectWithoutUpdateduserInput | permissionCreateOrConnectWithoutUpdateduserInput[]
    createMany?: permissionCreateManyUpdateduserInputEnvelope
    connect?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
  }

  export type refreshtokenCreateNestedManyWithoutUserInput = {
    create?: XOR<refreshtokenCreateWithoutUserInput, refreshtokenUncheckedCreateWithoutUserInput> | refreshtokenCreateWithoutUserInput[] | refreshtokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: refreshtokenCreateOrConnectWithoutUserInput | refreshtokenCreateOrConnectWithoutUserInput[]
    createMany?: refreshtokenCreateManyUserInputEnvelope
    connect?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
  }

  export type roleCreateNestedManyWithoutCreateduserInput = {
    create?: XOR<roleCreateWithoutCreateduserInput, roleUncheckedCreateWithoutCreateduserInput> | roleCreateWithoutCreateduserInput[] | roleUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: roleCreateOrConnectWithoutCreateduserInput | roleCreateOrConnectWithoutCreateduserInput[]
    createMany?: roleCreateManyCreateduserInputEnvelope
    connect?: roleWhereUniqueInput | roleWhereUniqueInput[]
  }

  export type roleCreateNestedManyWithoutUpdateduserInput = {
    create?: XOR<roleCreateWithoutUpdateduserInput, roleUncheckedCreateWithoutUpdateduserInput> | roleCreateWithoutUpdateduserInput[] | roleUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: roleCreateOrConnectWithoutUpdateduserInput | roleCreateOrConnectWithoutUpdateduserInput[]
    createMany?: roleCreateManyUpdateduserInputEnvelope
    connect?: roleWhereUniqueInput | roleWhereUniqueInput[]
  }

  export type rolepermissionCreateNestedManyWithoutCreateduserInput = {
    create?: XOR<rolepermissionCreateWithoutCreateduserInput, rolepermissionUncheckedCreateWithoutCreateduserInput> | rolepermissionCreateWithoutCreateduserInput[] | rolepermissionUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: rolepermissionCreateOrConnectWithoutCreateduserInput | rolepermissionCreateOrConnectWithoutCreateduserInput[]
    createMany?: rolepermissionCreateManyCreateduserInputEnvelope
    connect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
  }

  export type rolepermissionCreateNestedManyWithoutUpdateduserInput = {
    create?: XOR<rolepermissionCreateWithoutUpdateduserInput, rolepermissionUncheckedCreateWithoutUpdateduserInput> | rolepermissionCreateWithoutUpdateduserInput[] | rolepermissionUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: rolepermissionCreateOrConnectWithoutUpdateduserInput | rolepermissionCreateOrConnectWithoutUpdateduserInput[]
    createMany?: rolepermissionCreateManyUpdateduserInputEnvelope
    connect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
  }

  export type userCreateNestedOneWithoutCreatedusersInput = {
    create?: XOR<userCreateWithoutCreatedusersInput, userUncheckedCreateWithoutCreatedusersInput>
    connectOrCreate?: userCreateOrConnectWithoutCreatedusersInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedManyWithoutCreateduserInput = {
    create?: XOR<userCreateWithoutCreateduserInput, userUncheckedCreateWithoutCreateduserInput> | userCreateWithoutCreateduserInput[] | userUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: userCreateOrConnectWithoutCreateduserInput | userCreateOrConnectWithoutCreateduserInput[]
    createMany?: userCreateManyCreateduserInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type userCreateNestedOneWithoutUpdatedusersInput = {
    create?: XOR<userCreateWithoutUpdatedusersInput, userUncheckedCreateWithoutUpdatedusersInput>
    connectOrCreate?: userCreateOrConnectWithoutUpdatedusersInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedManyWithoutUpdateduserInput = {
    create?: XOR<userCreateWithoutUpdateduserInput, userUncheckedCreateWithoutUpdateduserInput> | userCreateWithoutUpdateduserInput[] | userUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: userCreateOrConnectWithoutUpdateduserInput | userCreateOrConnectWithoutUpdateduserInput[]
    createMany?: userCreateManyUpdateduserInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type userpermissionCreateNestedManyWithoutCreateduserInput = {
    create?: XOR<userpermissionCreateWithoutCreateduserInput, userpermissionUncheckedCreateWithoutCreateduserInput> | userpermissionCreateWithoutCreateduserInput[] | userpermissionUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: userpermissionCreateOrConnectWithoutCreateduserInput | userpermissionCreateOrConnectWithoutCreateduserInput[]
    createMany?: userpermissionCreateManyCreateduserInputEnvelope
    connect?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
  }

  export type userpermissionCreateNestedManyWithoutUpdateduserInput = {
    create?: XOR<userpermissionCreateWithoutUpdateduserInput, userpermissionUncheckedCreateWithoutUpdateduserInput> | userpermissionCreateWithoutUpdateduserInput[] | userpermissionUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: userpermissionCreateOrConnectWithoutUpdateduserInput | userpermissionCreateOrConnectWithoutUpdateduserInput[]
    createMany?: userpermissionCreateManyUpdateduserInputEnvelope
    connect?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
  }

  export type userpermissionCreateNestedManyWithoutUserInput = {
    create?: XOR<userpermissionCreateWithoutUserInput, userpermissionUncheckedCreateWithoutUserInput> | userpermissionCreateWithoutUserInput[] | userpermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userpermissionCreateOrConnectWithoutUserInput | userpermissionCreateOrConnectWithoutUserInput[]
    createMany?: userpermissionCreateManyUserInputEnvelope
    connect?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
  }

  export type userroleCreateNestedManyWithoutCreateduserInput = {
    create?: XOR<userroleCreateWithoutCreateduserInput, userroleUncheckedCreateWithoutCreateduserInput> | userroleCreateWithoutCreateduserInput[] | userroleUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutCreateduserInput | userroleCreateOrConnectWithoutCreateduserInput[]
    createMany?: userroleCreateManyCreateduserInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type userroleCreateNestedManyWithoutUpdateduserInput = {
    create?: XOR<userroleCreateWithoutUpdateduserInput, userroleUncheckedCreateWithoutUpdateduserInput> | userroleCreateWithoutUpdateduserInput[] | userroleUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUpdateduserInput | userroleCreateOrConnectWithoutUpdateduserInput[]
    createMany?: userroleCreateManyUpdateduserInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type userroleCreateNestedManyWithoutUserInput = {
    create?: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput> | userroleCreateWithoutUserInput[] | userroleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUserInput | userroleCreateOrConnectWithoutUserInput[]
    createMany?: userroleCreateManyUserInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type invoiceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<invoiceCreateWithoutUserInput, invoiceUncheckedCreateWithoutUserInput> | invoiceCreateWithoutUserInput[] | invoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: invoiceCreateOrConnectWithoutUserInput | invoiceCreateOrConnectWithoutUserInput[]
    createMany?: invoiceCreateManyUserInputEnvelope
    connect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
  }

  export type subscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<subscriptionCreateWithoutUserInput, subscriptionUncheckedCreateWithoutUserInput> | subscriptionCreateWithoutUserInput[] | subscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: subscriptionCreateOrConnectWithoutUserInput | subscriptionCreateOrConnectWithoutUserInput[]
    createMany?: subscriptionCreateManyUserInputEnvelope
    connect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
  }

  export type customerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<customerCreateWithoutUserInput, customerUncheckedCreateWithoutUserInput> | customerCreateWithoutUserInput[] | customerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: customerCreateOrConnectWithoutUserInput | customerCreateOrConnectWithoutUserInput[]
    createMany?: customerCreateManyUserInputEnvelope
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
  }

  export type parametersUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<parametersCreateWithoutUserInput, parametersUncheckedCreateWithoutUserInput> | parametersCreateWithoutUserInput[] | parametersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: parametersCreateOrConnectWithoutUserInput | parametersCreateOrConnectWithoutUserInput[]
    createMany?: parametersCreateManyUserInputEnvelope
    connect?: parametersWhereUniqueInput | parametersWhereUniqueInput[]
  }

  export type entranceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<entranceCreateWithoutUserInput, entranceUncheckedCreateWithoutUserInput> | entranceCreateWithoutUserInput[] | entranceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: entranceCreateOrConnectWithoutUserInput | entranceCreateOrConnectWithoutUserInput[]
    createMany?: entranceCreateManyUserInputEnvelope
    connect?: entranceWhereUniqueInput | entranceWhereUniqueInput[]
  }

  export type paymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<paymentCreateWithoutUserInput, paymentUncheckedCreateWithoutUserInput> | paymentCreateWithoutUserInput[] | paymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutUserInput | paymentCreateOrConnectWithoutUserInput[]
    createMany?: paymentCreateManyUserInputEnvelope
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
  }

  export type transactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<transactionCreateWithoutUserInput, transactionUncheckedCreateWithoutUserInput> | transactionCreateWithoutUserInput[] | transactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutUserInput | transactionCreateOrConnectWithoutUserInput[]
    createMany?: transactionCreateManyUserInputEnvelope
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
  }

  export type notificationUncheckedCreateNestedManyWithoutToInput = {
    create?: XOR<notificationCreateWithoutToInput, notificationUncheckedCreateWithoutToInput> | notificationCreateWithoutToInput[] | notificationUncheckedCreateWithoutToInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutToInput | notificationCreateOrConnectWithoutToInput[]
    createMany?: notificationCreateManyToInputEnvelope
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
  }

  export type apiclientUncheckedCreateNestedManyWithoutCreateduserInput = {
    create?: XOR<apiclientCreateWithoutCreateduserInput, apiclientUncheckedCreateWithoutCreateduserInput> | apiclientCreateWithoutCreateduserInput[] | apiclientUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: apiclientCreateOrConnectWithoutCreateduserInput | apiclientCreateOrConnectWithoutCreateduserInput[]
    createMany?: apiclientCreateManyCreateduserInputEnvelope
    connect?: apiclientWhereUniqueInput | apiclientWhereUniqueInput[]
  }

  export type apiclientUncheckedCreateNestedManyWithoutUpdateduserInput = {
    create?: XOR<apiclientCreateWithoutUpdateduserInput, apiclientUncheckedCreateWithoutUpdateduserInput> | apiclientCreateWithoutUpdateduserInput[] | apiclientUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: apiclientCreateOrConnectWithoutUpdateduserInput | apiclientCreateOrConnectWithoutUpdateduserInput[]
    createMany?: apiclientCreateManyUpdateduserInputEnvelope
    connect?: apiclientWhereUniqueInput | apiclientWhereUniqueInput[]
  }

  export type permissionUncheckedCreateNestedManyWithoutCreateduserInput = {
    create?: XOR<permissionCreateWithoutCreateduserInput, permissionUncheckedCreateWithoutCreateduserInput> | permissionCreateWithoutCreateduserInput[] | permissionUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: permissionCreateOrConnectWithoutCreateduserInput | permissionCreateOrConnectWithoutCreateduserInput[]
    createMany?: permissionCreateManyCreateduserInputEnvelope
    connect?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
  }

  export type permissionUncheckedCreateNestedManyWithoutUpdateduserInput = {
    create?: XOR<permissionCreateWithoutUpdateduserInput, permissionUncheckedCreateWithoutUpdateduserInput> | permissionCreateWithoutUpdateduserInput[] | permissionUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: permissionCreateOrConnectWithoutUpdateduserInput | permissionCreateOrConnectWithoutUpdateduserInput[]
    createMany?: permissionCreateManyUpdateduserInputEnvelope
    connect?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
  }

  export type refreshtokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<refreshtokenCreateWithoutUserInput, refreshtokenUncheckedCreateWithoutUserInput> | refreshtokenCreateWithoutUserInput[] | refreshtokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: refreshtokenCreateOrConnectWithoutUserInput | refreshtokenCreateOrConnectWithoutUserInput[]
    createMany?: refreshtokenCreateManyUserInputEnvelope
    connect?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
  }

  export type roleUncheckedCreateNestedManyWithoutCreateduserInput = {
    create?: XOR<roleCreateWithoutCreateduserInput, roleUncheckedCreateWithoutCreateduserInput> | roleCreateWithoutCreateduserInput[] | roleUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: roleCreateOrConnectWithoutCreateduserInput | roleCreateOrConnectWithoutCreateduserInput[]
    createMany?: roleCreateManyCreateduserInputEnvelope
    connect?: roleWhereUniqueInput | roleWhereUniqueInput[]
  }

  export type roleUncheckedCreateNestedManyWithoutUpdateduserInput = {
    create?: XOR<roleCreateWithoutUpdateduserInput, roleUncheckedCreateWithoutUpdateduserInput> | roleCreateWithoutUpdateduserInput[] | roleUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: roleCreateOrConnectWithoutUpdateduserInput | roleCreateOrConnectWithoutUpdateduserInput[]
    createMany?: roleCreateManyUpdateduserInputEnvelope
    connect?: roleWhereUniqueInput | roleWhereUniqueInput[]
  }

  export type rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput = {
    create?: XOR<rolepermissionCreateWithoutCreateduserInput, rolepermissionUncheckedCreateWithoutCreateduserInput> | rolepermissionCreateWithoutCreateduserInput[] | rolepermissionUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: rolepermissionCreateOrConnectWithoutCreateduserInput | rolepermissionCreateOrConnectWithoutCreateduserInput[]
    createMany?: rolepermissionCreateManyCreateduserInputEnvelope
    connect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
  }

  export type rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput = {
    create?: XOR<rolepermissionCreateWithoutUpdateduserInput, rolepermissionUncheckedCreateWithoutUpdateduserInput> | rolepermissionCreateWithoutUpdateduserInput[] | rolepermissionUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: rolepermissionCreateOrConnectWithoutUpdateduserInput | rolepermissionCreateOrConnectWithoutUpdateduserInput[]
    createMany?: rolepermissionCreateManyUpdateduserInputEnvelope
    connect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
  }

  export type userUncheckedCreateNestedManyWithoutCreateduserInput = {
    create?: XOR<userCreateWithoutCreateduserInput, userUncheckedCreateWithoutCreateduserInput> | userCreateWithoutCreateduserInput[] | userUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: userCreateOrConnectWithoutCreateduserInput | userCreateOrConnectWithoutCreateduserInput[]
    createMany?: userCreateManyCreateduserInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type userUncheckedCreateNestedManyWithoutUpdateduserInput = {
    create?: XOR<userCreateWithoutUpdateduserInput, userUncheckedCreateWithoutUpdateduserInput> | userCreateWithoutUpdateduserInput[] | userUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: userCreateOrConnectWithoutUpdateduserInput | userCreateOrConnectWithoutUpdateduserInput[]
    createMany?: userCreateManyUpdateduserInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type userpermissionUncheckedCreateNestedManyWithoutCreateduserInput = {
    create?: XOR<userpermissionCreateWithoutCreateduserInput, userpermissionUncheckedCreateWithoutCreateduserInput> | userpermissionCreateWithoutCreateduserInput[] | userpermissionUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: userpermissionCreateOrConnectWithoutCreateduserInput | userpermissionCreateOrConnectWithoutCreateduserInput[]
    createMany?: userpermissionCreateManyCreateduserInputEnvelope
    connect?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
  }

  export type userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput = {
    create?: XOR<userpermissionCreateWithoutUpdateduserInput, userpermissionUncheckedCreateWithoutUpdateduserInput> | userpermissionCreateWithoutUpdateduserInput[] | userpermissionUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: userpermissionCreateOrConnectWithoutUpdateduserInput | userpermissionCreateOrConnectWithoutUpdateduserInput[]
    createMany?: userpermissionCreateManyUpdateduserInputEnvelope
    connect?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
  }

  export type userpermissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<userpermissionCreateWithoutUserInput, userpermissionUncheckedCreateWithoutUserInput> | userpermissionCreateWithoutUserInput[] | userpermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userpermissionCreateOrConnectWithoutUserInput | userpermissionCreateOrConnectWithoutUserInput[]
    createMany?: userpermissionCreateManyUserInputEnvelope
    connect?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
  }

  export type userroleUncheckedCreateNestedManyWithoutCreateduserInput = {
    create?: XOR<userroleCreateWithoutCreateduserInput, userroleUncheckedCreateWithoutCreateduserInput> | userroleCreateWithoutCreateduserInput[] | userroleUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutCreateduserInput | userroleCreateOrConnectWithoutCreateduserInput[]
    createMany?: userroleCreateManyCreateduserInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type userroleUncheckedCreateNestedManyWithoutUpdateduserInput = {
    create?: XOR<userroleCreateWithoutUpdateduserInput, userroleUncheckedCreateWithoutUpdateduserInput> | userroleCreateWithoutUpdateduserInput[] | userroleUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUpdateduserInput | userroleCreateOrConnectWithoutUpdateduserInput[]
    createMany?: userroleCreateManyUpdateduserInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type userroleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput> | userroleCreateWithoutUserInput[] | userroleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUserInput | userroleCreateOrConnectWithoutUserInput[]
    createMany?: userroleCreateManyUserInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type invoiceUpdateManyWithoutUserNestedInput = {
    create?: XOR<invoiceCreateWithoutUserInput, invoiceUncheckedCreateWithoutUserInput> | invoiceCreateWithoutUserInput[] | invoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: invoiceCreateOrConnectWithoutUserInput | invoiceCreateOrConnectWithoutUserInput[]
    upsert?: invoiceUpsertWithWhereUniqueWithoutUserInput | invoiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: invoiceCreateManyUserInputEnvelope
    set?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    disconnect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    delete?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    connect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    update?: invoiceUpdateWithWhereUniqueWithoutUserInput | invoiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: invoiceUpdateManyWithWhereWithoutUserInput | invoiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: invoiceScalarWhereInput | invoiceScalarWhereInput[]
  }

  export type subscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<subscriptionCreateWithoutUserInput, subscriptionUncheckedCreateWithoutUserInput> | subscriptionCreateWithoutUserInput[] | subscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: subscriptionCreateOrConnectWithoutUserInput | subscriptionCreateOrConnectWithoutUserInput[]
    upsert?: subscriptionUpsertWithWhereUniqueWithoutUserInput | subscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: subscriptionCreateManyUserInputEnvelope
    set?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    disconnect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    delete?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    connect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    update?: subscriptionUpdateWithWhereUniqueWithoutUserInput | subscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: subscriptionUpdateManyWithWhereWithoutUserInput | subscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: subscriptionScalarWhereInput | subscriptionScalarWhereInput[]
  }

  export type customerUpdateManyWithoutUserNestedInput = {
    create?: XOR<customerCreateWithoutUserInput, customerUncheckedCreateWithoutUserInput> | customerCreateWithoutUserInput[] | customerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: customerCreateOrConnectWithoutUserInput | customerCreateOrConnectWithoutUserInput[]
    upsert?: customerUpsertWithWhereUniqueWithoutUserInput | customerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: customerCreateManyUserInputEnvelope
    set?: customerWhereUniqueInput | customerWhereUniqueInput[]
    disconnect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    delete?: customerWhereUniqueInput | customerWhereUniqueInput[]
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    update?: customerUpdateWithWhereUniqueWithoutUserInput | customerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: customerUpdateManyWithWhereWithoutUserInput | customerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: customerScalarWhereInput | customerScalarWhereInput[]
  }

  export type parametersUpdateManyWithoutUserNestedInput = {
    create?: XOR<parametersCreateWithoutUserInput, parametersUncheckedCreateWithoutUserInput> | parametersCreateWithoutUserInput[] | parametersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: parametersCreateOrConnectWithoutUserInput | parametersCreateOrConnectWithoutUserInput[]
    upsert?: parametersUpsertWithWhereUniqueWithoutUserInput | parametersUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: parametersCreateManyUserInputEnvelope
    set?: parametersWhereUniqueInput | parametersWhereUniqueInput[]
    disconnect?: parametersWhereUniqueInput | parametersWhereUniqueInput[]
    delete?: parametersWhereUniqueInput | parametersWhereUniqueInput[]
    connect?: parametersWhereUniqueInput | parametersWhereUniqueInput[]
    update?: parametersUpdateWithWhereUniqueWithoutUserInput | parametersUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: parametersUpdateManyWithWhereWithoutUserInput | parametersUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: parametersScalarWhereInput | parametersScalarWhereInput[]
  }

  export type entranceUpdateManyWithoutUserNestedInput = {
    create?: XOR<entranceCreateWithoutUserInput, entranceUncheckedCreateWithoutUserInput> | entranceCreateWithoutUserInput[] | entranceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: entranceCreateOrConnectWithoutUserInput | entranceCreateOrConnectWithoutUserInput[]
    upsert?: entranceUpsertWithWhereUniqueWithoutUserInput | entranceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: entranceCreateManyUserInputEnvelope
    set?: entranceWhereUniqueInput | entranceWhereUniqueInput[]
    disconnect?: entranceWhereUniqueInput | entranceWhereUniqueInput[]
    delete?: entranceWhereUniqueInput | entranceWhereUniqueInput[]
    connect?: entranceWhereUniqueInput | entranceWhereUniqueInput[]
    update?: entranceUpdateWithWhereUniqueWithoutUserInput | entranceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: entranceUpdateManyWithWhereWithoutUserInput | entranceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: entranceScalarWhereInput | entranceScalarWhereInput[]
  }

  export type paymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<paymentCreateWithoutUserInput, paymentUncheckedCreateWithoutUserInput> | paymentCreateWithoutUserInput[] | paymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutUserInput | paymentCreateOrConnectWithoutUserInput[]
    upsert?: paymentUpsertWithWhereUniqueWithoutUserInput | paymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: paymentCreateManyUserInputEnvelope
    set?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    disconnect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    delete?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    update?: paymentUpdateWithWhereUniqueWithoutUserInput | paymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: paymentUpdateManyWithWhereWithoutUserInput | paymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: paymentScalarWhereInput | paymentScalarWhereInput[]
  }

  export type planUpdateOneWithoutUsersNestedInput = {
    create?: XOR<planCreateWithoutUsersInput, planUncheckedCreateWithoutUsersInput>
    connectOrCreate?: planCreateOrConnectWithoutUsersInput
    upsert?: planUpsertWithoutUsersInput
    disconnect?: planWhereInput | boolean
    delete?: planWhereInput | boolean
    connect?: planWhereUniqueInput
    update?: XOR<XOR<planUpdateToOneWithWhereWithoutUsersInput, planUpdateWithoutUsersInput>, planUncheckedUpdateWithoutUsersInput>
  }

  export type transactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<transactionCreateWithoutUserInput, transactionUncheckedCreateWithoutUserInput> | transactionCreateWithoutUserInput[] | transactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutUserInput | transactionCreateOrConnectWithoutUserInput[]
    upsert?: transactionUpsertWithWhereUniqueWithoutUserInput | transactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: transactionCreateManyUserInputEnvelope
    set?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    disconnect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    delete?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    update?: transactionUpdateWithWhereUniqueWithoutUserInput | transactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: transactionUpdateManyWithWhereWithoutUserInput | transactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: transactionScalarWhereInput | transactionScalarWhereInput[]
  }

  export type notificationUpdateManyWithoutToNestedInput = {
    create?: XOR<notificationCreateWithoutToInput, notificationUncheckedCreateWithoutToInput> | notificationCreateWithoutToInput[] | notificationUncheckedCreateWithoutToInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutToInput | notificationCreateOrConnectWithoutToInput[]
    upsert?: notificationUpsertWithWhereUniqueWithoutToInput | notificationUpsertWithWhereUniqueWithoutToInput[]
    createMany?: notificationCreateManyToInputEnvelope
    set?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    disconnect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    delete?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    update?: notificationUpdateWithWhereUniqueWithoutToInput | notificationUpdateWithWhereUniqueWithoutToInput[]
    updateMany?: notificationUpdateManyWithWhereWithoutToInput | notificationUpdateManyWithWhereWithoutToInput[]
    deleteMany?: notificationScalarWhereInput | notificationScalarWhereInput[]
  }

  export type apiclientUpdateManyWithoutCreateduserNestedInput = {
    create?: XOR<apiclientCreateWithoutCreateduserInput, apiclientUncheckedCreateWithoutCreateduserInput> | apiclientCreateWithoutCreateduserInput[] | apiclientUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: apiclientCreateOrConnectWithoutCreateduserInput | apiclientCreateOrConnectWithoutCreateduserInput[]
    upsert?: apiclientUpsertWithWhereUniqueWithoutCreateduserInput | apiclientUpsertWithWhereUniqueWithoutCreateduserInput[]
    createMany?: apiclientCreateManyCreateduserInputEnvelope
    set?: apiclientWhereUniqueInput | apiclientWhereUniqueInput[]
    disconnect?: apiclientWhereUniqueInput | apiclientWhereUniqueInput[]
    delete?: apiclientWhereUniqueInput | apiclientWhereUniqueInput[]
    connect?: apiclientWhereUniqueInput | apiclientWhereUniqueInput[]
    update?: apiclientUpdateWithWhereUniqueWithoutCreateduserInput | apiclientUpdateWithWhereUniqueWithoutCreateduserInput[]
    updateMany?: apiclientUpdateManyWithWhereWithoutCreateduserInput | apiclientUpdateManyWithWhereWithoutCreateduserInput[]
    deleteMany?: apiclientScalarWhereInput | apiclientScalarWhereInput[]
  }

  export type apiclientUpdateManyWithoutUpdateduserNestedInput = {
    create?: XOR<apiclientCreateWithoutUpdateduserInput, apiclientUncheckedCreateWithoutUpdateduserInput> | apiclientCreateWithoutUpdateduserInput[] | apiclientUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: apiclientCreateOrConnectWithoutUpdateduserInput | apiclientCreateOrConnectWithoutUpdateduserInput[]
    upsert?: apiclientUpsertWithWhereUniqueWithoutUpdateduserInput | apiclientUpsertWithWhereUniqueWithoutUpdateduserInput[]
    createMany?: apiclientCreateManyUpdateduserInputEnvelope
    set?: apiclientWhereUniqueInput | apiclientWhereUniqueInput[]
    disconnect?: apiclientWhereUniqueInput | apiclientWhereUniqueInput[]
    delete?: apiclientWhereUniqueInput | apiclientWhereUniqueInput[]
    connect?: apiclientWhereUniqueInput | apiclientWhereUniqueInput[]
    update?: apiclientUpdateWithWhereUniqueWithoutUpdateduserInput | apiclientUpdateWithWhereUniqueWithoutUpdateduserInput[]
    updateMany?: apiclientUpdateManyWithWhereWithoutUpdateduserInput | apiclientUpdateManyWithWhereWithoutUpdateduserInput[]
    deleteMany?: apiclientScalarWhereInput | apiclientScalarWhereInput[]
  }

  export type permissionUpdateManyWithoutCreateduserNestedInput = {
    create?: XOR<permissionCreateWithoutCreateduserInput, permissionUncheckedCreateWithoutCreateduserInput> | permissionCreateWithoutCreateduserInput[] | permissionUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: permissionCreateOrConnectWithoutCreateduserInput | permissionCreateOrConnectWithoutCreateduserInput[]
    upsert?: permissionUpsertWithWhereUniqueWithoutCreateduserInput | permissionUpsertWithWhereUniqueWithoutCreateduserInput[]
    createMany?: permissionCreateManyCreateduserInputEnvelope
    set?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
    disconnect?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
    delete?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
    connect?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
    update?: permissionUpdateWithWhereUniqueWithoutCreateduserInput | permissionUpdateWithWhereUniqueWithoutCreateduserInput[]
    updateMany?: permissionUpdateManyWithWhereWithoutCreateduserInput | permissionUpdateManyWithWhereWithoutCreateduserInput[]
    deleteMany?: permissionScalarWhereInput | permissionScalarWhereInput[]
  }

  export type permissionUpdateManyWithoutUpdateduserNestedInput = {
    create?: XOR<permissionCreateWithoutUpdateduserInput, permissionUncheckedCreateWithoutUpdateduserInput> | permissionCreateWithoutUpdateduserInput[] | permissionUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: permissionCreateOrConnectWithoutUpdateduserInput | permissionCreateOrConnectWithoutUpdateduserInput[]
    upsert?: permissionUpsertWithWhereUniqueWithoutUpdateduserInput | permissionUpsertWithWhereUniqueWithoutUpdateduserInput[]
    createMany?: permissionCreateManyUpdateduserInputEnvelope
    set?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
    disconnect?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
    delete?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
    connect?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
    update?: permissionUpdateWithWhereUniqueWithoutUpdateduserInput | permissionUpdateWithWhereUniqueWithoutUpdateduserInput[]
    updateMany?: permissionUpdateManyWithWhereWithoutUpdateduserInput | permissionUpdateManyWithWhereWithoutUpdateduserInput[]
    deleteMany?: permissionScalarWhereInput | permissionScalarWhereInput[]
  }

  export type refreshtokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<refreshtokenCreateWithoutUserInput, refreshtokenUncheckedCreateWithoutUserInput> | refreshtokenCreateWithoutUserInput[] | refreshtokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: refreshtokenCreateOrConnectWithoutUserInput | refreshtokenCreateOrConnectWithoutUserInput[]
    upsert?: refreshtokenUpsertWithWhereUniqueWithoutUserInput | refreshtokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: refreshtokenCreateManyUserInputEnvelope
    set?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    disconnect?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    delete?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    connect?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    update?: refreshtokenUpdateWithWhereUniqueWithoutUserInput | refreshtokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: refreshtokenUpdateManyWithWhereWithoutUserInput | refreshtokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: refreshtokenScalarWhereInput | refreshtokenScalarWhereInput[]
  }

  export type roleUpdateManyWithoutCreateduserNestedInput = {
    create?: XOR<roleCreateWithoutCreateduserInput, roleUncheckedCreateWithoutCreateduserInput> | roleCreateWithoutCreateduserInput[] | roleUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: roleCreateOrConnectWithoutCreateduserInput | roleCreateOrConnectWithoutCreateduserInput[]
    upsert?: roleUpsertWithWhereUniqueWithoutCreateduserInput | roleUpsertWithWhereUniqueWithoutCreateduserInput[]
    createMany?: roleCreateManyCreateduserInputEnvelope
    set?: roleWhereUniqueInput | roleWhereUniqueInput[]
    disconnect?: roleWhereUniqueInput | roleWhereUniqueInput[]
    delete?: roleWhereUniqueInput | roleWhereUniqueInput[]
    connect?: roleWhereUniqueInput | roleWhereUniqueInput[]
    update?: roleUpdateWithWhereUniqueWithoutCreateduserInput | roleUpdateWithWhereUniqueWithoutCreateduserInput[]
    updateMany?: roleUpdateManyWithWhereWithoutCreateduserInput | roleUpdateManyWithWhereWithoutCreateduserInput[]
    deleteMany?: roleScalarWhereInput | roleScalarWhereInput[]
  }

  export type roleUpdateManyWithoutUpdateduserNestedInput = {
    create?: XOR<roleCreateWithoutUpdateduserInput, roleUncheckedCreateWithoutUpdateduserInput> | roleCreateWithoutUpdateduserInput[] | roleUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: roleCreateOrConnectWithoutUpdateduserInput | roleCreateOrConnectWithoutUpdateduserInput[]
    upsert?: roleUpsertWithWhereUniqueWithoutUpdateduserInput | roleUpsertWithWhereUniqueWithoutUpdateduserInput[]
    createMany?: roleCreateManyUpdateduserInputEnvelope
    set?: roleWhereUniqueInput | roleWhereUniqueInput[]
    disconnect?: roleWhereUniqueInput | roleWhereUniqueInput[]
    delete?: roleWhereUniqueInput | roleWhereUniqueInput[]
    connect?: roleWhereUniqueInput | roleWhereUniqueInput[]
    update?: roleUpdateWithWhereUniqueWithoutUpdateduserInput | roleUpdateWithWhereUniqueWithoutUpdateduserInput[]
    updateMany?: roleUpdateManyWithWhereWithoutUpdateduserInput | roleUpdateManyWithWhereWithoutUpdateduserInput[]
    deleteMany?: roleScalarWhereInput | roleScalarWhereInput[]
  }

  export type rolepermissionUpdateManyWithoutCreateduserNestedInput = {
    create?: XOR<rolepermissionCreateWithoutCreateduserInput, rolepermissionUncheckedCreateWithoutCreateduserInput> | rolepermissionCreateWithoutCreateduserInput[] | rolepermissionUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: rolepermissionCreateOrConnectWithoutCreateduserInput | rolepermissionCreateOrConnectWithoutCreateduserInput[]
    upsert?: rolepermissionUpsertWithWhereUniqueWithoutCreateduserInput | rolepermissionUpsertWithWhereUniqueWithoutCreateduserInput[]
    createMany?: rolepermissionCreateManyCreateduserInputEnvelope
    set?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    disconnect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    delete?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    connect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    update?: rolepermissionUpdateWithWhereUniqueWithoutCreateduserInput | rolepermissionUpdateWithWhereUniqueWithoutCreateduserInput[]
    updateMany?: rolepermissionUpdateManyWithWhereWithoutCreateduserInput | rolepermissionUpdateManyWithWhereWithoutCreateduserInput[]
    deleteMany?: rolepermissionScalarWhereInput | rolepermissionScalarWhereInput[]
  }

  export type rolepermissionUpdateManyWithoutUpdateduserNestedInput = {
    create?: XOR<rolepermissionCreateWithoutUpdateduserInput, rolepermissionUncheckedCreateWithoutUpdateduserInput> | rolepermissionCreateWithoutUpdateduserInput[] | rolepermissionUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: rolepermissionCreateOrConnectWithoutUpdateduserInput | rolepermissionCreateOrConnectWithoutUpdateduserInput[]
    upsert?: rolepermissionUpsertWithWhereUniqueWithoutUpdateduserInput | rolepermissionUpsertWithWhereUniqueWithoutUpdateduserInput[]
    createMany?: rolepermissionCreateManyUpdateduserInputEnvelope
    set?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    disconnect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    delete?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    connect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    update?: rolepermissionUpdateWithWhereUniqueWithoutUpdateduserInput | rolepermissionUpdateWithWhereUniqueWithoutUpdateduserInput[]
    updateMany?: rolepermissionUpdateManyWithWhereWithoutUpdateduserInput | rolepermissionUpdateManyWithWhereWithoutUpdateduserInput[]
    deleteMany?: rolepermissionScalarWhereInput | rolepermissionScalarWhereInput[]
  }

  export type userUpdateOneRequiredWithoutCreatedusersNestedInput = {
    create?: XOR<userCreateWithoutCreatedusersInput, userUncheckedCreateWithoutCreatedusersInput>
    connectOrCreate?: userCreateOrConnectWithoutCreatedusersInput
    upsert?: userUpsertWithoutCreatedusersInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutCreatedusersInput, userUpdateWithoutCreatedusersInput>, userUncheckedUpdateWithoutCreatedusersInput>
  }

  export type userUpdateManyWithoutCreateduserNestedInput = {
    create?: XOR<userCreateWithoutCreateduserInput, userUncheckedCreateWithoutCreateduserInput> | userCreateWithoutCreateduserInput[] | userUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: userCreateOrConnectWithoutCreateduserInput | userCreateOrConnectWithoutCreateduserInput[]
    upsert?: userUpsertWithWhereUniqueWithoutCreateduserInput | userUpsertWithWhereUniqueWithoutCreateduserInput[]
    createMany?: userCreateManyCreateduserInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutCreateduserInput | userUpdateWithWhereUniqueWithoutCreateduserInput[]
    updateMany?: userUpdateManyWithWhereWithoutCreateduserInput | userUpdateManyWithWhereWithoutCreateduserInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type userUpdateOneWithoutUpdatedusersNestedInput = {
    create?: XOR<userCreateWithoutUpdatedusersInput, userUncheckedCreateWithoutUpdatedusersInput>
    connectOrCreate?: userCreateOrConnectWithoutUpdatedusersInput
    upsert?: userUpsertWithoutUpdatedusersInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUpdatedusersInput, userUpdateWithoutUpdatedusersInput>, userUncheckedUpdateWithoutUpdatedusersInput>
  }

  export type userUpdateManyWithoutUpdateduserNestedInput = {
    create?: XOR<userCreateWithoutUpdateduserInput, userUncheckedCreateWithoutUpdateduserInput> | userCreateWithoutUpdateduserInput[] | userUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: userCreateOrConnectWithoutUpdateduserInput | userCreateOrConnectWithoutUpdateduserInput[]
    upsert?: userUpsertWithWhereUniqueWithoutUpdateduserInput | userUpsertWithWhereUniqueWithoutUpdateduserInput[]
    createMany?: userCreateManyUpdateduserInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutUpdateduserInput | userUpdateWithWhereUniqueWithoutUpdateduserInput[]
    updateMany?: userUpdateManyWithWhereWithoutUpdateduserInput | userUpdateManyWithWhereWithoutUpdateduserInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type userpermissionUpdateManyWithoutCreateduserNestedInput = {
    create?: XOR<userpermissionCreateWithoutCreateduserInput, userpermissionUncheckedCreateWithoutCreateduserInput> | userpermissionCreateWithoutCreateduserInput[] | userpermissionUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: userpermissionCreateOrConnectWithoutCreateduserInput | userpermissionCreateOrConnectWithoutCreateduserInput[]
    upsert?: userpermissionUpsertWithWhereUniqueWithoutCreateduserInput | userpermissionUpsertWithWhereUniqueWithoutCreateduserInput[]
    createMany?: userpermissionCreateManyCreateduserInputEnvelope
    set?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    disconnect?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    delete?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    connect?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    update?: userpermissionUpdateWithWhereUniqueWithoutCreateduserInput | userpermissionUpdateWithWhereUniqueWithoutCreateduserInput[]
    updateMany?: userpermissionUpdateManyWithWhereWithoutCreateduserInput | userpermissionUpdateManyWithWhereWithoutCreateduserInput[]
    deleteMany?: userpermissionScalarWhereInput | userpermissionScalarWhereInput[]
  }

  export type userpermissionUpdateManyWithoutUpdateduserNestedInput = {
    create?: XOR<userpermissionCreateWithoutUpdateduserInput, userpermissionUncheckedCreateWithoutUpdateduserInput> | userpermissionCreateWithoutUpdateduserInput[] | userpermissionUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: userpermissionCreateOrConnectWithoutUpdateduserInput | userpermissionCreateOrConnectWithoutUpdateduserInput[]
    upsert?: userpermissionUpsertWithWhereUniqueWithoutUpdateduserInput | userpermissionUpsertWithWhereUniqueWithoutUpdateduserInput[]
    createMany?: userpermissionCreateManyUpdateduserInputEnvelope
    set?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    disconnect?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    delete?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    connect?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    update?: userpermissionUpdateWithWhereUniqueWithoutUpdateduserInput | userpermissionUpdateWithWhereUniqueWithoutUpdateduserInput[]
    updateMany?: userpermissionUpdateManyWithWhereWithoutUpdateduserInput | userpermissionUpdateManyWithWhereWithoutUpdateduserInput[]
    deleteMany?: userpermissionScalarWhereInput | userpermissionScalarWhereInput[]
  }

  export type userpermissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<userpermissionCreateWithoutUserInput, userpermissionUncheckedCreateWithoutUserInput> | userpermissionCreateWithoutUserInput[] | userpermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userpermissionCreateOrConnectWithoutUserInput | userpermissionCreateOrConnectWithoutUserInput[]
    upsert?: userpermissionUpsertWithWhereUniqueWithoutUserInput | userpermissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userpermissionCreateManyUserInputEnvelope
    set?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    disconnect?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    delete?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    connect?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    update?: userpermissionUpdateWithWhereUniqueWithoutUserInput | userpermissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userpermissionUpdateManyWithWhereWithoutUserInput | userpermissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userpermissionScalarWhereInput | userpermissionScalarWhereInput[]
  }

  export type userroleUpdateManyWithoutCreateduserNestedInput = {
    create?: XOR<userroleCreateWithoutCreateduserInput, userroleUncheckedCreateWithoutCreateduserInput> | userroleCreateWithoutCreateduserInput[] | userroleUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutCreateduserInput | userroleCreateOrConnectWithoutCreateduserInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutCreateduserInput | userroleUpsertWithWhereUniqueWithoutCreateduserInput[]
    createMany?: userroleCreateManyCreateduserInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutCreateduserInput | userroleUpdateWithWhereUniqueWithoutCreateduserInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutCreateduserInput | userroleUpdateManyWithWhereWithoutCreateduserInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type userroleUpdateManyWithoutUpdateduserNestedInput = {
    create?: XOR<userroleCreateWithoutUpdateduserInput, userroleUncheckedCreateWithoutUpdateduserInput> | userroleCreateWithoutUpdateduserInput[] | userroleUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUpdateduserInput | userroleCreateOrConnectWithoutUpdateduserInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutUpdateduserInput | userroleUpsertWithWhereUniqueWithoutUpdateduserInput[]
    createMany?: userroleCreateManyUpdateduserInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutUpdateduserInput | userroleUpdateWithWhereUniqueWithoutUpdateduserInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutUpdateduserInput | userroleUpdateManyWithWhereWithoutUpdateduserInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type userroleUpdateManyWithoutUserNestedInput = {
    create?: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput> | userroleCreateWithoutUserInput[] | userroleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUserInput | userroleCreateOrConnectWithoutUserInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutUserInput | userroleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userroleCreateManyUserInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutUserInput | userroleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutUserInput | userroleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type invoiceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<invoiceCreateWithoutUserInput, invoiceUncheckedCreateWithoutUserInput> | invoiceCreateWithoutUserInput[] | invoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: invoiceCreateOrConnectWithoutUserInput | invoiceCreateOrConnectWithoutUserInput[]
    upsert?: invoiceUpsertWithWhereUniqueWithoutUserInput | invoiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: invoiceCreateManyUserInputEnvelope
    set?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    disconnect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    delete?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    connect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    update?: invoiceUpdateWithWhereUniqueWithoutUserInput | invoiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: invoiceUpdateManyWithWhereWithoutUserInput | invoiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: invoiceScalarWhereInput | invoiceScalarWhereInput[]
  }

  export type subscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<subscriptionCreateWithoutUserInput, subscriptionUncheckedCreateWithoutUserInput> | subscriptionCreateWithoutUserInput[] | subscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: subscriptionCreateOrConnectWithoutUserInput | subscriptionCreateOrConnectWithoutUserInput[]
    upsert?: subscriptionUpsertWithWhereUniqueWithoutUserInput | subscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: subscriptionCreateManyUserInputEnvelope
    set?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    disconnect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    delete?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    connect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    update?: subscriptionUpdateWithWhereUniqueWithoutUserInput | subscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: subscriptionUpdateManyWithWhereWithoutUserInput | subscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: subscriptionScalarWhereInput | subscriptionScalarWhereInput[]
  }

  export type customerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<customerCreateWithoutUserInput, customerUncheckedCreateWithoutUserInput> | customerCreateWithoutUserInput[] | customerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: customerCreateOrConnectWithoutUserInput | customerCreateOrConnectWithoutUserInput[]
    upsert?: customerUpsertWithWhereUniqueWithoutUserInput | customerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: customerCreateManyUserInputEnvelope
    set?: customerWhereUniqueInput | customerWhereUniqueInput[]
    disconnect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    delete?: customerWhereUniqueInput | customerWhereUniqueInput[]
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    update?: customerUpdateWithWhereUniqueWithoutUserInput | customerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: customerUpdateManyWithWhereWithoutUserInput | customerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: customerScalarWhereInput | customerScalarWhereInput[]
  }

  export type parametersUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<parametersCreateWithoutUserInput, parametersUncheckedCreateWithoutUserInput> | parametersCreateWithoutUserInput[] | parametersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: parametersCreateOrConnectWithoutUserInput | parametersCreateOrConnectWithoutUserInput[]
    upsert?: parametersUpsertWithWhereUniqueWithoutUserInput | parametersUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: parametersCreateManyUserInputEnvelope
    set?: parametersWhereUniqueInput | parametersWhereUniqueInput[]
    disconnect?: parametersWhereUniqueInput | parametersWhereUniqueInput[]
    delete?: parametersWhereUniqueInput | parametersWhereUniqueInput[]
    connect?: parametersWhereUniqueInput | parametersWhereUniqueInput[]
    update?: parametersUpdateWithWhereUniqueWithoutUserInput | parametersUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: parametersUpdateManyWithWhereWithoutUserInput | parametersUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: parametersScalarWhereInput | parametersScalarWhereInput[]
  }

  export type entranceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<entranceCreateWithoutUserInput, entranceUncheckedCreateWithoutUserInput> | entranceCreateWithoutUserInput[] | entranceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: entranceCreateOrConnectWithoutUserInput | entranceCreateOrConnectWithoutUserInput[]
    upsert?: entranceUpsertWithWhereUniqueWithoutUserInput | entranceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: entranceCreateManyUserInputEnvelope
    set?: entranceWhereUniqueInput | entranceWhereUniqueInput[]
    disconnect?: entranceWhereUniqueInput | entranceWhereUniqueInput[]
    delete?: entranceWhereUniqueInput | entranceWhereUniqueInput[]
    connect?: entranceWhereUniqueInput | entranceWhereUniqueInput[]
    update?: entranceUpdateWithWhereUniqueWithoutUserInput | entranceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: entranceUpdateManyWithWhereWithoutUserInput | entranceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: entranceScalarWhereInput | entranceScalarWhereInput[]
  }

  export type paymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<paymentCreateWithoutUserInput, paymentUncheckedCreateWithoutUserInput> | paymentCreateWithoutUserInput[] | paymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutUserInput | paymentCreateOrConnectWithoutUserInput[]
    upsert?: paymentUpsertWithWhereUniqueWithoutUserInput | paymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: paymentCreateManyUserInputEnvelope
    set?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    disconnect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    delete?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    update?: paymentUpdateWithWhereUniqueWithoutUserInput | paymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: paymentUpdateManyWithWhereWithoutUserInput | paymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: paymentScalarWhereInput | paymentScalarWhereInput[]
  }

  export type transactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<transactionCreateWithoutUserInput, transactionUncheckedCreateWithoutUserInput> | transactionCreateWithoutUserInput[] | transactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutUserInput | transactionCreateOrConnectWithoutUserInput[]
    upsert?: transactionUpsertWithWhereUniqueWithoutUserInput | transactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: transactionCreateManyUserInputEnvelope
    set?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    disconnect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    delete?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    update?: transactionUpdateWithWhereUniqueWithoutUserInput | transactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: transactionUpdateManyWithWhereWithoutUserInput | transactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: transactionScalarWhereInput | transactionScalarWhereInput[]
  }

  export type notificationUncheckedUpdateManyWithoutToNestedInput = {
    create?: XOR<notificationCreateWithoutToInput, notificationUncheckedCreateWithoutToInput> | notificationCreateWithoutToInput[] | notificationUncheckedCreateWithoutToInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutToInput | notificationCreateOrConnectWithoutToInput[]
    upsert?: notificationUpsertWithWhereUniqueWithoutToInput | notificationUpsertWithWhereUniqueWithoutToInput[]
    createMany?: notificationCreateManyToInputEnvelope
    set?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    disconnect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    delete?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    update?: notificationUpdateWithWhereUniqueWithoutToInput | notificationUpdateWithWhereUniqueWithoutToInput[]
    updateMany?: notificationUpdateManyWithWhereWithoutToInput | notificationUpdateManyWithWhereWithoutToInput[]
    deleteMany?: notificationScalarWhereInput | notificationScalarWhereInput[]
  }

  export type apiclientUncheckedUpdateManyWithoutCreateduserNestedInput = {
    create?: XOR<apiclientCreateWithoutCreateduserInput, apiclientUncheckedCreateWithoutCreateduserInput> | apiclientCreateWithoutCreateduserInput[] | apiclientUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: apiclientCreateOrConnectWithoutCreateduserInput | apiclientCreateOrConnectWithoutCreateduserInput[]
    upsert?: apiclientUpsertWithWhereUniqueWithoutCreateduserInput | apiclientUpsertWithWhereUniqueWithoutCreateduserInput[]
    createMany?: apiclientCreateManyCreateduserInputEnvelope
    set?: apiclientWhereUniqueInput | apiclientWhereUniqueInput[]
    disconnect?: apiclientWhereUniqueInput | apiclientWhereUniqueInput[]
    delete?: apiclientWhereUniqueInput | apiclientWhereUniqueInput[]
    connect?: apiclientWhereUniqueInput | apiclientWhereUniqueInput[]
    update?: apiclientUpdateWithWhereUniqueWithoutCreateduserInput | apiclientUpdateWithWhereUniqueWithoutCreateduserInput[]
    updateMany?: apiclientUpdateManyWithWhereWithoutCreateduserInput | apiclientUpdateManyWithWhereWithoutCreateduserInput[]
    deleteMany?: apiclientScalarWhereInput | apiclientScalarWhereInput[]
  }

  export type apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput = {
    create?: XOR<apiclientCreateWithoutUpdateduserInput, apiclientUncheckedCreateWithoutUpdateduserInput> | apiclientCreateWithoutUpdateduserInput[] | apiclientUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: apiclientCreateOrConnectWithoutUpdateduserInput | apiclientCreateOrConnectWithoutUpdateduserInput[]
    upsert?: apiclientUpsertWithWhereUniqueWithoutUpdateduserInput | apiclientUpsertWithWhereUniqueWithoutUpdateduserInput[]
    createMany?: apiclientCreateManyUpdateduserInputEnvelope
    set?: apiclientWhereUniqueInput | apiclientWhereUniqueInput[]
    disconnect?: apiclientWhereUniqueInput | apiclientWhereUniqueInput[]
    delete?: apiclientWhereUniqueInput | apiclientWhereUniqueInput[]
    connect?: apiclientWhereUniqueInput | apiclientWhereUniqueInput[]
    update?: apiclientUpdateWithWhereUniqueWithoutUpdateduserInput | apiclientUpdateWithWhereUniqueWithoutUpdateduserInput[]
    updateMany?: apiclientUpdateManyWithWhereWithoutUpdateduserInput | apiclientUpdateManyWithWhereWithoutUpdateduserInput[]
    deleteMany?: apiclientScalarWhereInput | apiclientScalarWhereInput[]
  }

  export type permissionUncheckedUpdateManyWithoutCreateduserNestedInput = {
    create?: XOR<permissionCreateWithoutCreateduserInput, permissionUncheckedCreateWithoutCreateduserInput> | permissionCreateWithoutCreateduserInput[] | permissionUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: permissionCreateOrConnectWithoutCreateduserInput | permissionCreateOrConnectWithoutCreateduserInput[]
    upsert?: permissionUpsertWithWhereUniqueWithoutCreateduserInput | permissionUpsertWithWhereUniqueWithoutCreateduserInput[]
    createMany?: permissionCreateManyCreateduserInputEnvelope
    set?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
    disconnect?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
    delete?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
    connect?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
    update?: permissionUpdateWithWhereUniqueWithoutCreateduserInput | permissionUpdateWithWhereUniqueWithoutCreateduserInput[]
    updateMany?: permissionUpdateManyWithWhereWithoutCreateduserInput | permissionUpdateManyWithWhereWithoutCreateduserInput[]
    deleteMany?: permissionScalarWhereInput | permissionScalarWhereInput[]
  }

  export type permissionUncheckedUpdateManyWithoutUpdateduserNestedInput = {
    create?: XOR<permissionCreateWithoutUpdateduserInput, permissionUncheckedCreateWithoutUpdateduserInput> | permissionCreateWithoutUpdateduserInput[] | permissionUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: permissionCreateOrConnectWithoutUpdateduserInput | permissionCreateOrConnectWithoutUpdateduserInput[]
    upsert?: permissionUpsertWithWhereUniqueWithoutUpdateduserInput | permissionUpsertWithWhereUniqueWithoutUpdateduserInput[]
    createMany?: permissionCreateManyUpdateduserInputEnvelope
    set?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
    disconnect?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
    delete?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
    connect?: permissionWhereUniqueInput | permissionWhereUniqueInput[]
    update?: permissionUpdateWithWhereUniqueWithoutUpdateduserInput | permissionUpdateWithWhereUniqueWithoutUpdateduserInput[]
    updateMany?: permissionUpdateManyWithWhereWithoutUpdateduserInput | permissionUpdateManyWithWhereWithoutUpdateduserInput[]
    deleteMany?: permissionScalarWhereInput | permissionScalarWhereInput[]
  }

  export type refreshtokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<refreshtokenCreateWithoutUserInput, refreshtokenUncheckedCreateWithoutUserInput> | refreshtokenCreateWithoutUserInput[] | refreshtokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: refreshtokenCreateOrConnectWithoutUserInput | refreshtokenCreateOrConnectWithoutUserInput[]
    upsert?: refreshtokenUpsertWithWhereUniqueWithoutUserInput | refreshtokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: refreshtokenCreateManyUserInputEnvelope
    set?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    disconnect?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    delete?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    connect?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    update?: refreshtokenUpdateWithWhereUniqueWithoutUserInput | refreshtokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: refreshtokenUpdateManyWithWhereWithoutUserInput | refreshtokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: refreshtokenScalarWhereInput | refreshtokenScalarWhereInput[]
  }

  export type roleUncheckedUpdateManyWithoutCreateduserNestedInput = {
    create?: XOR<roleCreateWithoutCreateduserInput, roleUncheckedCreateWithoutCreateduserInput> | roleCreateWithoutCreateduserInput[] | roleUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: roleCreateOrConnectWithoutCreateduserInput | roleCreateOrConnectWithoutCreateduserInput[]
    upsert?: roleUpsertWithWhereUniqueWithoutCreateduserInput | roleUpsertWithWhereUniqueWithoutCreateduserInput[]
    createMany?: roleCreateManyCreateduserInputEnvelope
    set?: roleWhereUniqueInput | roleWhereUniqueInput[]
    disconnect?: roleWhereUniqueInput | roleWhereUniqueInput[]
    delete?: roleWhereUniqueInput | roleWhereUniqueInput[]
    connect?: roleWhereUniqueInput | roleWhereUniqueInput[]
    update?: roleUpdateWithWhereUniqueWithoutCreateduserInput | roleUpdateWithWhereUniqueWithoutCreateduserInput[]
    updateMany?: roleUpdateManyWithWhereWithoutCreateduserInput | roleUpdateManyWithWhereWithoutCreateduserInput[]
    deleteMany?: roleScalarWhereInput | roleScalarWhereInput[]
  }

  export type roleUncheckedUpdateManyWithoutUpdateduserNestedInput = {
    create?: XOR<roleCreateWithoutUpdateduserInput, roleUncheckedCreateWithoutUpdateduserInput> | roleCreateWithoutUpdateduserInput[] | roleUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: roleCreateOrConnectWithoutUpdateduserInput | roleCreateOrConnectWithoutUpdateduserInput[]
    upsert?: roleUpsertWithWhereUniqueWithoutUpdateduserInput | roleUpsertWithWhereUniqueWithoutUpdateduserInput[]
    createMany?: roleCreateManyUpdateduserInputEnvelope
    set?: roleWhereUniqueInput | roleWhereUniqueInput[]
    disconnect?: roleWhereUniqueInput | roleWhereUniqueInput[]
    delete?: roleWhereUniqueInput | roleWhereUniqueInput[]
    connect?: roleWhereUniqueInput | roleWhereUniqueInput[]
    update?: roleUpdateWithWhereUniqueWithoutUpdateduserInput | roleUpdateWithWhereUniqueWithoutUpdateduserInput[]
    updateMany?: roleUpdateManyWithWhereWithoutUpdateduserInput | roleUpdateManyWithWhereWithoutUpdateduserInput[]
    deleteMany?: roleScalarWhereInput | roleScalarWhereInput[]
  }

  export type rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput = {
    create?: XOR<rolepermissionCreateWithoutCreateduserInput, rolepermissionUncheckedCreateWithoutCreateduserInput> | rolepermissionCreateWithoutCreateduserInput[] | rolepermissionUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: rolepermissionCreateOrConnectWithoutCreateduserInput | rolepermissionCreateOrConnectWithoutCreateduserInput[]
    upsert?: rolepermissionUpsertWithWhereUniqueWithoutCreateduserInput | rolepermissionUpsertWithWhereUniqueWithoutCreateduserInput[]
    createMany?: rolepermissionCreateManyCreateduserInputEnvelope
    set?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    disconnect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    delete?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    connect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    update?: rolepermissionUpdateWithWhereUniqueWithoutCreateduserInput | rolepermissionUpdateWithWhereUniqueWithoutCreateduserInput[]
    updateMany?: rolepermissionUpdateManyWithWhereWithoutCreateduserInput | rolepermissionUpdateManyWithWhereWithoutCreateduserInput[]
    deleteMany?: rolepermissionScalarWhereInput | rolepermissionScalarWhereInput[]
  }

  export type rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput = {
    create?: XOR<rolepermissionCreateWithoutUpdateduserInput, rolepermissionUncheckedCreateWithoutUpdateduserInput> | rolepermissionCreateWithoutUpdateduserInput[] | rolepermissionUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: rolepermissionCreateOrConnectWithoutUpdateduserInput | rolepermissionCreateOrConnectWithoutUpdateduserInput[]
    upsert?: rolepermissionUpsertWithWhereUniqueWithoutUpdateduserInput | rolepermissionUpsertWithWhereUniqueWithoutUpdateduserInput[]
    createMany?: rolepermissionCreateManyUpdateduserInputEnvelope
    set?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    disconnect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    delete?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    connect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    update?: rolepermissionUpdateWithWhereUniqueWithoutUpdateduserInput | rolepermissionUpdateWithWhereUniqueWithoutUpdateduserInput[]
    updateMany?: rolepermissionUpdateManyWithWhereWithoutUpdateduserInput | rolepermissionUpdateManyWithWhereWithoutUpdateduserInput[]
    deleteMany?: rolepermissionScalarWhereInput | rolepermissionScalarWhereInput[]
  }

  export type userUncheckedUpdateManyWithoutCreateduserNestedInput = {
    create?: XOR<userCreateWithoutCreateduserInput, userUncheckedCreateWithoutCreateduserInput> | userCreateWithoutCreateduserInput[] | userUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: userCreateOrConnectWithoutCreateduserInput | userCreateOrConnectWithoutCreateduserInput[]
    upsert?: userUpsertWithWhereUniqueWithoutCreateduserInput | userUpsertWithWhereUniqueWithoutCreateduserInput[]
    createMany?: userCreateManyCreateduserInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutCreateduserInput | userUpdateWithWhereUniqueWithoutCreateduserInput[]
    updateMany?: userUpdateManyWithWhereWithoutCreateduserInput | userUpdateManyWithWhereWithoutCreateduserInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type userUncheckedUpdateManyWithoutUpdateduserNestedInput = {
    create?: XOR<userCreateWithoutUpdateduserInput, userUncheckedCreateWithoutUpdateduserInput> | userCreateWithoutUpdateduserInput[] | userUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: userCreateOrConnectWithoutUpdateduserInput | userCreateOrConnectWithoutUpdateduserInput[]
    upsert?: userUpsertWithWhereUniqueWithoutUpdateduserInput | userUpsertWithWhereUniqueWithoutUpdateduserInput[]
    createMany?: userCreateManyUpdateduserInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutUpdateduserInput | userUpdateWithWhereUniqueWithoutUpdateduserInput[]
    updateMany?: userUpdateManyWithWhereWithoutUpdateduserInput | userUpdateManyWithWhereWithoutUpdateduserInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput = {
    create?: XOR<userpermissionCreateWithoutCreateduserInput, userpermissionUncheckedCreateWithoutCreateduserInput> | userpermissionCreateWithoutCreateduserInput[] | userpermissionUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: userpermissionCreateOrConnectWithoutCreateduserInput | userpermissionCreateOrConnectWithoutCreateduserInput[]
    upsert?: userpermissionUpsertWithWhereUniqueWithoutCreateduserInput | userpermissionUpsertWithWhereUniqueWithoutCreateduserInput[]
    createMany?: userpermissionCreateManyCreateduserInputEnvelope
    set?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    disconnect?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    delete?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    connect?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    update?: userpermissionUpdateWithWhereUniqueWithoutCreateduserInput | userpermissionUpdateWithWhereUniqueWithoutCreateduserInput[]
    updateMany?: userpermissionUpdateManyWithWhereWithoutCreateduserInput | userpermissionUpdateManyWithWhereWithoutCreateduserInput[]
    deleteMany?: userpermissionScalarWhereInput | userpermissionScalarWhereInput[]
  }

  export type userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput = {
    create?: XOR<userpermissionCreateWithoutUpdateduserInput, userpermissionUncheckedCreateWithoutUpdateduserInput> | userpermissionCreateWithoutUpdateduserInput[] | userpermissionUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: userpermissionCreateOrConnectWithoutUpdateduserInput | userpermissionCreateOrConnectWithoutUpdateduserInput[]
    upsert?: userpermissionUpsertWithWhereUniqueWithoutUpdateduserInput | userpermissionUpsertWithWhereUniqueWithoutUpdateduserInput[]
    createMany?: userpermissionCreateManyUpdateduserInputEnvelope
    set?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    disconnect?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    delete?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    connect?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    update?: userpermissionUpdateWithWhereUniqueWithoutUpdateduserInput | userpermissionUpdateWithWhereUniqueWithoutUpdateduserInput[]
    updateMany?: userpermissionUpdateManyWithWhereWithoutUpdateduserInput | userpermissionUpdateManyWithWhereWithoutUpdateduserInput[]
    deleteMany?: userpermissionScalarWhereInput | userpermissionScalarWhereInput[]
  }

  export type userpermissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<userpermissionCreateWithoutUserInput, userpermissionUncheckedCreateWithoutUserInput> | userpermissionCreateWithoutUserInput[] | userpermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userpermissionCreateOrConnectWithoutUserInput | userpermissionCreateOrConnectWithoutUserInput[]
    upsert?: userpermissionUpsertWithWhereUniqueWithoutUserInput | userpermissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userpermissionCreateManyUserInputEnvelope
    set?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    disconnect?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    delete?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    connect?: userpermissionWhereUniqueInput | userpermissionWhereUniqueInput[]
    update?: userpermissionUpdateWithWhereUniqueWithoutUserInput | userpermissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userpermissionUpdateManyWithWhereWithoutUserInput | userpermissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userpermissionScalarWhereInput | userpermissionScalarWhereInput[]
  }

  export type userroleUncheckedUpdateManyWithoutCreateduserNestedInput = {
    create?: XOR<userroleCreateWithoutCreateduserInput, userroleUncheckedCreateWithoutCreateduserInput> | userroleCreateWithoutCreateduserInput[] | userroleUncheckedCreateWithoutCreateduserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutCreateduserInput | userroleCreateOrConnectWithoutCreateduserInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutCreateduserInput | userroleUpsertWithWhereUniqueWithoutCreateduserInput[]
    createMany?: userroleCreateManyCreateduserInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutCreateduserInput | userroleUpdateWithWhereUniqueWithoutCreateduserInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutCreateduserInput | userroleUpdateManyWithWhereWithoutCreateduserInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type userroleUncheckedUpdateManyWithoutUpdateduserNestedInput = {
    create?: XOR<userroleCreateWithoutUpdateduserInput, userroleUncheckedCreateWithoutUpdateduserInput> | userroleCreateWithoutUpdateduserInput[] | userroleUncheckedCreateWithoutUpdateduserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUpdateduserInput | userroleCreateOrConnectWithoutUpdateduserInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutUpdateduserInput | userroleUpsertWithWhereUniqueWithoutUpdateduserInput[]
    createMany?: userroleCreateManyUpdateduserInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutUpdateduserInput | userroleUpdateWithWhereUniqueWithoutUpdateduserInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutUpdateduserInput | userroleUpdateManyWithWhereWithoutUpdateduserInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type userroleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput> | userroleCreateWithoutUserInput[] | userroleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUserInput | userroleCreateOrConnectWithoutUserInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutUserInput | userroleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userroleCreateManyUserInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutUserInput | userroleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutUserInput | userroleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type subscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<subscriptionCreateWithoutPlanInput, subscriptionUncheckedCreateWithoutPlanInput> | subscriptionCreateWithoutPlanInput[] | subscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: subscriptionCreateOrConnectWithoutPlanInput | subscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: subscriptionCreateManyPlanInputEnvelope
    connect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
  }

  export type userCreateNestedManyWithoutPlanInput = {
    create?: XOR<userCreateWithoutPlanInput, userUncheckedCreateWithoutPlanInput> | userCreateWithoutPlanInput[] | userUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: userCreateOrConnectWithoutPlanInput | userCreateOrConnectWithoutPlanInput[]
    createMany?: userCreateManyPlanInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type subscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<subscriptionCreateWithoutPlanInput, subscriptionUncheckedCreateWithoutPlanInput> | subscriptionCreateWithoutPlanInput[] | subscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: subscriptionCreateOrConnectWithoutPlanInput | subscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: subscriptionCreateManyPlanInputEnvelope
    connect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
  }

  export type userUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<userCreateWithoutPlanInput, userUncheckedCreateWithoutPlanInput> | userCreateWithoutPlanInput[] | userUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: userCreateOrConnectWithoutPlanInput | userCreateOrConnectWithoutPlanInput[]
    createMany?: userCreateManyPlanInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type subscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<subscriptionCreateWithoutPlanInput, subscriptionUncheckedCreateWithoutPlanInput> | subscriptionCreateWithoutPlanInput[] | subscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: subscriptionCreateOrConnectWithoutPlanInput | subscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: subscriptionUpsertWithWhereUniqueWithoutPlanInput | subscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: subscriptionCreateManyPlanInputEnvelope
    set?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    disconnect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    delete?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    connect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    update?: subscriptionUpdateWithWhereUniqueWithoutPlanInput | subscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: subscriptionUpdateManyWithWhereWithoutPlanInput | subscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: subscriptionScalarWhereInput | subscriptionScalarWhereInput[]
  }

  export type userUpdateManyWithoutPlanNestedInput = {
    create?: XOR<userCreateWithoutPlanInput, userUncheckedCreateWithoutPlanInput> | userCreateWithoutPlanInput[] | userUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: userCreateOrConnectWithoutPlanInput | userCreateOrConnectWithoutPlanInput[]
    upsert?: userUpsertWithWhereUniqueWithoutPlanInput | userUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: userCreateManyPlanInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutPlanInput | userUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: userUpdateManyWithWhereWithoutPlanInput | userUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type subscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<subscriptionCreateWithoutPlanInput, subscriptionUncheckedCreateWithoutPlanInput> | subscriptionCreateWithoutPlanInput[] | subscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: subscriptionCreateOrConnectWithoutPlanInput | subscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: subscriptionUpsertWithWhereUniqueWithoutPlanInput | subscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: subscriptionCreateManyPlanInputEnvelope
    set?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    disconnect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    delete?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    connect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    update?: subscriptionUpdateWithWhereUniqueWithoutPlanInput | subscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: subscriptionUpdateManyWithWhereWithoutPlanInput | subscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: subscriptionScalarWhereInput | subscriptionScalarWhereInput[]
  }

  export type userUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<userCreateWithoutPlanInput, userUncheckedCreateWithoutPlanInput> | userCreateWithoutPlanInput[] | userUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: userCreateOrConnectWithoutPlanInput | userCreateOrConnectWithoutPlanInput[]
    upsert?: userUpsertWithWhereUniqueWithoutPlanInput | userUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: userCreateManyPlanInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutPlanInput | userUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: userUpdateManyWithWhereWithoutPlanInput | userUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<userCreateWithoutSubscriptionsInput, userUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: userCreateOrConnectWithoutSubscriptionsInput
    connect?: userWhereUniqueInput
  }

  export type planCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<planCreateWithoutSubscriptionsInput, planUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: planCreateOrConnectWithoutSubscriptionsInput
    connect?: planWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<userCreateWithoutSubscriptionsInput, userUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: userCreateOrConnectWithoutSubscriptionsInput
    upsert?: userUpsertWithoutSubscriptionsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutSubscriptionsInput, userUpdateWithoutSubscriptionsInput>, userUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type planUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<planCreateWithoutSubscriptionsInput, planUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: planCreateOrConnectWithoutSubscriptionsInput
    upsert?: planUpsertWithoutSubscriptionsInput
    connect?: planWhereUniqueInput
    update?: XOR<XOR<planUpdateToOneWithWhereWithoutSubscriptionsInput, planUpdateWithoutSubscriptionsInput>, planUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type userCreateNestedOneWithoutCustomersInput = {
    create?: XOR<userCreateWithoutCustomersInput, userUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: userCreateOrConnectWithoutCustomersInput
    connect?: userWhereUniqueInput
  }

  export type invoiceCreateNestedManyWithoutCustomerInput = {
    create?: XOR<invoiceCreateWithoutCustomerInput, invoiceUncheckedCreateWithoutCustomerInput> | invoiceCreateWithoutCustomerInput[] | invoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: invoiceCreateOrConnectWithoutCustomerInput | invoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: invoiceCreateManyCustomerInputEnvelope
    connect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
  }

  export type invoiceUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<invoiceCreateWithoutCustomerInput, invoiceUncheckedCreateWithoutCustomerInput> | invoiceCreateWithoutCustomerInput[] | invoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: invoiceCreateOrConnectWithoutCustomerInput | invoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: invoiceCreateManyCustomerInputEnvelope
    connect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
  }

  export type userUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<userCreateWithoutCustomersInput, userUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: userCreateOrConnectWithoutCustomersInput
    upsert?: userUpsertWithoutCustomersInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutCustomersInput, userUpdateWithoutCustomersInput>, userUncheckedUpdateWithoutCustomersInput>
  }

  export type invoiceUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<invoiceCreateWithoutCustomerInput, invoiceUncheckedCreateWithoutCustomerInput> | invoiceCreateWithoutCustomerInput[] | invoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: invoiceCreateOrConnectWithoutCustomerInput | invoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: invoiceUpsertWithWhereUniqueWithoutCustomerInput | invoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: invoiceCreateManyCustomerInputEnvelope
    set?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    disconnect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    delete?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    connect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    update?: invoiceUpdateWithWhereUniqueWithoutCustomerInput | invoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: invoiceUpdateManyWithWhereWithoutCustomerInput | invoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: invoiceScalarWhereInput | invoiceScalarWhereInput[]
  }

  export type invoiceUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<invoiceCreateWithoutCustomerInput, invoiceUncheckedCreateWithoutCustomerInput> | invoiceCreateWithoutCustomerInput[] | invoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: invoiceCreateOrConnectWithoutCustomerInput | invoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: invoiceUpsertWithWhereUniqueWithoutCustomerInput | invoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: invoiceCreateManyCustomerInputEnvelope
    set?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    disconnect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    delete?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    connect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    update?: invoiceUpdateWithWhereUniqueWithoutCustomerInput | invoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: invoiceUpdateManyWithWhereWithoutCustomerInput | invoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: invoiceScalarWhereInput | invoiceScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<userCreateWithoutInvoicesInput, userUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: userCreateOrConnectWithoutInvoicesInput
    connect?: userWhereUniqueInput
  }

  export type customerCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<customerCreateWithoutInvoicesInput, customerUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: customerCreateOrConnectWithoutInvoicesInput
    connect?: customerWhereUniqueInput
  }

  export type paymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<paymentCreateWithoutInvoiceInput, paymentUncheckedCreateWithoutInvoiceInput> | paymentCreateWithoutInvoiceInput[] | paymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutInvoiceInput | paymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: paymentCreateManyInvoiceInputEnvelope
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
  }

  export type paymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<paymentCreateWithoutInvoiceInput, paymentUncheckedCreateWithoutInvoiceInput> | paymentCreateWithoutInvoiceInput[] | paymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutInvoiceInput | paymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: paymentCreateManyInvoiceInputEnvelope
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
  }

  export type userUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<userCreateWithoutInvoicesInput, userUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: userCreateOrConnectWithoutInvoicesInput
    upsert?: userUpsertWithoutInvoicesInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutInvoicesInput, userUpdateWithoutInvoicesInput>, userUncheckedUpdateWithoutInvoicesInput>
  }

  export type customerUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<customerCreateWithoutInvoicesInput, customerUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: customerCreateOrConnectWithoutInvoicesInput
    upsert?: customerUpsertWithoutInvoicesInput
    connect?: customerWhereUniqueInput
    update?: XOR<XOR<customerUpdateToOneWithWhereWithoutInvoicesInput, customerUpdateWithoutInvoicesInput>, customerUncheckedUpdateWithoutInvoicesInput>
  }

  export type paymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<paymentCreateWithoutInvoiceInput, paymentUncheckedCreateWithoutInvoiceInput> | paymentCreateWithoutInvoiceInput[] | paymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutInvoiceInput | paymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: paymentUpsertWithWhereUniqueWithoutInvoiceInput | paymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: paymentCreateManyInvoiceInputEnvelope
    set?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    disconnect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    delete?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    update?: paymentUpdateWithWhereUniqueWithoutInvoiceInput | paymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: paymentUpdateManyWithWhereWithoutInvoiceInput | paymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: paymentScalarWhereInput | paymentScalarWhereInput[]
  }

  export type paymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<paymentCreateWithoutInvoiceInput, paymentUncheckedCreateWithoutInvoiceInput> | paymentCreateWithoutInvoiceInput[] | paymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutInvoiceInput | paymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: paymentUpsertWithWhereUniqueWithoutInvoiceInput | paymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: paymentCreateManyInvoiceInputEnvelope
    set?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    disconnect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    delete?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    update?: paymentUpdateWithWhereUniqueWithoutInvoiceInput | paymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: paymentUpdateManyWithWhereWithoutInvoiceInput | paymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: paymentScalarWhereInput | paymentScalarWhereInput[]
  }

  export type invoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<invoiceCreateWithoutPaymentsInput, invoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: invoiceCreateOrConnectWithoutPaymentsInput
    connect?: invoiceWhereUniqueInput
  }

  export type userCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<userCreateWithoutPaymentsInput, userUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: userCreateOrConnectWithoutPaymentsInput
    connect?: userWhereUniqueInput
  }

  export type invoiceUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<invoiceCreateWithoutPaymentsInput, invoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: invoiceCreateOrConnectWithoutPaymentsInput
    upsert?: invoiceUpsertWithoutPaymentsInput
    connect?: invoiceWhereUniqueInput
    update?: XOR<XOR<invoiceUpdateToOneWithWhereWithoutPaymentsInput, invoiceUpdateWithoutPaymentsInput>, invoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type userUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<userCreateWithoutPaymentsInput, userUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: userCreateOrConnectWithoutPaymentsInput
    upsert?: userUpsertWithoutPaymentsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutPaymentsInput, userUpdateWithoutPaymentsInput>, userUncheckedUpdateWithoutPaymentsInput>
  }

  export type userCreateNestedOneWithoutParametersInput = {
    create?: XOR<userCreateWithoutParametersInput, userUncheckedCreateWithoutParametersInput>
    connectOrCreate?: userCreateOrConnectWithoutParametersInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutParametersNestedInput = {
    create?: XOR<userCreateWithoutParametersInput, userUncheckedCreateWithoutParametersInput>
    connectOrCreate?: userCreateOrConnectWithoutParametersInput
    upsert?: userUpsertWithoutParametersInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutParametersInput, userUpdateWithoutParametersInput>, userUncheckedUpdateWithoutParametersInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type userCreateWithoutCreatedapiclientsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCreatedapiclientsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCreatedapiclientsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCreatedapiclientsInput, userUncheckedCreateWithoutCreatedapiclientsInput>
  }

  export type userCreateWithoutUpdatedapiclientsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUpdatedapiclientsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUpdatedapiclientsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUpdatedapiclientsInput, userUncheckedCreateWithoutUpdatedapiclientsInput>
  }

  export type userUpsertWithoutCreatedapiclientsInput = {
    update: XOR<userUpdateWithoutCreatedapiclientsInput, userUncheckedUpdateWithoutCreatedapiclientsInput>
    create: XOR<userCreateWithoutCreatedapiclientsInput, userUncheckedCreateWithoutCreatedapiclientsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutCreatedapiclientsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutCreatedapiclientsInput, userUncheckedUpdateWithoutCreatedapiclientsInput>
  }

  export type userUpdateWithoutCreatedapiclientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutCreatedapiclientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUpsertWithoutUpdatedapiclientsInput = {
    update: XOR<userUpdateWithoutUpdatedapiclientsInput, userUncheckedUpdateWithoutUpdatedapiclientsInput>
    create: XOR<userCreateWithoutUpdatedapiclientsInput, userUncheckedCreateWithoutUpdatedapiclientsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUpdatedapiclientsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUpdatedapiclientsInput, userUncheckedUpdateWithoutUpdatedapiclientsInput>
  }

  export type userUpdateWithoutUpdatedapiclientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUpdatedapiclientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutRefreshtokensInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutRefreshtokensInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutRefreshtokensInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutRefreshtokensInput, userUncheckedCreateWithoutRefreshtokensInput>
  }

  export type userUpsertWithoutRefreshtokensInput = {
    update: XOR<userUpdateWithoutRefreshtokensInput, userUncheckedUpdateWithoutRefreshtokensInput>
    create: XOR<userCreateWithoutRefreshtokensInput, userUncheckedCreateWithoutRefreshtokensInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutRefreshtokensInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutRefreshtokensInput, userUncheckedUpdateWithoutRefreshtokensInput>
  }

  export type userUpdateWithoutRefreshtokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutRefreshtokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutCreatedrolesInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCreatedrolesInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCreatedrolesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCreatedrolesInput, userUncheckedCreateWithoutCreatedrolesInput>
  }

  export type userCreateWithoutUpdatedrolesInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUpdatedrolesInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUpdatedrolesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUpdatedrolesInput, userUncheckedCreateWithoutUpdatedrolesInput>
  }

  export type rolepermissionCreateWithoutRoleInput = {
    id?: string
    createdat?: Date | string
    updatedat?: Date | string | null
    createduser: userCreateNestedOneWithoutCreatedrolepermissionsInput
    permission: permissionCreateNestedOneWithoutRolepermissionsInput
    updateduser?: userCreateNestedOneWithoutUpdatedrolepermissionsInput
  }

  export type rolepermissionUncheckedCreateWithoutRoleInput = {
    id?: string
    permissionid: string
    createdat?: Date | string
    createdby: string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type rolepermissionCreateOrConnectWithoutRoleInput = {
    where: rolepermissionWhereUniqueInput
    create: XOR<rolepermissionCreateWithoutRoleInput, rolepermissionUncheckedCreateWithoutRoleInput>
  }

  export type rolepermissionCreateManyRoleInputEnvelope = {
    data: rolepermissionCreateManyRoleInput | rolepermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type userroleCreateWithoutRoleInput = {
    id?: string
    createdat?: Date | string
    updatedat?: Date | string | null
    createduser: userCreateNestedOneWithoutCreateduserrolesInput
    updateduser?: userCreateNestedOneWithoutUpdateduserrolesInput
    user: userCreateNestedOneWithoutUserrolesInput
  }

  export type userroleUncheckedCreateWithoutRoleInput = {
    id?: string
    userid: string
    createdby: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type userroleCreateOrConnectWithoutRoleInput = {
    where: userroleWhereUniqueInput
    create: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput>
  }

  export type userroleCreateManyRoleInputEnvelope = {
    data: userroleCreateManyRoleInput | userroleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutCreatedrolesInput = {
    update: XOR<userUpdateWithoutCreatedrolesInput, userUncheckedUpdateWithoutCreatedrolesInput>
    create: XOR<userCreateWithoutCreatedrolesInput, userUncheckedCreateWithoutCreatedrolesInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutCreatedrolesInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutCreatedrolesInput, userUncheckedUpdateWithoutCreatedrolesInput>
  }

  export type userUpdateWithoutCreatedrolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutCreatedrolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUpsertWithoutUpdatedrolesInput = {
    update: XOR<userUpdateWithoutUpdatedrolesInput, userUncheckedUpdateWithoutUpdatedrolesInput>
    create: XOR<userCreateWithoutUpdatedrolesInput, userUncheckedCreateWithoutUpdatedrolesInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUpdatedrolesInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUpdatedrolesInput, userUncheckedUpdateWithoutUpdatedrolesInput>
  }

  export type userUpdateWithoutUpdatedrolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUpdatedrolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type rolepermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: rolepermissionWhereUniqueInput
    update: XOR<rolepermissionUpdateWithoutRoleInput, rolepermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<rolepermissionCreateWithoutRoleInput, rolepermissionUncheckedCreateWithoutRoleInput>
  }

  export type rolepermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: rolepermissionWhereUniqueInput
    data: XOR<rolepermissionUpdateWithoutRoleInput, rolepermissionUncheckedUpdateWithoutRoleInput>
  }

  export type rolepermissionUpdateManyWithWhereWithoutRoleInput = {
    where: rolepermissionScalarWhereInput
    data: XOR<rolepermissionUpdateManyMutationInput, rolepermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type rolepermissionScalarWhereInput = {
    AND?: rolepermissionScalarWhereInput | rolepermissionScalarWhereInput[]
    OR?: rolepermissionScalarWhereInput[]
    NOT?: rolepermissionScalarWhereInput | rolepermissionScalarWhereInput[]
    id?: StringFilter<"rolepermission"> | string
    roleid?: StringFilter<"rolepermission"> | string
    permissionid?: StringFilter<"rolepermission"> | string
    createdat?: DateTimeFilter<"rolepermission"> | Date | string
    createdby?: StringFilter<"rolepermission"> | string
    updatedby?: StringNullableFilter<"rolepermission"> | string | null
    updatedat?: DateTimeNullableFilter<"rolepermission"> | Date | string | null
  }

  export type userroleUpsertWithWhereUniqueWithoutRoleInput = {
    where: userroleWhereUniqueInput
    update: XOR<userroleUpdateWithoutRoleInput, userroleUncheckedUpdateWithoutRoleInput>
    create: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput>
  }

  export type userroleUpdateWithWhereUniqueWithoutRoleInput = {
    where: userroleWhereUniqueInput
    data: XOR<userroleUpdateWithoutRoleInput, userroleUncheckedUpdateWithoutRoleInput>
  }

  export type userroleUpdateManyWithWhereWithoutRoleInput = {
    where: userroleScalarWhereInput
    data: XOR<userroleUpdateManyMutationInput, userroleUncheckedUpdateManyWithoutRoleInput>
  }

  export type userroleScalarWhereInput = {
    AND?: userroleScalarWhereInput | userroleScalarWhereInput[]
    OR?: userroleScalarWhereInput[]
    NOT?: userroleScalarWhereInput | userroleScalarWhereInput[]
    id?: StringFilter<"userrole"> | string
    userid?: StringFilter<"userrole"> | string
    roleid?: StringFilter<"userrole"> | string
    createdby?: StringFilter<"userrole"> | string
    createdat?: DateTimeFilter<"userrole"> | Date | string
    updatedby?: StringNullableFilter<"userrole"> | string | null
    updatedat?: DateTimeNullableFilter<"userrole"> | Date | string | null
  }

  export type userCreateWithoutNotificationuserInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutNotificationuserInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutNotificationuserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutNotificationuserInput, userUncheckedCreateWithoutNotificationuserInput>
  }

  export type userUpsertWithoutNotificationuserInput = {
    update: XOR<userUpdateWithoutNotificationuserInput, userUncheckedUpdateWithoutNotificationuserInput>
    create: XOR<userCreateWithoutNotificationuserInput, userUncheckedCreateWithoutNotificationuserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutNotificationuserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutNotificationuserInput, userUncheckedUpdateWithoutNotificationuserInput>
  }

  export type userUpdateWithoutNotificationuserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutNotificationuserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutCreatedpermissionsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCreatedpermissionsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCreatedpermissionsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCreatedpermissionsInput, userUncheckedCreateWithoutCreatedpermissionsInput>
  }

  export type userCreateWithoutUpdatedpermissionsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUpdatedpermissionsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUpdatedpermissionsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUpdatedpermissionsInput, userUncheckedCreateWithoutUpdatedpermissionsInput>
  }

  export type rolepermissionCreateWithoutPermissionInput = {
    id?: string
    createdat?: Date | string
    updatedat?: Date | string | null
    createduser: userCreateNestedOneWithoutCreatedrolepermissionsInput
    role: roleCreateNestedOneWithoutRolepermissionsInput
    updateduser?: userCreateNestedOneWithoutUpdatedrolepermissionsInput
  }

  export type rolepermissionUncheckedCreateWithoutPermissionInput = {
    id?: string
    roleid: string
    createdat?: Date | string
    createdby: string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type rolepermissionCreateOrConnectWithoutPermissionInput = {
    where: rolepermissionWhereUniqueInput
    create: XOR<rolepermissionCreateWithoutPermissionInput, rolepermissionUncheckedCreateWithoutPermissionInput>
  }

  export type rolepermissionCreateManyPermissionInputEnvelope = {
    data: rolepermissionCreateManyPermissionInput | rolepermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type userpermissionCreateWithoutPermissionInput = {
    id?: string
    createdat?: Date | string
    updatedat?: Date | string | null
    createduser: userCreateNestedOneWithoutCreateduserpermissionsInput
    updateduser?: userCreateNestedOneWithoutUpdateduserpermissionsInput
    user: userCreateNestedOneWithoutUserpermissionsInput
  }

  export type userpermissionUncheckedCreateWithoutPermissionInput = {
    id?: string
    userid: string
    createdby: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type userpermissionCreateOrConnectWithoutPermissionInput = {
    where: userpermissionWhereUniqueInput
    create: XOR<userpermissionCreateWithoutPermissionInput, userpermissionUncheckedCreateWithoutPermissionInput>
  }

  export type userpermissionCreateManyPermissionInputEnvelope = {
    data: userpermissionCreateManyPermissionInput | userpermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutCreatedpermissionsInput = {
    update: XOR<userUpdateWithoutCreatedpermissionsInput, userUncheckedUpdateWithoutCreatedpermissionsInput>
    create: XOR<userCreateWithoutCreatedpermissionsInput, userUncheckedCreateWithoutCreatedpermissionsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutCreatedpermissionsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutCreatedpermissionsInput, userUncheckedUpdateWithoutCreatedpermissionsInput>
  }

  export type userUpdateWithoutCreatedpermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutCreatedpermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUpsertWithoutUpdatedpermissionsInput = {
    update: XOR<userUpdateWithoutUpdatedpermissionsInput, userUncheckedUpdateWithoutUpdatedpermissionsInput>
    create: XOR<userCreateWithoutUpdatedpermissionsInput, userUncheckedCreateWithoutUpdatedpermissionsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUpdatedpermissionsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUpdatedpermissionsInput, userUncheckedUpdateWithoutUpdatedpermissionsInput>
  }

  export type userUpdateWithoutUpdatedpermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUpdatedpermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type rolepermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: rolepermissionWhereUniqueInput
    update: XOR<rolepermissionUpdateWithoutPermissionInput, rolepermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<rolepermissionCreateWithoutPermissionInput, rolepermissionUncheckedCreateWithoutPermissionInput>
  }

  export type rolepermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: rolepermissionWhereUniqueInput
    data: XOR<rolepermissionUpdateWithoutPermissionInput, rolepermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type rolepermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: rolepermissionScalarWhereInput
    data: XOR<rolepermissionUpdateManyMutationInput, rolepermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type userpermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: userpermissionWhereUniqueInput
    update: XOR<userpermissionUpdateWithoutPermissionInput, userpermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<userpermissionCreateWithoutPermissionInput, userpermissionUncheckedCreateWithoutPermissionInput>
  }

  export type userpermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: userpermissionWhereUniqueInput
    data: XOR<userpermissionUpdateWithoutPermissionInput, userpermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type userpermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: userpermissionScalarWhereInput
    data: XOR<userpermissionUpdateManyMutationInput, userpermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type userpermissionScalarWhereInput = {
    AND?: userpermissionScalarWhereInput | userpermissionScalarWhereInput[]
    OR?: userpermissionScalarWhereInput[]
    NOT?: userpermissionScalarWhereInput | userpermissionScalarWhereInput[]
    id?: StringFilter<"userpermission"> | string
    userid?: StringFilter<"userpermission"> | string
    permissionid?: StringFilter<"userpermission"> | string
    createdby?: StringFilter<"userpermission"> | string
    createdat?: DateTimeFilter<"userpermission"> | Date | string
    updatedby?: StringNullableFilter<"userpermission"> | string | null
    updatedat?: DateTimeNullableFilter<"userpermission"> | Date | string | null
  }

  export type userCreateWithoutCreatedrolepermissionsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCreatedrolepermissionsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCreatedrolepermissionsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCreatedrolepermissionsInput, userUncheckedCreateWithoutCreatedrolepermissionsInput>
  }

  export type permissionCreateWithoutRolepermissionsInput = {
    id?: string
    name: string
    value: string
    group: string
    description: string
    createdat?: Date | string
    updatedat?: Date | string | null
    createduser: userCreateNestedOneWithoutCreatedpermissionsInput
    updateduser?: userCreateNestedOneWithoutUpdatedpermissionsInput
    userpermissions?: userpermissionCreateNestedManyWithoutPermissionInput
  }

  export type permissionUncheckedCreateWithoutRolepermissionsInput = {
    id?: string
    name: string
    value: string
    group: string
    description: string
    createdby: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type permissionCreateOrConnectWithoutRolepermissionsInput = {
    where: permissionWhereUniqueInput
    create: XOR<permissionCreateWithoutRolepermissionsInput, permissionUncheckedCreateWithoutRolepermissionsInput>
  }

  export type roleCreateWithoutRolepermissionsInput = {
    id?: string
    name: string
    createdat?: Date | string
    updatedat?: Date | string | null
    issystemrole?: boolean
    createduser: userCreateNestedOneWithoutCreatedrolesInput
    updateduser?: userCreateNestedOneWithoutUpdatedrolesInput
    userroles?: userroleCreateNestedManyWithoutRoleInput
  }

  export type roleUncheckedCreateWithoutRolepermissionsInput = {
    id?: string
    name: string
    createdby: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
    issystemrole?: boolean
    userroles?: userroleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type roleCreateOrConnectWithoutRolepermissionsInput = {
    where: roleWhereUniqueInput
    create: XOR<roleCreateWithoutRolepermissionsInput, roleUncheckedCreateWithoutRolepermissionsInput>
  }

  export type userCreateWithoutUpdatedrolepermissionsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUpdatedrolepermissionsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUpdatedrolepermissionsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUpdatedrolepermissionsInput, userUncheckedCreateWithoutUpdatedrolepermissionsInput>
  }

  export type userUpsertWithoutCreatedrolepermissionsInput = {
    update: XOR<userUpdateWithoutCreatedrolepermissionsInput, userUncheckedUpdateWithoutCreatedrolepermissionsInput>
    create: XOR<userCreateWithoutCreatedrolepermissionsInput, userUncheckedCreateWithoutCreatedrolepermissionsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutCreatedrolepermissionsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutCreatedrolepermissionsInput, userUncheckedUpdateWithoutCreatedrolepermissionsInput>
  }

  export type userUpdateWithoutCreatedrolepermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutCreatedrolepermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type permissionUpsertWithoutRolepermissionsInput = {
    update: XOR<permissionUpdateWithoutRolepermissionsInput, permissionUncheckedUpdateWithoutRolepermissionsInput>
    create: XOR<permissionCreateWithoutRolepermissionsInput, permissionUncheckedCreateWithoutRolepermissionsInput>
    where?: permissionWhereInput
  }

  export type permissionUpdateToOneWithWhereWithoutRolepermissionsInput = {
    where?: permissionWhereInput
    data: XOR<permissionUpdateWithoutRolepermissionsInput, permissionUncheckedUpdateWithoutRolepermissionsInput>
  }

  export type permissionUpdateWithoutRolepermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createduser?: userUpdateOneRequiredWithoutCreatedpermissionsNestedInput
    updateduser?: userUpdateOneWithoutUpdatedpermissionsNestedInput
    userpermissions?: userpermissionUpdateManyWithoutPermissionNestedInput
  }

  export type permissionUncheckedUpdateWithoutRolepermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userpermissions?: userpermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type roleUpsertWithoutRolepermissionsInput = {
    update: XOR<roleUpdateWithoutRolepermissionsInput, roleUncheckedUpdateWithoutRolepermissionsInput>
    create: XOR<roleCreateWithoutRolepermissionsInput, roleUncheckedCreateWithoutRolepermissionsInput>
    where?: roleWhereInput
  }

  export type roleUpdateToOneWithWhereWithoutRolepermissionsInput = {
    where?: roleWhereInput
    data: XOR<roleUpdateWithoutRolepermissionsInput, roleUncheckedUpdateWithoutRolepermissionsInput>
  }

  export type roleUpdateWithoutRolepermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issystemrole?: BoolFieldUpdateOperationsInput | boolean
    createduser?: userUpdateOneRequiredWithoutCreatedrolesNestedInput
    updateduser?: userUpdateOneWithoutUpdatedrolesNestedInput
    userroles?: userroleUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateWithoutRolepermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issystemrole?: BoolFieldUpdateOperationsInput | boolean
    userroles?: userroleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type userUpsertWithoutUpdatedrolepermissionsInput = {
    update: XOR<userUpdateWithoutUpdatedrolepermissionsInput, userUncheckedUpdateWithoutUpdatedrolepermissionsInput>
    create: XOR<userCreateWithoutUpdatedrolepermissionsInput, userUncheckedCreateWithoutUpdatedrolepermissionsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUpdatedrolepermissionsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUpdatedrolepermissionsInput, userUncheckedUpdateWithoutUpdatedrolepermissionsInput>
  }

  export type userUpdateWithoutUpdatedrolepermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUpdatedrolepermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutTransactionsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutTransactionsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutTransactionsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutTransactionsInput, userUncheckedCreateWithoutTransactionsInput>
  }

  export type userUpsertWithoutTransactionsInput = {
    update: XOR<userUpdateWithoutTransactionsInput, userUncheckedUpdateWithoutTransactionsInput>
    create: XOR<userCreateWithoutTransactionsInput, userUncheckedCreateWithoutTransactionsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutTransactionsInput, userUncheckedUpdateWithoutTransactionsInput>
  }

  export type userUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutEntrancesInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutEntrancesInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutEntrancesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutEntrancesInput, userUncheckedCreateWithoutEntrancesInput>
  }

  export type userUpsertWithoutEntrancesInput = {
    update: XOR<userUpdateWithoutEntrancesInput, userUncheckedUpdateWithoutEntrancesInput>
    create: XOR<userCreateWithoutEntrancesInput, userUncheckedCreateWithoutEntrancesInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutEntrancesInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutEntrancesInput, userUncheckedUpdateWithoutEntrancesInput>
  }

  export type userUpdateWithoutEntrancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutEntrancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutCreateduserpermissionsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCreateduserpermissionsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCreateduserpermissionsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCreateduserpermissionsInput, userUncheckedCreateWithoutCreateduserpermissionsInput>
  }

  export type permissionCreateWithoutUserpermissionsInput = {
    id?: string
    name: string
    value: string
    group: string
    description: string
    createdat?: Date | string
    updatedat?: Date | string | null
    createduser: userCreateNestedOneWithoutCreatedpermissionsInput
    updateduser?: userCreateNestedOneWithoutUpdatedpermissionsInput
    rolepermissions?: rolepermissionCreateNestedManyWithoutPermissionInput
  }

  export type permissionUncheckedCreateWithoutUserpermissionsInput = {
    id?: string
    name: string
    value: string
    group: string
    description: string
    createdby: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
    rolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type permissionCreateOrConnectWithoutUserpermissionsInput = {
    where: permissionWhereUniqueInput
    create: XOR<permissionCreateWithoutUserpermissionsInput, permissionUncheckedCreateWithoutUserpermissionsInput>
  }

  export type userCreateWithoutUpdateduserpermissionsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUpdateduserpermissionsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUpdateduserpermissionsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUpdateduserpermissionsInput, userUncheckedCreateWithoutUpdateduserpermissionsInput>
  }

  export type userCreateWithoutUserpermissionsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUserpermissionsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUserpermissionsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUserpermissionsInput, userUncheckedCreateWithoutUserpermissionsInput>
  }

  export type userUpsertWithoutCreateduserpermissionsInput = {
    update: XOR<userUpdateWithoutCreateduserpermissionsInput, userUncheckedUpdateWithoutCreateduserpermissionsInput>
    create: XOR<userCreateWithoutCreateduserpermissionsInput, userUncheckedCreateWithoutCreateduserpermissionsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutCreateduserpermissionsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutCreateduserpermissionsInput, userUncheckedUpdateWithoutCreateduserpermissionsInput>
  }

  export type userUpdateWithoutCreateduserpermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutCreateduserpermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type permissionUpsertWithoutUserpermissionsInput = {
    update: XOR<permissionUpdateWithoutUserpermissionsInput, permissionUncheckedUpdateWithoutUserpermissionsInput>
    create: XOR<permissionCreateWithoutUserpermissionsInput, permissionUncheckedCreateWithoutUserpermissionsInput>
    where?: permissionWhereInput
  }

  export type permissionUpdateToOneWithWhereWithoutUserpermissionsInput = {
    where?: permissionWhereInput
    data: XOR<permissionUpdateWithoutUserpermissionsInput, permissionUncheckedUpdateWithoutUserpermissionsInput>
  }

  export type permissionUpdateWithoutUserpermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createduser?: userUpdateOneRequiredWithoutCreatedpermissionsNestedInput
    updateduser?: userUpdateOneWithoutUpdatedpermissionsNestedInput
    rolepermissions?: rolepermissionUpdateManyWithoutPermissionNestedInput
  }

  export type permissionUncheckedUpdateWithoutUserpermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rolepermissions?: rolepermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type userUpsertWithoutUpdateduserpermissionsInput = {
    update: XOR<userUpdateWithoutUpdateduserpermissionsInput, userUncheckedUpdateWithoutUpdateduserpermissionsInput>
    create: XOR<userCreateWithoutUpdateduserpermissionsInput, userUncheckedCreateWithoutUpdateduserpermissionsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUpdateduserpermissionsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUpdateduserpermissionsInput, userUncheckedUpdateWithoutUpdateduserpermissionsInput>
  }

  export type userUpdateWithoutUpdateduserpermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUpdateduserpermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUpsertWithoutUserpermissionsInput = {
    update: XOR<userUpdateWithoutUserpermissionsInput, userUncheckedUpdateWithoutUserpermissionsInput>
    create: XOR<userCreateWithoutUserpermissionsInput, userUncheckedCreateWithoutUserpermissionsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUserpermissionsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUserpermissionsInput, userUncheckedUpdateWithoutUserpermissionsInput>
  }

  export type userUpdateWithoutUserpermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUserpermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutCreateduserrolesInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCreateduserrolesInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCreateduserrolesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCreateduserrolesInput, userUncheckedCreateWithoutCreateduserrolesInput>
  }

  export type roleCreateWithoutUserrolesInput = {
    id?: string
    name: string
    createdat?: Date | string
    updatedat?: Date | string | null
    issystemrole?: boolean
    createduser: userCreateNestedOneWithoutCreatedrolesInput
    updateduser?: userCreateNestedOneWithoutUpdatedrolesInput
    rolepermissions?: rolepermissionCreateNestedManyWithoutRoleInput
  }

  export type roleUncheckedCreateWithoutUserrolesInput = {
    id?: string
    name: string
    createdby: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
    issystemrole?: boolean
    rolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type roleCreateOrConnectWithoutUserrolesInput = {
    where: roleWhereUniqueInput
    create: XOR<roleCreateWithoutUserrolesInput, roleUncheckedCreateWithoutUserrolesInput>
  }

  export type userCreateWithoutUpdateduserrolesInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUpdateduserrolesInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUpdateduserrolesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUpdateduserrolesInput, userUncheckedCreateWithoutUpdateduserrolesInput>
  }

  export type userCreateWithoutUserrolesInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
  }

  export type userUncheckedCreateWithoutUserrolesInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
  }

  export type userCreateOrConnectWithoutUserrolesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUserrolesInput, userUncheckedCreateWithoutUserrolesInput>
  }

  export type userUpsertWithoutCreateduserrolesInput = {
    update: XOR<userUpdateWithoutCreateduserrolesInput, userUncheckedUpdateWithoutCreateduserrolesInput>
    create: XOR<userCreateWithoutCreateduserrolesInput, userUncheckedCreateWithoutCreateduserrolesInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutCreateduserrolesInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutCreateduserrolesInput, userUncheckedUpdateWithoutCreateduserrolesInput>
  }

  export type userUpdateWithoutCreateduserrolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutCreateduserrolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type roleUpsertWithoutUserrolesInput = {
    update: XOR<roleUpdateWithoutUserrolesInput, roleUncheckedUpdateWithoutUserrolesInput>
    create: XOR<roleCreateWithoutUserrolesInput, roleUncheckedCreateWithoutUserrolesInput>
    where?: roleWhereInput
  }

  export type roleUpdateToOneWithWhereWithoutUserrolesInput = {
    where?: roleWhereInput
    data: XOR<roleUpdateWithoutUserrolesInput, roleUncheckedUpdateWithoutUserrolesInput>
  }

  export type roleUpdateWithoutUserrolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issystemrole?: BoolFieldUpdateOperationsInput | boolean
    createduser?: userUpdateOneRequiredWithoutCreatedrolesNestedInput
    updateduser?: userUpdateOneWithoutUpdatedrolesNestedInput
    rolepermissions?: rolepermissionUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateWithoutUserrolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issystemrole?: BoolFieldUpdateOperationsInput | boolean
    rolepermissions?: rolepermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type userUpsertWithoutUpdateduserrolesInput = {
    update: XOR<userUpdateWithoutUpdateduserrolesInput, userUncheckedUpdateWithoutUpdateduserrolesInput>
    create: XOR<userCreateWithoutUpdateduserrolesInput, userUncheckedCreateWithoutUpdateduserrolesInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUpdateduserrolesInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUpdateduserrolesInput, userUncheckedUpdateWithoutUpdateduserrolesInput>
  }

  export type userUpdateWithoutUpdateduserrolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUpdateduserrolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUpsertWithoutUserrolesInput = {
    update: XOR<userUpdateWithoutUserrolesInput, userUncheckedUpdateWithoutUserrolesInput>
    create: XOR<userCreateWithoutUserrolesInput, userUncheckedCreateWithoutUserrolesInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUserrolesInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUserrolesInput, userUncheckedUpdateWithoutUserrolesInput>
  }

  export type userUpdateWithoutUserrolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
  }

  export type userUncheckedUpdateWithoutUserrolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
  }

  export type invoiceCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    createdat?: Date | string
    status?: string
    customer: customerCreateNestedOneWithoutInvoicesInput
    payments?: paymentCreateNestedManyWithoutInvoiceInput
  }

  export type invoiceUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    customerId: string
    createdat?: Date | string
    status?: string
    payments?: paymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type invoiceCreateOrConnectWithoutUserInput = {
    where: invoiceWhereUniqueInput
    create: XOR<invoiceCreateWithoutUserInput, invoiceUncheckedCreateWithoutUserInput>
  }

  export type invoiceCreateManyUserInputEnvelope = {
    data: invoiceCreateManyUserInput | invoiceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type subscriptionCreateWithoutUserInput = {
    id?: string
    stripeId?: string | null
    status?: string
    startedat?: Date | string
    endedat?: Date | string | null
    canceledat?: Date | string | null
    plan: planCreateNestedOneWithoutSubscriptionsInput
  }

  export type subscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    planId: string
    stripeId?: string | null
    status?: string
    startedat?: Date | string
    endedat?: Date | string | null
    canceledat?: Date | string | null
  }

  export type subscriptionCreateOrConnectWithoutUserInput = {
    where: subscriptionWhereUniqueInput
    create: XOR<subscriptionCreateWithoutUserInput, subscriptionUncheckedCreateWithoutUserInput>
  }

  export type subscriptionCreateManyUserInputEnvelope = {
    data: subscriptionCreateManyUserInput | subscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type customerCreateWithoutUserInput = {
    id?: string
    name: string
    email: string
    createdat?: Date | string
    invoices?: invoiceCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    email: string
    createdat?: Date | string
    invoices?: invoiceUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerCreateOrConnectWithoutUserInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutUserInput, customerUncheckedCreateWithoutUserInput>
  }

  export type customerCreateManyUserInputEnvelope = {
    data: customerCreateManyUserInput | customerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type parametersCreateWithoutUserInput = {
    id?: string
    key: string
    name: string
    value: string
    createdat?: Date | string
    status?: number
  }

  export type parametersUncheckedCreateWithoutUserInput = {
    id?: string
    key: string
    name: string
    value: string
    createdat?: Date | string
    status?: number
  }

  export type parametersCreateOrConnectWithoutUserInput = {
    where: parametersWhereUniqueInput
    create: XOR<parametersCreateWithoutUserInput, parametersUncheckedCreateWithoutUserInput>
  }

  export type parametersCreateManyUserInputEnvelope = {
    data: parametersCreateManyUserInput | parametersCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type entranceCreateWithoutUserInput = {
    id?: string
    type: string
    useragent: string
    ipaddress: string
    createdat?: Date | string
  }

  export type entranceUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    useragent: string
    ipaddress: string
    createdat?: Date | string
  }

  export type entranceCreateOrConnectWithoutUserInput = {
    where: entranceWhereUniqueInput
    create: XOR<entranceCreateWithoutUserInput, entranceUncheckedCreateWithoutUserInput>
  }

  export type entranceCreateManyUserInputEnvelope = {
    data: entranceCreateManyUserInput | entranceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type paymentCreateWithoutUserInput = {
    id?: string
    amount: string
    currency: string
    stripeId?: string | null
    status?: string
    createdat?: Date | string
    invoice: invoiceCreateNestedOneWithoutPaymentsInput
  }

  export type paymentUncheckedCreateWithoutUserInput = {
    id?: string
    amount: string
    currency: string
    invoiceId: string
    stripeId?: string | null
    status?: string
    createdat?: Date | string
  }

  export type paymentCreateOrConnectWithoutUserInput = {
    where: paymentWhereUniqueInput
    create: XOR<paymentCreateWithoutUserInput, paymentUncheckedCreateWithoutUserInput>
  }

  export type paymentCreateManyUserInputEnvelope = {
    data: paymentCreateManyUserInput | paymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type planCreateWithoutUsersInput = {
    id?: string
    name: string
    price: string
    currency: string
    interval: string
    description?: string | null
    stripePriceId?: string | null
    stripeProductId?: string | null
    createdat?: Date | string
    subscriptions?: subscriptionCreateNestedManyWithoutPlanInput
  }

  export type planUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    price: string
    currency: string
    interval: string
    description?: string | null
    stripePriceId?: string | null
    stripeProductId?: string | null
    createdat?: Date | string
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type planCreateOrConnectWithoutUsersInput = {
    where: planWhereUniqueInput
    create: XOR<planCreateWithoutUsersInput, planUncheckedCreateWithoutUsersInput>
  }

  export type transactionCreateWithoutUserInput = {
    id?: string
    type: number
    useragent: string
    ipaddress: string
    createdat?: Date | string
  }

  export type transactionUncheckedCreateWithoutUserInput = {
    id?: string
    type: number
    useragent: string
    ipaddress: string
    createdat?: Date | string
  }

  export type transactionCreateOrConnectWithoutUserInput = {
    where: transactionWhereUniqueInput
    create: XOR<transactionCreateWithoutUserInput, transactionUncheckedCreateWithoutUserInput>
  }

  export type transactionCreateManyUserInputEnvelope = {
    data: transactionCreateManyUserInput | transactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type notificationCreateWithoutToInput = {
    id?: string
    message: string
    url: string
    createdby: string
    createdat?: Date | string
    readedat?: Date | string | null
  }

  export type notificationUncheckedCreateWithoutToInput = {
    id?: string
    message: string
    url: string
    createdby: string
    createdat?: Date | string
    readedat?: Date | string | null
  }

  export type notificationCreateOrConnectWithoutToInput = {
    where: notificationWhereUniqueInput
    create: XOR<notificationCreateWithoutToInput, notificationUncheckedCreateWithoutToInput>
  }

  export type notificationCreateManyToInputEnvelope = {
    data: notificationCreateManyToInput | notificationCreateManyToInput[]
    skipDuplicates?: boolean
  }

  export type apiclientCreateWithoutCreateduserInput = {
    id?: string
    name: string
    key: string
    secret: string
    type: number
    createdat?: Date | string
    updatedat?: Date | string | null
    isactive: boolean
    updateduser?: userCreateNestedOneWithoutUpdatedapiclientsInput
  }

  export type apiclientUncheckedCreateWithoutCreateduserInput = {
    id?: string
    name: string
    key: string
    secret: string
    type: number
    createdat?: Date | string
    updatedat?: Date | string | null
    updatedby?: string | null
    isactive: boolean
  }

  export type apiclientCreateOrConnectWithoutCreateduserInput = {
    where: apiclientWhereUniqueInput
    create: XOR<apiclientCreateWithoutCreateduserInput, apiclientUncheckedCreateWithoutCreateduserInput>
  }

  export type apiclientCreateManyCreateduserInputEnvelope = {
    data: apiclientCreateManyCreateduserInput | apiclientCreateManyCreateduserInput[]
    skipDuplicates?: boolean
  }

  export type apiclientCreateWithoutUpdateduserInput = {
    id?: string
    name: string
    key: string
    secret: string
    type: number
    createdat?: Date | string
    updatedat?: Date | string | null
    isactive: boolean
    createduser: userCreateNestedOneWithoutCreatedapiclientsInput
  }

  export type apiclientUncheckedCreateWithoutUpdateduserInput = {
    id?: string
    name: string
    key: string
    secret: string
    type: number
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    isactive: boolean
  }

  export type apiclientCreateOrConnectWithoutUpdateduserInput = {
    where: apiclientWhereUniqueInput
    create: XOR<apiclientCreateWithoutUpdateduserInput, apiclientUncheckedCreateWithoutUpdateduserInput>
  }

  export type apiclientCreateManyUpdateduserInputEnvelope = {
    data: apiclientCreateManyUpdateduserInput | apiclientCreateManyUpdateduserInput[]
    skipDuplicates?: boolean
  }

  export type permissionCreateWithoutCreateduserInput = {
    id?: string
    name: string
    value: string
    group: string
    description: string
    createdat?: Date | string
    updatedat?: Date | string | null
    updateduser?: userCreateNestedOneWithoutUpdatedpermissionsInput
    rolepermissions?: rolepermissionCreateNestedManyWithoutPermissionInput
    userpermissions?: userpermissionCreateNestedManyWithoutPermissionInput
  }

  export type permissionUncheckedCreateWithoutCreateduserInput = {
    id?: string
    name: string
    value: string
    group: string
    description: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
    rolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutPermissionInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type permissionCreateOrConnectWithoutCreateduserInput = {
    where: permissionWhereUniqueInput
    create: XOR<permissionCreateWithoutCreateduserInput, permissionUncheckedCreateWithoutCreateduserInput>
  }

  export type permissionCreateManyCreateduserInputEnvelope = {
    data: permissionCreateManyCreateduserInput | permissionCreateManyCreateduserInput[]
    skipDuplicates?: boolean
  }

  export type permissionCreateWithoutUpdateduserInput = {
    id?: string
    name: string
    value: string
    group: string
    description: string
    createdat?: Date | string
    updatedat?: Date | string | null
    createduser: userCreateNestedOneWithoutCreatedpermissionsInput
    rolepermissions?: rolepermissionCreateNestedManyWithoutPermissionInput
    userpermissions?: userpermissionCreateNestedManyWithoutPermissionInput
  }

  export type permissionUncheckedCreateWithoutUpdateduserInput = {
    id?: string
    name: string
    value: string
    group: string
    description: string
    createdby: string
    createdat?: Date | string
    updatedat?: Date | string | null
    rolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutPermissionInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type permissionCreateOrConnectWithoutUpdateduserInput = {
    where: permissionWhereUniqueInput
    create: XOR<permissionCreateWithoutUpdateduserInput, permissionUncheckedCreateWithoutUpdateduserInput>
  }

  export type permissionCreateManyUpdateduserInputEnvelope = {
    data: permissionCreateManyUpdateduserInput | permissionCreateManyUpdateduserInput[]
    skipDuplicates?: boolean
  }

  export type refreshtokenCreateWithoutUserInput = {
    id?: string
    token: string
    createdat?: Date | string
    updatedat?: Date | string | null
    expiresat?: Date | string | null
  }

  export type refreshtokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    createdat?: Date | string
    updatedat?: Date | string | null
    expiresat?: Date | string | null
  }

  export type refreshtokenCreateOrConnectWithoutUserInput = {
    where: refreshtokenWhereUniqueInput
    create: XOR<refreshtokenCreateWithoutUserInput, refreshtokenUncheckedCreateWithoutUserInput>
  }

  export type refreshtokenCreateManyUserInputEnvelope = {
    data: refreshtokenCreateManyUserInput | refreshtokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type roleCreateWithoutCreateduserInput = {
    id?: string
    name: string
    createdat?: Date | string
    updatedat?: Date | string | null
    issystemrole?: boolean
    updateduser?: userCreateNestedOneWithoutUpdatedrolesInput
    rolepermissions?: rolepermissionCreateNestedManyWithoutRoleInput
    userroles?: userroleCreateNestedManyWithoutRoleInput
  }

  export type roleUncheckedCreateWithoutCreateduserInput = {
    id?: string
    name: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
    issystemrole?: boolean
    rolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutRoleInput
    userroles?: userroleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type roleCreateOrConnectWithoutCreateduserInput = {
    where: roleWhereUniqueInput
    create: XOR<roleCreateWithoutCreateduserInput, roleUncheckedCreateWithoutCreateduserInput>
  }

  export type roleCreateManyCreateduserInputEnvelope = {
    data: roleCreateManyCreateduserInput | roleCreateManyCreateduserInput[]
    skipDuplicates?: boolean
  }

  export type roleCreateWithoutUpdateduserInput = {
    id?: string
    name: string
    createdat?: Date | string
    updatedat?: Date | string | null
    issystemrole?: boolean
    createduser: userCreateNestedOneWithoutCreatedrolesInput
    rolepermissions?: rolepermissionCreateNestedManyWithoutRoleInput
    userroles?: userroleCreateNestedManyWithoutRoleInput
  }

  export type roleUncheckedCreateWithoutUpdateduserInput = {
    id?: string
    name: string
    createdby: string
    createdat?: Date | string
    updatedat?: Date | string | null
    issystemrole?: boolean
    rolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutRoleInput
    userroles?: userroleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type roleCreateOrConnectWithoutUpdateduserInput = {
    where: roleWhereUniqueInput
    create: XOR<roleCreateWithoutUpdateduserInput, roleUncheckedCreateWithoutUpdateduserInput>
  }

  export type roleCreateManyUpdateduserInputEnvelope = {
    data: roleCreateManyUpdateduserInput | roleCreateManyUpdateduserInput[]
    skipDuplicates?: boolean
  }

  export type rolepermissionCreateWithoutCreateduserInput = {
    id?: string
    createdat?: Date | string
    updatedat?: Date | string | null
    permission: permissionCreateNestedOneWithoutRolepermissionsInput
    role: roleCreateNestedOneWithoutRolepermissionsInput
    updateduser?: userCreateNestedOneWithoutUpdatedrolepermissionsInput
  }

  export type rolepermissionUncheckedCreateWithoutCreateduserInput = {
    id?: string
    roleid: string
    permissionid: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type rolepermissionCreateOrConnectWithoutCreateduserInput = {
    where: rolepermissionWhereUniqueInput
    create: XOR<rolepermissionCreateWithoutCreateduserInput, rolepermissionUncheckedCreateWithoutCreateduserInput>
  }

  export type rolepermissionCreateManyCreateduserInputEnvelope = {
    data: rolepermissionCreateManyCreateduserInput | rolepermissionCreateManyCreateduserInput[]
    skipDuplicates?: boolean
  }

  export type rolepermissionCreateWithoutUpdateduserInput = {
    id?: string
    createdat?: Date | string
    updatedat?: Date | string | null
    createduser: userCreateNestedOneWithoutCreatedrolepermissionsInput
    permission: permissionCreateNestedOneWithoutRolepermissionsInput
    role: roleCreateNestedOneWithoutRolepermissionsInput
  }

  export type rolepermissionUncheckedCreateWithoutUpdateduserInput = {
    id?: string
    roleid: string
    permissionid: string
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
  }

  export type rolepermissionCreateOrConnectWithoutUpdateduserInput = {
    where: rolepermissionWhereUniqueInput
    create: XOR<rolepermissionCreateWithoutUpdateduserInput, rolepermissionUncheckedCreateWithoutUpdateduserInput>
  }

  export type rolepermissionCreateManyUpdateduserInputEnvelope = {
    data: rolepermissionCreateManyUpdateduserInput | rolepermissionCreateManyUpdateduserInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutCreatedusersInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCreatedusersInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCreatedusersInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCreatedusersInput, userUncheckedCreateWithoutCreatedusersInput>
  }

  export type userCreateWithoutCreateduserInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCreateduserInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCreateduserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCreateduserInput, userUncheckedCreateWithoutCreateduserInput>
  }

  export type userCreateManyCreateduserInputEnvelope = {
    data: userCreateManyCreateduserInput | userCreateManyCreateduserInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutUpdatedusersInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUpdatedusersInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUpdatedusersInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUpdatedusersInput, userUncheckedCreateWithoutUpdatedusersInput>
  }

  export type userCreateWithoutUpdateduserInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUpdateduserInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUpdateduserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUpdateduserInput, userUncheckedCreateWithoutUpdateduserInput>
  }

  export type userCreateManyUpdateduserInputEnvelope = {
    data: userCreateManyUpdateduserInput | userCreateManyUpdateduserInput[]
    skipDuplicates?: boolean
  }

  export type userpermissionCreateWithoutCreateduserInput = {
    id?: string
    createdat?: Date | string
    updatedat?: Date | string | null
    permission: permissionCreateNestedOneWithoutUserpermissionsInput
    updateduser?: userCreateNestedOneWithoutUpdateduserpermissionsInput
    user: userCreateNestedOneWithoutUserpermissionsInput
  }

  export type userpermissionUncheckedCreateWithoutCreateduserInput = {
    id?: string
    userid: string
    permissionid: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type userpermissionCreateOrConnectWithoutCreateduserInput = {
    where: userpermissionWhereUniqueInput
    create: XOR<userpermissionCreateWithoutCreateduserInput, userpermissionUncheckedCreateWithoutCreateduserInput>
  }

  export type userpermissionCreateManyCreateduserInputEnvelope = {
    data: userpermissionCreateManyCreateduserInput | userpermissionCreateManyCreateduserInput[]
    skipDuplicates?: boolean
  }

  export type userpermissionCreateWithoutUpdateduserInput = {
    id?: string
    createdat?: Date | string
    updatedat?: Date | string | null
    createduser: userCreateNestedOneWithoutCreateduserpermissionsInput
    permission: permissionCreateNestedOneWithoutUserpermissionsInput
    user: userCreateNestedOneWithoutUserpermissionsInput
  }

  export type userpermissionUncheckedCreateWithoutUpdateduserInput = {
    id?: string
    userid: string
    permissionid: string
    createdby: string
    createdat?: Date | string
    updatedat?: Date | string | null
  }

  export type userpermissionCreateOrConnectWithoutUpdateduserInput = {
    where: userpermissionWhereUniqueInput
    create: XOR<userpermissionCreateWithoutUpdateduserInput, userpermissionUncheckedCreateWithoutUpdateduserInput>
  }

  export type userpermissionCreateManyUpdateduserInputEnvelope = {
    data: userpermissionCreateManyUpdateduserInput | userpermissionCreateManyUpdateduserInput[]
    skipDuplicates?: boolean
  }

  export type userpermissionCreateWithoutUserInput = {
    id?: string
    createdat?: Date | string
    updatedat?: Date | string | null
    createduser: userCreateNestedOneWithoutCreateduserpermissionsInput
    permission: permissionCreateNestedOneWithoutUserpermissionsInput
    updateduser?: userCreateNestedOneWithoutUpdateduserpermissionsInput
  }

  export type userpermissionUncheckedCreateWithoutUserInput = {
    id?: string
    permissionid: string
    createdby: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type userpermissionCreateOrConnectWithoutUserInput = {
    where: userpermissionWhereUniqueInput
    create: XOR<userpermissionCreateWithoutUserInput, userpermissionUncheckedCreateWithoutUserInput>
  }

  export type userpermissionCreateManyUserInputEnvelope = {
    data: userpermissionCreateManyUserInput | userpermissionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type userroleCreateWithoutCreateduserInput = {
    id?: string
    createdat?: Date | string
    updatedat?: Date | string | null
    role: roleCreateNestedOneWithoutUserrolesInput
    updateduser?: userCreateNestedOneWithoutUpdateduserrolesInput
    user: userCreateNestedOneWithoutUserrolesInput
  }

  export type userroleUncheckedCreateWithoutCreateduserInput = {
    id?: string
    userid: string
    roleid: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type userroleCreateOrConnectWithoutCreateduserInput = {
    where: userroleWhereUniqueInput
    create: XOR<userroleCreateWithoutCreateduserInput, userroleUncheckedCreateWithoutCreateduserInput>
  }

  export type userroleCreateManyCreateduserInputEnvelope = {
    data: userroleCreateManyCreateduserInput | userroleCreateManyCreateduserInput[]
    skipDuplicates?: boolean
  }

  export type userroleCreateWithoutUpdateduserInput = {
    id?: string
    createdat?: Date | string
    updatedat?: Date | string | null
    createduser: userCreateNestedOneWithoutCreateduserrolesInput
    role: roleCreateNestedOneWithoutUserrolesInput
    user: userCreateNestedOneWithoutUserrolesInput
  }

  export type userroleUncheckedCreateWithoutUpdateduserInput = {
    id?: string
    userid: string
    roleid: string
    createdby: string
    createdat?: Date | string
    updatedat?: Date | string | null
  }

  export type userroleCreateOrConnectWithoutUpdateduserInput = {
    where: userroleWhereUniqueInput
    create: XOR<userroleCreateWithoutUpdateduserInput, userroleUncheckedCreateWithoutUpdateduserInput>
  }

  export type userroleCreateManyUpdateduserInputEnvelope = {
    data: userroleCreateManyUpdateduserInput | userroleCreateManyUpdateduserInput[]
    skipDuplicates?: boolean
  }

  export type userroleCreateWithoutUserInput = {
    id?: string
    createdat?: Date | string
    updatedat?: Date | string | null
    createduser: userCreateNestedOneWithoutCreateduserrolesInput
    role: roleCreateNestedOneWithoutUserrolesInput
    updateduser?: userCreateNestedOneWithoutUpdateduserrolesInput
  }

  export type userroleUncheckedCreateWithoutUserInput = {
    id?: string
    roleid: string
    createdby: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type userroleCreateOrConnectWithoutUserInput = {
    where: userroleWhereUniqueInput
    create: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput>
  }

  export type userroleCreateManyUserInputEnvelope = {
    data: userroleCreateManyUserInput | userroleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type invoiceUpsertWithWhereUniqueWithoutUserInput = {
    where: invoiceWhereUniqueInput
    update: XOR<invoiceUpdateWithoutUserInput, invoiceUncheckedUpdateWithoutUserInput>
    create: XOR<invoiceCreateWithoutUserInput, invoiceUncheckedCreateWithoutUserInput>
  }

  export type invoiceUpdateWithWhereUniqueWithoutUserInput = {
    where: invoiceWhereUniqueInput
    data: XOR<invoiceUpdateWithoutUserInput, invoiceUncheckedUpdateWithoutUserInput>
  }

  export type invoiceUpdateManyWithWhereWithoutUserInput = {
    where: invoiceScalarWhereInput
    data: XOR<invoiceUpdateManyMutationInput, invoiceUncheckedUpdateManyWithoutUserInput>
  }

  export type invoiceScalarWhereInput = {
    AND?: invoiceScalarWhereInput | invoiceScalarWhereInput[]
    OR?: invoiceScalarWhereInput[]
    NOT?: invoiceScalarWhereInput | invoiceScalarWhereInput[]
    id?: StringFilter<"invoice"> | string
    title?: StringFilter<"invoice"> | string
    description?: StringNullableFilter<"invoice"> | string | null
    amount?: IntFilter<"invoice"> | number
    userId?: StringFilter<"invoice"> | string
    customerId?: StringFilter<"invoice"> | string
    createdat?: DateTimeFilter<"invoice"> | Date | string
    status?: StringFilter<"invoice"> | string
  }

  export type subscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: subscriptionWhereUniqueInput
    update: XOR<subscriptionUpdateWithoutUserInput, subscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<subscriptionCreateWithoutUserInput, subscriptionUncheckedCreateWithoutUserInput>
  }

  export type subscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: subscriptionWhereUniqueInput
    data: XOR<subscriptionUpdateWithoutUserInput, subscriptionUncheckedUpdateWithoutUserInput>
  }

  export type subscriptionUpdateManyWithWhereWithoutUserInput = {
    where: subscriptionScalarWhereInput
    data: XOR<subscriptionUpdateManyMutationInput, subscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type subscriptionScalarWhereInput = {
    AND?: subscriptionScalarWhereInput | subscriptionScalarWhereInput[]
    OR?: subscriptionScalarWhereInput[]
    NOT?: subscriptionScalarWhereInput | subscriptionScalarWhereInput[]
    id?: StringFilter<"subscription"> | string
    userId?: StringFilter<"subscription"> | string
    planId?: StringFilter<"subscription"> | string
    stripeId?: StringNullableFilter<"subscription"> | string | null
    status?: StringFilter<"subscription"> | string
    startedat?: DateTimeFilter<"subscription"> | Date | string
    endedat?: DateTimeNullableFilter<"subscription"> | Date | string | null
    canceledat?: DateTimeNullableFilter<"subscription"> | Date | string | null
  }

  export type customerUpsertWithWhereUniqueWithoutUserInput = {
    where: customerWhereUniqueInput
    update: XOR<customerUpdateWithoutUserInput, customerUncheckedUpdateWithoutUserInput>
    create: XOR<customerCreateWithoutUserInput, customerUncheckedCreateWithoutUserInput>
  }

  export type customerUpdateWithWhereUniqueWithoutUserInput = {
    where: customerWhereUniqueInput
    data: XOR<customerUpdateWithoutUserInput, customerUncheckedUpdateWithoutUserInput>
  }

  export type customerUpdateManyWithWhereWithoutUserInput = {
    where: customerScalarWhereInput
    data: XOR<customerUpdateManyMutationInput, customerUncheckedUpdateManyWithoutUserInput>
  }

  export type customerScalarWhereInput = {
    AND?: customerScalarWhereInput | customerScalarWhereInput[]
    OR?: customerScalarWhereInput[]
    NOT?: customerScalarWhereInput | customerScalarWhereInput[]
    id?: StringFilter<"customer"> | string
    userId?: StringFilter<"customer"> | string
    name?: StringFilter<"customer"> | string
    email?: StringFilter<"customer"> | string
    createdat?: DateTimeFilter<"customer"> | Date | string
  }

  export type parametersUpsertWithWhereUniqueWithoutUserInput = {
    where: parametersWhereUniqueInput
    update: XOR<parametersUpdateWithoutUserInput, parametersUncheckedUpdateWithoutUserInput>
    create: XOR<parametersCreateWithoutUserInput, parametersUncheckedCreateWithoutUserInput>
  }

  export type parametersUpdateWithWhereUniqueWithoutUserInput = {
    where: parametersWhereUniqueInput
    data: XOR<parametersUpdateWithoutUserInput, parametersUncheckedUpdateWithoutUserInput>
  }

  export type parametersUpdateManyWithWhereWithoutUserInput = {
    where: parametersScalarWhereInput
    data: XOR<parametersUpdateManyMutationInput, parametersUncheckedUpdateManyWithoutUserInput>
  }

  export type parametersScalarWhereInput = {
    AND?: parametersScalarWhereInput | parametersScalarWhereInput[]
    OR?: parametersScalarWhereInput[]
    NOT?: parametersScalarWhereInput | parametersScalarWhereInput[]
    id?: StringFilter<"parameters"> | string
    key?: StringFilter<"parameters"> | string
    name?: StringFilter<"parameters"> | string
    value?: StringFilter<"parameters"> | string
    createdat?: DateTimeFilter<"parameters"> | Date | string
    status?: IntFilter<"parameters"> | number
    userId?: StringFilter<"parameters"> | string
  }

  export type entranceUpsertWithWhereUniqueWithoutUserInput = {
    where: entranceWhereUniqueInput
    update: XOR<entranceUpdateWithoutUserInput, entranceUncheckedUpdateWithoutUserInput>
    create: XOR<entranceCreateWithoutUserInput, entranceUncheckedCreateWithoutUserInput>
  }

  export type entranceUpdateWithWhereUniqueWithoutUserInput = {
    where: entranceWhereUniqueInput
    data: XOR<entranceUpdateWithoutUserInput, entranceUncheckedUpdateWithoutUserInput>
  }

  export type entranceUpdateManyWithWhereWithoutUserInput = {
    where: entranceScalarWhereInput
    data: XOR<entranceUpdateManyMutationInput, entranceUncheckedUpdateManyWithoutUserInput>
  }

  export type entranceScalarWhereInput = {
    AND?: entranceScalarWhereInput | entranceScalarWhereInput[]
    OR?: entranceScalarWhereInput[]
    NOT?: entranceScalarWhereInput | entranceScalarWhereInput[]
    id?: StringFilter<"entrance"> | string
    type?: StringFilter<"entrance"> | string
    useragent?: StringFilter<"entrance"> | string
    ipaddress?: StringFilter<"entrance"> | string
    userid?: StringFilter<"entrance"> | string
    createdat?: DateTimeFilter<"entrance"> | Date | string
  }

  export type paymentUpsertWithWhereUniqueWithoutUserInput = {
    where: paymentWhereUniqueInput
    update: XOR<paymentUpdateWithoutUserInput, paymentUncheckedUpdateWithoutUserInput>
    create: XOR<paymentCreateWithoutUserInput, paymentUncheckedCreateWithoutUserInput>
  }

  export type paymentUpdateWithWhereUniqueWithoutUserInput = {
    where: paymentWhereUniqueInput
    data: XOR<paymentUpdateWithoutUserInput, paymentUncheckedUpdateWithoutUserInput>
  }

  export type paymentUpdateManyWithWhereWithoutUserInput = {
    where: paymentScalarWhereInput
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyWithoutUserInput>
  }

  export type paymentScalarWhereInput = {
    AND?: paymentScalarWhereInput | paymentScalarWhereInput[]
    OR?: paymentScalarWhereInput[]
    NOT?: paymentScalarWhereInput | paymentScalarWhereInput[]
    id?: StringFilter<"payment"> | string
    userId?: StringFilter<"payment"> | string
    amount?: StringFilter<"payment"> | string
    currency?: StringFilter<"payment"> | string
    invoiceId?: StringFilter<"payment"> | string
    stripeId?: StringNullableFilter<"payment"> | string | null
    status?: StringFilter<"payment"> | string
    createdat?: DateTimeFilter<"payment"> | Date | string
  }

  export type planUpsertWithoutUsersInput = {
    update: XOR<planUpdateWithoutUsersInput, planUncheckedUpdateWithoutUsersInput>
    create: XOR<planCreateWithoutUsersInput, planUncheckedCreateWithoutUsersInput>
    where?: planWhereInput
  }

  export type planUpdateToOneWithWhereWithoutUsersInput = {
    where?: planWhereInput
    data: XOR<planUpdateWithoutUsersInput, planUncheckedUpdateWithoutUsersInput>
  }

  export type planUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: subscriptionUpdateManyWithoutPlanNestedInput
  }

  export type planUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: subscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type transactionUpsertWithWhereUniqueWithoutUserInput = {
    where: transactionWhereUniqueInput
    update: XOR<transactionUpdateWithoutUserInput, transactionUncheckedUpdateWithoutUserInput>
    create: XOR<transactionCreateWithoutUserInput, transactionUncheckedCreateWithoutUserInput>
  }

  export type transactionUpdateWithWhereUniqueWithoutUserInput = {
    where: transactionWhereUniqueInput
    data: XOR<transactionUpdateWithoutUserInput, transactionUncheckedUpdateWithoutUserInput>
  }

  export type transactionUpdateManyWithWhereWithoutUserInput = {
    where: transactionScalarWhereInput
    data: XOR<transactionUpdateManyMutationInput, transactionUncheckedUpdateManyWithoutUserInput>
  }

  export type transactionScalarWhereInput = {
    AND?: transactionScalarWhereInput | transactionScalarWhereInput[]
    OR?: transactionScalarWhereInput[]
    NOT?: transactionScalarWhereInput | transactionScalarWhereInput[]
    id?: StringFilter<"transaction"> | string
    type?: IntFilter<"transaction"> | number
    useragent?: StringFilter<"transaction"> | string
    ipaddress?: StringFilter<"transaction"> | string
    userid?: StringFilter<"transaction"> | string
    createdat?: DateTimeFilter<"transaction"> | Date | string
  }

  export type notificationUpsertWithWhereUniqueWithoutToInput = {
    where: notificationWhereUniqueInput
    update: XOR<notificationUpdateWithoutToInput, notificationUncheckedUpdateWithoutToInput>
    create: XOR<notificationCreateWithoutToInput, notificationUncheckedCreateWithoutToInput>
  }

  export type notificationUpdateWithWhereUniqueWithoutToInput = {
    where: notificationWhereUniqueInput
    data: XOR<notificationUpdateWithoutToInput, notificationUncheckedUpdateWithoutToInput>
  }

  export type notificationUpdateManyWithWhereWithoutToInput = {
    where: notificationScalarWhereInput
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyWithoutToInput>
  }

  export type notificationScalarWhereInput = {
    AND?: notificationScalarWhereInput | notificationScalarWhereInput[]
    OR?: notificationScalarWhereInput[]
    NOT?: notificationScalarWhereInput | notificationScalarWhereInput[]
    id?: StringFilter<"notification"> | string
    touserid?: StringFilter<"notification"> | string
    message?: StringFilter<"notification"> | string
    url?: StringFilter<"notification"> | string
    createdby?: StringFilter<"notification"> | string
    createdat?: DateTimeFilter<"notification"> | Date | string
    readedat?: DateTimeNullableFilter<"notification"> | Date | string | null
  }

  export type apiclientUpsertWithWhereUniqueWithoutCreateduserInput = {
    where: apiclientWhereUniqueInput
    update: XOR<apiclientUpdateWithoutCreateduserInput, apiclientUncheckedUpdateWithoutCreateduserInput>
    create: XOR<apiclientCreateWithoutCreateduserInput, apiclientUncheckedCreateWithoutCreateduserInput>
  }

  export type apiclientUpdateWithWhereUniqueWithoutCreateduserInput = {
    where: apiclientWhereUniqueInput
    data: XOR<apiclientUpdateWithoutCreateduserInput, apiclientUncheckedUpdateWithoutCreateduserInput>
  }

  export type apiclientUpdateManyWithWhereWithoutCreateduserInput = {
    where: apiclientScalarWhereInput
    data: XOR<apiclientUpdateManyMutationInput, apiclientUncheckedUpdateManyWithoutCreateduserInput>
  }

  export type apiclientScalarWhereInput = {
    AND?: apiclientScalarWhereInput | apiclientScalarWhereInput[]
    OR?: apiclientScalarWhereInput[]
    NOT?: apiclientScalarWhereInput | apiclientScalarWhereInput[]
    id?: StringFilter<"apiclient"> | string
    name?: StringFilter<"apiclient"> | string
    key?: StringFilter<"apiclient"> | string
    secret?: StringFilter<"apiclient"> | string
    type?: IntFilter<"apiclient"> | number
    createdat?: DateTimeFilter<"apiclient"> | Date | string
    createdby?: StringFilter<"apiclient"> | string
    updatedat?: DateTimeNullableFilter<"apiclient"> | Date | string | null
    updatedby?: StringNullableFilter<"apiclient"> | string | null
    isactive?: BoolFilter<"apiclient"> | boolean
  }

  export type apiclientUpsertWithWhereUniqueWithoutUpdateduserInput = {
    where: apiclientWhereUniqueInput
    update: XOR<apiclientUpdateWithoutUpdateduserInput, apiclientUncheckedUpdateWithoutUpdateduserInput>
    create: XOR<apiclientCreateWithoutUpdateduserInput, apiclientUncheckedCreateWithoutUpdateduserInput>
  }

  export type apiclientUpdateWithWhereUniqueWithoutUpdateduserInput = {
    where: apiclientWhereUniqueInput
    data: XOR<apiclientUpdateWithoutUpdateduserInput, apiclientUncheckedUpdateWithoutUpdateduserInput>
  }

  export type apiclientUpdateManyWithWhereWithoutUpdateduserInput = {
    where: apiclientScalarWhereInput
    data: XOR<apiclientUpdateManyMutationInput, apiclientUncheckedUpdateManyWithoutUpdateduserInput>
  }

  export type permissionUpsertWithWhereUniqueWithoutCreateduserInput = {
    where: permissionWhereUniqueInput
    update: XOR<permissionUpdateWithoutCreateduserInput, permissionUncheckedUpdateWithoutCreateduserInput>
    create: XOR<permissionCreateWithoutCreateduserInput, permissionUncheckedCreateWithoutCreateduserInput>
  }

  export type permissionUpdateWithWhereUniqueWithoutCreateduserInput = {
    where: permissionWhereUniqueInput
    data: XOR<permissionUpdateWithoutCreateduserInput, permissionUncheckedUpdateWithoutCreateduserInput>
  }

  export type permissionUpdateManyWithWhereWithoutCreateduserInput = {
    where: permissionScalarWhereInput
    data: XOR<permissionUpdateManyMutationInput, permissionUncheckedUpdateManyWithoutCreateduserInput>
  }

  export type permissionScalarWhereInput = {
    AND?: permissionScalarWhereInput | permissionScalarWhereInput[]
    OR?: permissionScalarWhereInput[]
    NOT?: permissionScalarWhereInput | permissionScalarWhereInput[]
    id?: StringFilter<"permission"> | string
    name?: StringFilter<"permission"> | string
    value?: StringFilter<"permission"> | string
    group?: StringFilter<"permission"> | string
    description?: StringFilter<"permission"> | string
    createdby?: StringFilter<"permission"> | string
    createdat?: DateTimeFilter<"permission"> | Date | string
    updatedby?: StringNullableFilter<"permission"> | string | null
    updatedat?: DateTimeNullableFilter<"permission"> | Date | string | null
  }

  export type permissionUpsertWithWhereUniqueWithoutUpdateduserInput = {
    where: permissionWhereUniqueInput
    update: XOR<permissionUpdateWithoutUpdateduserInput, permissionUncheckedUpdateWithoutUpdateduserInput>
    create: XOR<permissionCreateWithoutUpdateduserInput, permissionUncheckedCreateWithoutUpdateduserInput>
  }

  export type permissionUpdateWithWhereUniqueWithoutUpdateduserInput = {
    where: permissionWhereUniqueInput
    data: XOR<permissionUpdateWithoutUpdateduserInput, permissionUncheckedUpdateWithoutUpdateduserInput>
  }

  export type permissionUpdateManyWithWhereWithoutUpdateduserInput = {
    where: permissionScalarWhereInput
    data: XOR<permissionUpdateManyMutationInput, permissionUncheckedUpdateManyWithoutUpdateduserInput>
  }

  export type refreshtokenUpsertWithWhereUniqueWithoutUserInput = {
    where: refreshtokenWhereUniqueInput
    update: XOR<refreshtokenUpdateWithoutUserInput, refreshtokenUncheckedUpdateWithoutUserInput>
    create: XOR<refreshtokenCreateWithoutUserInput, refreshtokenUncheckedCreateWithoutUserInput>
  }

  export type refreshtokenUpdateWithWhereUniqueWithoutUserInput = {
    where: refreshtokenWhereUniqueInput
    data: XOR<refreshtokenUpdateWithoutUserInput, refreshtokenUncheckedUpdateWithoutUserInput>
  }

  export type refreshtokenUpdateManyWithWhereWithoutUserInput = {
    where: refreshtokenScalarWhereInput
    data: XOR<refreshtokenUpdateManyMutationInput, refreshtokenUncheckedUpdateManyWithoutUserInput>
  }

  export type refreshtokenScalarWhereInput = {
    AND?: refreshtokenScalarWhereInput | refreshtokenScalarWhereInput[]
    OR?: refreshtokenScalarWhereInput[]
    NOT?: refreshtokenScalarWhereInput | refreshtokenScalarWhereInput[]
    id?: StringFilter<"refreshtoken"> | string
    userid?: StringFilter<"refreshtoken"> | string
    token?: StringFilter<"refreshtoken"> | string
    createdat?: DateTimeFilter<"refreshtoken"> | Date | string
    updatedat?: DateTimeNullableFilter<"refreshtoken"> | Date | string | null
    expiresat?: DateTimeNullableFilter<"refreshtoken"> | Date | string | null
  }

  export type roleUpsertWithWhereUniqueWithoutCreateduserInput = {
    where: roleWhereUniqueInput
    update: XOR<roleUpdateWithoutCreateduserInput, roleUncheckedUpdateWithoutCreateduserInput>
    create: XOR<roleCreateWithoutCreateduserInput, roleUncheckedCreateWithoutCreateduserInput>
  }

  export type roleUpdateWithWhereUniqueWithoutCreateduserInput = {
    where: roleWhereUniqueInput
    data: XOR<roleUpdateWithoutCreateduserInput, roleUncheckedUpdateWithoutCreateduserInput>
  }

  export type roleUpdateManyWithWhereWithoutCreateduserInput = {
    where: roleScalarWhereInput
    data: XOR<roleUpdateManyMutationInput, roleUncheckedUpdateManyWithoutCreateduserInput>
  }

  export type roleScalarWhereInput = {
    AND?: roleScalarWhereInput | roleScalarWhereInput[]
    OR?: roleScalarWhereInput[]
    NOT?: roleScalarWhereInput | roleScalarWhereInput[]
    id?: StringFilter<"role"> | string
    name?: StringFilter<"role"> | string
    createdby?: StringFilter<"role"> | string
    createdat?: DateTimeFilter<"role"> | Date | string
    updatedby?: StringNullableFilter<"role"> | string | null
    updatedat?: DateTimeNullableFilter<"role"> | Date | string | null
    issystemrole?: BoolFilter<"role"> | boolean
  }

  export type roleUpsertWithWhereUniqueWithoutUpdateduserInput = {
    where: roleWhereUniqueInput
    update: XOR<roleUpdateWithoutUpdateduserInput, roleUncheckedUpdateWithoutUpdateduserInput>
    create: XOR<roleCreateWithoutUpdateduserInput, roleUncheckedCreateWithoutUpdateduserInput>
  }

  export type roleUpdateWithWhereUniqueWithoutUpdateduserInput = {
    where: roleWhereUniqueInput
    data: XOR<roleUpdateWithoutUpdateduserInput, roleUncheckedUpdateWithoutUpdateduserInput>
  }

  export type roleUpdateManyWithWhereWithoutUpdateduserInput = {
    where: roleScalarWhereInput
    data: XOR<roleUpdateManyMutationInput, roleUncheckedUpdateManyWithoutUpdateduserInput>
  }

  export type rolepermissionUpsertWithWhereUniqueWithoutCreateduserInput = {
    where: rolepermissionWhereUniqueInput
    update: XOR<rolepermissionUpdateWithoutCreateduserInput, rolepermissionUncheckedUpdateWithoutCreateduserInput>
    create: XOR<rolepermissionCreateWithoutCreateduserInput, rolepermissionUncheckedCreateWithoutCreateduserInput>
  }

  export type rolepermissionUpdateWithWhereUniqueWithoutCreateduserInput = {
    where: rolepermissionWhereUniqueInput
    data: XOR<rolepermissionUpdateWithoutCreateduserInput, rolepermissionUncheckedUpdateWithoutCreateduserInput>
  }

  export type rolepermissionUpdateManyWithWhereWithoutCreateduserInput = {
    where: rolepermissionScalarWhereInput
    data: XOR<rolepermissionUpdateManyMutationInput, rolepermissionUncheckedUpdateManyWithoutCreateduserInput>
  }

  export type rolepermissionUpsertWithWhereUniqueWithoutUpdateduserInput = {
    where: rolepermissionWhereUniqueInput
    update: XOR<rolepermissionUpdateWithoutUpdateduserInput, rolepermissionUncheckedUpdateWithoutUpdateduserInput>
    create: XOR<rolepermissionCreateWithoutUpdateduserInput, rolepermissionUncheckedCreateWithoutUpdateduserInput>
  }

  export type rolepermissionUpdateWithWhereUniqueWithoutUpdateduserInput = {
    where: rolepermissionWhereUniqueInput
    data: XOR<rolepermissionUpdateWithoutUpdateduserInput, rolepermissionUncheckedUpdateWithoutUpdateduserInput>
  }

  export type rolepermissionUpdateManyWithWhereWithoutUpdateduserInput = {
    where: rolepermissionScalarWhereInput
    data: XOR<rolepermissionUpdateManyMutationInput, rolepermissionUncheckedUpdateManyWithoutUpdateduserInput>
  }

  export type userUpsertWithoutCreatedusersInput = {
    update: XOR<userUpdateWithoutCreatedusersInput, userUncheckedUpdateWithoutCreatedusersInput>
    create: XOR<userCreateWithoutCreatedusersInput, userUncheckedCreateWithoutCreatedusersInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutCreatedusersInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutCreatedusersInput, userUncheckedUpdateWithoutCreatedusersInput>
  }

  export type userUpdateWithoutCreatedusersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutCreatedusersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUpsertWithWhereUniqueWithoutCreateduserInput = {
    where: userWhereUniqueInput
    update: XOR<userUpdateWithoutCreateduserInput, userUncheckedUpdateWithoutCreateduserInput>
    create: XOR<userCreateWithoutCreateduserInput, userUncheckedCreateWithoutCreateduserInput>
  }

  export type userUpdateWithWhereUniqueWithoutCreateduserInput = {
    where: userWhereUniqueInput
    data: XOR<userUpdateWithoutCreateduserInput, userUncheckedUpdateWithoutCreateduserInput>
  }

  export type userUpdateManyWithWhereWithoutCreateduserInput = {
    where: userScalarWhereInput
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyWithoutCreateduserInput>
  }

  export type userScalarWhereInput = {
    AND?: userScalarWhereInput | userScalarWhereInput[]
    OR?: userScalarWhereInput[]
    NOT?: userScalarWhereInput | userScalarWhereInput[]
    id?: StringFilter<"user"> | string
    firstname?: StringFilter<"user"> | string
    lastname?: StringFilter<"user"> | string
    email?: StringFilter<"user"> | string
    planId?: StringNullableFilter<"user"> | string | null
    password?: StringFilter<"user"> | string
    companyName?: StringNullableFilter<"user"> | string | null
    companyLogoUrl?: StringNullableFilter<"user"> | string | null
    taxId?: StringNullableFilter<"user"> | string | null
    address?: StringNullableFilter<"user"> | string | null
    phone?: StringNullableFilter<"user"> | string | null
    createdat?: DateTimeFilter<"user"> | Date | string
    createdby?: StringFilter<"user"> | string
    updatedat?: DateTimeNullableFilter<"user"> | Date | string | null
    updatedby?: StringNullableFilter<"user"> | string | null
    status?: BoolFilter<"user"> | boolean
  }

  export type userUpsertWithoutUpdatedusersInput = {
    update: XOR<userUpdateWithoutUpdatedusersInput, userUncheckedUpdateWithoutUpdatedusersInput>
    create: XOR<userCreateWithoutUpdatedusersInput, userUncheckedCreateWithoutUpdatedusersInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUpdatedusersInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUpdatedusersInput, userUncheckedUpdateWithoutUpdatedusersInput>
  }

  export type userUpdateWithoutUpdatedusersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUpdatedusersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUpsertWithWhereUniqueWithoutUpdateduserInput = {
    where: userWhereUniqueInput
    update: XOR<userUpdateWithoutUpdateduserInput, userUncheckedUpdateWithoutUpdateduserInput>
    create: XOR<userCreateWithoutUpdateduserInput, userUncheckedCreateWithoutUpdateduserInput>
  }

  export type userUpdateWithWhereUniqueWithoutUpdateduserInput = {
    where: userWhereUniqueInput
    data: XOR<userUpdateWithoutUpdateduserInput, userUncheckedUpdateWithoutUpdateduserInput>
  }

  export type userUpdateManyWithWhereWithoutUpdateduserInput = {
    where: userScalarWhereInput
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyWithoutUpdateduserInput>
  }

  export type userpermissionUpsertWithWhereUniqueWithoutCreateduserInput = {
    where: userpermissionWhereUniqueInput
    update: XOR<userpermissionUpdateWithoutCreateduserInput, userpermissionUncheckedUpdateWithoutCreateduserInput>
    create: XOR<userpermissionCreateWithoutCreateduserInput, userpermissionUncheckedCreateWithoutCreateduserInput>
  }

  export type userpermissionUpdateWithWhereUniqueWithoutCreateduserInput = {
    where: userpermissionWhereUniqueInput
    data: XOR<userpermissionUpdateWithoutCreateduserInput, userpermissionUncheckedUpdateWithoutCreateduserInput>
  }

  export type userpermissionUpdateManyWithWhereWithoutCreateduserInput = {
    where: userpermissionScalarWhereInput
    data: XOR<userpermissionUpdateManyMutationInput, userpermissionUncheckedUpdateManyWithoutCreateduserInput>
  }

  export type userpermissionUpsertWithWhereUniqueWithoutUpdateduserInput = {
    where: userpermissionWhereUniqueInput
    update: XOR<userpermissionUpdateWithoutUpdateduserInput, userpermissionUncheckedUpdateWithoutUpdateduserInput>
    create: XOR<userpermissionCreateWithoutUpdateduserInput, userpermissionUncheckedCreateWithoutUpdateduserInput>
  }

  export type userpermissionUpdateWithWhereUniqueWithoutUpdateduserInput = {
    where: userpermissionWhereUniqueInput
    data: XOR<userpermissionUpdateWithoutUpdateduserInput, userpermissionUncheckedUpdateWithoutUpdateduserInput>
  }

  export type userpermissionUpdateManyWithWhereWithoutUpdateduserInput = {
    where: userpermissionScalarWhereInput
    data: XOR<userpermissionUpdateManyMutationInput, userpermissionUncheckedUpdateManyWithoutUpdateduserInput>
  }

  export type userpermissionUpsertWithWhereUniqueWithoutUserInput = {
    where: userpermissionWhereUniqueInput
    update: XOR<userpermissionUpdateWithoutUserInput, userpermissionUncheckedUpdateWithoutUserInput>
    create: XOR<userpermissionCreateWithoutUserInput, userpermissionUncheckedCreateWithoutUserInput>
  }

  export type userpermissionUpdateWithWhereUniqueWithoutUserInput = {
    where: userpermissionWhereUniqueInput
    data: XOR<userpermissionUpdateWithoutUserInput, userpermissionUncheckedUpdateWithoutUserInput>
  }

  export type userpermissionUpdateManyWithWhereWithoutUserInput = {
    where: userpermissionScalarWhereInput
    data: XOR<userpermissionUpdateManyMutationInput, userpermissionUncheckedUpdateManyWithoutUserInput>
  }

  export type userroleUpsertWithWhereUniqueWithoutCreateduserInput = {
    where: userroleWhereUniqueInput
    update: XOR<userroleUpdateWithoutCreateduserInput, userroleUncheckedUpdateWithoutCreateduserInput>
    create: XOR<userroleCreateWithoutCreateduserInput, userroleUncheckedCreateWithoutCreateduserInput>
  }

  export type userroleUpdateWithWhereUniqueWithoutCreateduserInput = {
    where: userroleWhereUniqueInput
    data: XOR<userroleUpdateWithoutCreateduserInput, userroleUncheckedUpdateWithoutCreateduserInput>
  }

  export type userroleUpdateManyWithWhereWithoutCreateduserInput = {
    where: userroleScalarWhereInput
    data: XOR<userroleUpdateManyMutationInput, userroleUncheckedUpdateManyWithoutCreateduserInput>
  }

  export type userroleUpsertWithWhereUniqueWithoutUpdateduserInput = {
    where: userroleWhereUniqueInput
    update: XOR<userroleUpdateWithoutUpdateduserInput, userroleUncheckedUpdateWithoutUpdateduserInput>
    create: XOR<userroleCreateWithoutUpdateduserInput, userroleUncheckedCreateWithoutUpdateduserInput>
  }

  export type userroleUpdateWithWhereUniqueWithoutUpdateduserInput = {
    where: userroleWhereUniqueInput
    data: XOR<userroleUpdateWithoutUpdateduserInput, userroleUncheckedUpdateWithoutUpdateduserInput>
  }

  export type userroleUpdateManyWithWhereWithoutUpdateduserInput = {
    where: userroleScalarWhereInput
    data: XOR<userroleUpdateManyMutationInput, userroleUncheckedUpdateManyWithoutUpdateduserInput>
  }

  export type userroleUpsertWithWhereUniqueWithoutUserInput = {
    where: userroleWhereUniqueInput
    update: XOR<userroleUpdateWithoutUserInput, userroleUncheckedUpdateWithoutUserInput>
    create: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput>
  }

  export type userroleUpdateWithWhereUniqueWithoutUserInput = {
    where: userroleWhereUniqueInput
    data: XOR<userroleUpdateWithoutUserInput, userroleUncheckedUpdateWithoutUserInput>
  }

  export type userroleUpdateManyWithWhereWithoutUserInput = {
    where: userroleScalarWhereInput
    data: XOR<userroleUpdateManyMutationInput, userroleUncheckedUpdateManyWithoutUserInput>
  }

  export type subscriptionCreateWithoutPlanInput = {
    id?: string
    stripeId?: string | null
    status?: string
    startedat?: Date | string
    endedat?: Date | string | null
    canceledat?: Date | string | null
    user: userCreateNestedOneWithoutSubscriptionsInput
  }

  export type subscriptionUncheckedCreateWithoutPlanInput = {
    id?: string
    userId: string
    stripeId?: string | null
    status?: string
    startedat?: Date | string
    endedat?: Date | string | null
    canceledat?: Date | string | null
  }

  export type subscriptionCreateOrConnectWithoutPlanInput = {
    where: subscriptionWhereUniqueInput
    create: XOR<subscriptionCreateWithoutPlanInput, subscriptionUncheckedCreateWithoutPlanInput>
  }

  export type subscriptionCreateManyPlanInputEnvelope = {
    data: subscriptionCreateManyPlanInput | subscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutPlanInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutPlanInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutPlanInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPlanInput, userUncheckedCreateWithoutPlanInput>
  }

  export type userCreateManyPlanInputEnvelope = {
    data: userCreateManyPlanInput | userCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type subscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: subscriptionWhereUniqueInput
    update: XOR<subscriptionUpdateWithoutPlanInput, subscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<subscriptionCreateWithoutPlanInput, subscriptionUncheckedCreateWithoutPlanInput>
  }

  export type subscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: subscriptionWhereUniqueInput
    data: XOR<subscriptionUpdateWithoutPlanInput, subscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type subscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: subscriptionScalarWhereInput
    data: XOR<subscriptionUpdateManyMutationInput, subscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type userUpsertWithWhereUniqueWithoutPlanInput = {
    where: userWhereUniqueInput
    update: XOR<userUpdateWithoutPlanInput, userUncheckedUpdateWithoutPlanInput>
    create: XOR<userCreateWithoutPlanInput, userUncheckedCreateWithoutPlanInput>
  }

  export type userUpdateWithWhereUniqueWithoutPlanInput = {
    where: userWhereUniqueInput
    data: XOR<userUpdateWithoutPlanInput, userUncheckedUpdateWithoutPlanInput>
  }

  export type userUpdateManyWithWhereWithoutPlanInput = {
    where: userScalarWhereInput
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyWithoutPlanInput>
  }

  export type userCreateWithoutSubscriptionsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutSubscriptionsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutSubscriptionsInput, userUncheckedCreateWithoutSubscriptionsInput>
  }

  export type planCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    price: string
    currency: string
    interval: string
    description?: string | null
    stripePriceId?: string | null
    stripeProductId?: string | null
    createdat?: Date | string
    users?: userCreateNestedManyWithoutPlanInput
  }

  export type planUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    price: string
    currency: string
    interval: string
    description?: string | null
    stripePriceId?: string | null
    stripeProductId?: string | null
    createdat?: Date | string
    users?: userUncheckedCreateNestedManyWithoutPlanInput
  }

  export type planCreateOrConnectWithoutSubscriptionsInput = {
    where: planWhereUniqueInput
    create: XOR<planCreateWithoutSubscriptionsInput, planUncheckedCreateWithoutSubscriptionsInput>
  }

  export type userUpsertWithoutSubscriptionsInput = {
    update: XOR<userUpdateWithoutSubscriptionsInput, userUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<userCreateWithoutSubscriptionsInput, userUncheckedCreateWithoutSubscriptionsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutSubscriptionsInput, userUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type userUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type planUpsertWithoutSubscriptionsInput = {
    update: XOR<planUpdateWithoutSubscriptionsInput, planUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<planCreateWithoutSubscriptionsInput, planUncheckedCreateWithoutSubscriptionsInput>
    where?: planWhereInput
  }

  export type planUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: planWhereInput
    data: XOR<planUpdateWithoutSubscriptionsInput, planUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type planUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: userUpdateManyWithoutPlanNestedInput
  }

  export type planUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeProductId?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: userUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type userCreateWithoutCustomersInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCustomersInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCustomersInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCustomersInput, userUncheckedCreateWithoutCustomersInput>
  }

  export type invoiceCreateWithoutCustomerInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    createdat?: Date | string
    status?: string
    user: userCreateNestedOneWithoutInvoicesInput
    payments?: paymentCreateNestedManyWithoutInvoiceInput
  }

  export type invoiceUncheckedCreateWithoutCustomerInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    userId: string
    createdat?: Date | string
    status?: string
    payments?: paymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type invoiceCreateOrConnectWithoutCustomerInput = {
    where: invoiceWhereUniqueInput
    create: XOR<invoiceCreateWithoutCustomerInput, invoiceUncheckedCreateWithoutCustomerInput>
  }

  export type invoiceCreateManyCustomerInputEnvelope = {
    data: invoiceCreateManyCustomerInput | invoiceCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutCustomersInput = {
    update: XOR<userUpdateWithoutCustomersInput, userUncheckedUpdateWithoutCustomersInput>
    create: XOR<userCreateWithoutCustomersInput, userUncheckedCreateWithoutCustomersInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutCustomersInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutCustomersInput, userUncheckedUpdateWithoutCustomersInput>
  }

  export type userUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type invoiceUpsertWithWhereUniqueWithoutCustomerInput = {
    where: invoiceWhereUniqueInput
    update: XOR<invoiceUpdateWithoutCustomerInput, invoiceUncheckedUpdateWithoutCustomerInput>
    create: XOR<invoiceCreateWithoutCustomerInput, invoiceUncheckedCreateWithoutCustomerInput>
  }

  export type invoiceUpdateWithWhereUniqueWithoutCustomerInput = {
    where: invoiceWhereUniqueInput
    data: XOR<invoiceUpdateWithoutCustomerInput, invoiceUncheckedUpdateWithoutCustomerInput>
  }

  export type invoiceUpdateManyWithWhereWithoutCustomerInput = {
    where: invoiceScalarWhereInput
    data: XOR<invoiceUpdateManyMutationInput, invoiceUncheckedUpdateManyWithoutCustomerInput>
  }

  export type userCreateWithoutInvoicesInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutInvoicesInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutInvoicesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutInvoicesInput, userUncheckedCreateWithoutInvoicesInput>
  }

  export type customerCreateWithoutInvoicesInput = {
    id?: string
    name: string
    email: string
    createdat?: Date | string
    user: userCreateNestedOneWithoutCustomersInput
  }

  export type customerUncheckedCreateWithoutInvoicesInput = {
    id?: string
    userId: string
    name: string
    email: string
    createdat?: Date | string
  }

  export type customerCreateOrConnectWithoutInvoicesInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutInvoicesInput, customerUncheckedCreateWithoutInvoicesInput>
  }

  export type paymentCreateWithoutInvoiceInput = {
    id?: string
    amount: string
    currency: string
    stripeId?: string | null
    status?: string
    createdat?: Date | string
    user: userCreateNestedOneWithoutPaymentsInput
  }

  export type paymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    userId: string
    amount: string
    currency: string
    stripeId?: string | null
    status?: string
    createdat?: Date | string
  }

  export type paymentCreateOrConnectWithoutInvoiceInput = {
    where: paymentWhereUniqueInput
    create: XOR<paymentCreateWithoutInvoiceInput, paymentUncheckedCreateWithoutInvoiceInput>
  }

  export type paymentCreateManyInvoiceInputEnvelope = {
    data: paymentCreateManyInvoiceInput | paymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutInvoicesInput = {
    update: XOR<userUpdateWithoutInvoicesInput, userUncheckedUpdateWithoutInvoicesInput>
    create: XOR<userCreateWithoutInvoicesInput, userUncheckedCreateWithoutInvoicesInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutInvoicesInput, userUncheckedUpdateWithoutInvoicesInput>
  }

  export type userUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type customerUpsertWithoutInvoicesInput = {
    update: XOR<customerUpdateWithoutInvoicesInput, customerUncheckedUpdateWithoutInvoicesInput>
    create: XOR<customerCreateWithoutInvoicesInput, customerUncheckedCreateWithoutInvoicesInput>
    where?: customerWhereInput
  }

  export type customerUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: customerWhereInput
    data: XOR<customerUpdateWithoutInvoicesInput, customerUncheckedUpdateWithoutInvoicesInput>
  }

  export type customerUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutCustomersNestedInput
  }

  export type customerUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: paymentWhereUniqueInput
    update: XOR<paymentUpdateWithoutInvoiceInput, paymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<paymentCreateWithoutInvoiceInput, paymentUncheckedCreateWithoutInvoiceInput>
  }

  export type paymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: paymentWhereUniqueInput
    data: XOR<paymentUpdateWithoutInvoiceInput, paymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type paymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: paymentScalarWhereInput
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type invoiceCreateWithoutPaymentsInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    createdat?: Date | string
    status?: string
    user: userCreateNestedOneWithoutInvoicesInput
    customer: customerCreateNestedOneWithoutInvoicesInput
  }

  export type invoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    userId: string
    customerId: string
    createdat?: Date | string
    status?: string
  }

  export type invoiceCreateOrConnectWithoutPaymentsInput = {
    where: invoiceWhereUniqueInput
    create: XOR<invoiceCreateWithoutPaymentsInput, invoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type userCreateWithoutPaymentsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    parameters?: parametersCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutPaymentsInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    parameters?: parametersUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutPaymentsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPaymentsInput, userUncheckedCreateWithoutPaymentsInput>
  }

  export type invoiceUpsertWithoutPaymentsInput = {
    update: XOR<invoiceUpdateWithoutPaymentsInput, invoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<invoiceCreateWithoutPaymentsInput, invoiceUncheckedCreateWithoutPaymentsInput>
    where?: invoiceWhereInput
  }

  export type invoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: invoiceWhereInput
    data: XOR<invoiceUpdateWithoutPaymentsInput, invoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type invoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    user?: userUpdateOneRequiredWithoutInvoicesNestedInput
    customer?: customerUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type invoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type userUpsertWithoutPaymentsInput = {
    update: XOR<userUpdateWithoutPaymentsInput, userUncheckedUpdateWithoutPaymentsInput>
    create: XOR<userCreateWithoutPaymentsInput, userUncheckedCreateWithoutPaymentsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutPaymentsInput, userUncheckedUpdateWithoutPaymentsInput>
  }

  export type userUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutParametersInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    status?: boolean
    invoices?: invoiceCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionCreateNestedManyWithoutUserInput
    customers?: customerCreateNestedManyWithoutUserInput
    entrances?: entranceCreateNestedManyWithoutUserInput
    payments?: paymentCreateNestedManyWithoutUserInput
    plan?: planCreateNestedOneWithoutUsersInput
    transactions?: transactionCreateNestedManyWithoutUserInput
    notificationuser?: notificationCreateNestedManyWithoutToInput
    createdapiclients?: apiclientCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenCreateNestedManyWithoutUserInput
    createdroles?: roleCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionCreateNestedManyWithoutUpdateduserInput
    createduser: userCreateNestedOneWithoutCreatedusersInput
    createdusers?: userCreateNestedManyWithoutCreateduserInput
    updateduser?: userCreateNestedOneWithoutUpdatedusersInput
    updatedusers?: userCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionCreateNestedManyWithoutUserInput
    createduserroles?: userroleCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutParametersInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
    invoices?: invoiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    customers?: customerUncheckedCreateNestedManyWithoutUserInput
    entrances?: entranceUncheckedCreateNestedManyWithoutUserInput
    payments?: paymentUncheckedCreateNestedManyWithoutUserInput
    transactions?: transactionUncheckedCreateNestedManyWithoutUserInput
    notificationuser?: notificationUncheckedCreateNestedManyWithoutToInput
    createdapiclients?: apiclientUncheckedCreateNestedManyWithoutCreateduserInput
    updatedapiclients?: apiclientUncheckedCreateNestedManyWithoutUpdateduserInput
    createdpermissions?: permissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedpermissions?: permissionUncheckedCreateNestedManyWithoutUpdateduserInput
    refreshtokens?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    createdroles?: roleUncheckedCreateNestedManyWithoutCreateduserInput
    updatedroles?: roleUncheckedCreateNestedManyWithoutUpdateduserInput
    createdrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updatedrolepermissions?: rolepermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    createdusers?: userUncheckedCreateNestedManyWithoutCreateduserInput
    updatedusers?: userUncheckedCreateNestedManyWithoutUpdateduserInput
    createduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserpermissions?: userpermissionUncheckedCreateNestedManyWithoutUpdateduserInput
    userpermissions?: userpermissionUncheckedCreateNestedManyWithoutUserInput
    createduserroles?: userroleUncheckedCreateNestedManyWithoutCreateduserInput
    updateduserroles?: userroleUncheckedCreateNestedManyWithoutUpdateduserInput
    userroles?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutParametersInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutParametersInput, userUncheckedCreateWithoutParametersInput>
  }

  export type userUpsertWithoutParametersInput = {
    update: XOR<userUpdateWithoutParametersInput, userUncheckedUpdateWithoutParametersInput>
    create: XOR<userCreateWithoutParametersInput, userUncheckedCreateWithoutParametersInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutParametersInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutParametersInput, userUncheckedUpdateWithoutParametersInput>
  }

  export type userUpdateWithoutParametersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutParametersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type rolepermissionCreateManyRoleInput = {
    id?: string
    permissionid: string
    createdat?: Date | string
    createdby: string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type userroleCreateManyRoleInput = {
    id?: string
    userid: string
    createdby: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type rolepermissionUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createduser?: userUpdateOneRequiredWithoutCreatedrolepermissionsNestedInput
    permission?: permissionUpdateOneRequiredWithoutRolepermissionsNestedInput
    updateduser?: userUpdateOneWithoutUpdatedrolepermissionsNestedInput
  }

  export type rolepermissionUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionid?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolepermissionUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionid?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userroleUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createduser?: userUpdateOneRequiredWithoutCreateduserrolesNestedInput
    updateduser?: userUpdateOneWithoutUpdateduserrolesNestedInput
    user?: userUpdateOneRequiredWithoutUserrolesNestedInput
  }

  export type userroleUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userroleUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolepermissionCreateManyPermissionInput = {
    id?: string
    roleid: string
    createdat?: Date | string
    createdby: string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type userpermissionCreateManyPermissionInput = {
    id?: string
    userid: string
    createdby: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type rolepermissionUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createduser?: userUpdateOneRequiredWithoutCreatedrolepermissionsNestedInput
    role?: roleUpdateOneRequiredWithoutRolepermissionsNestedInput
    updateduser?: userUpdateOneWithoutUpdatedrolepermissionsNestedInput
  }

  export type rolepermissionUncheckedUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleid?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolepermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleid?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userpermissionUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createduser?: userUpdateOneRequiredWithoutCreateduserpermissionsNestedInput
    updateduser?: userUpdateOneWithoutUpdateduserpermissionsNestedInput
    user?: userUpdateOneRequiredWithoutUserpermissionsNestedInput
  }

  export type userpermissionUncheckedUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userpermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type invoiceCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    customerId: string
    createdat?: Date | string
    status?: string
  }

  export type subscriptionCreateManyUserInput = {
    id?: string
    planId: string
    stripeId?: string | null
    status?: string
    startedat?: Date | string
    endedat?: Date | string | null
    canceledat?: Date | string | null
  }

  export type customerCreateManyUserInput = {
    id?: string
    name: string
    email: string
    createdat?: Date | string
  }

  export type parametersCreateManyUserInput = {
    id?: string
    key: string
    name: string
    value: string
    createdat?: Date | string
    status?: number
  }

  export type entranceCreateManyUserInput = {
    id?: string
    type: string
    useragent: string
    ipaddress: string
    createdat?: Date | string
  }

  export type paymentCreateManyUserInput = {
    id?: string
    amount: string
    currency: string
    invoiceId: string
    stripeId?: string | null
    status?: string
    createdat?: Date | string
  }

  export type transactionCreateManyUserInput = {
    id?: string
    type: number
    useragent: string
    ipaddress: string
    createdat?: Date | string
  }

  export type notificationCreateManyToInput = {
    id?: string
    message: string
    url: string
    createdby: string
    createdat?: Date | string
    readedat?: Date | string | null
  }

  export type apiclientCreateManyCreateduserInput = {
    id?: string
    name: string
    key: string
    secret: string
    type: number
    createdat?: Date | string
    updatedat?: Date | string | null
    updatedby?: string | null
    isactive: boolean
  }

  export type apiclientCreateManyUpdateduserInput = {
    id?: string
    name: string
    key: string
    secret: string
    type: number
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    isactive: boolean
  }

  export type permissionCreateManyCreateduserInput = {
    id?: string
    name: string
    value: string
    group: string
    description: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type permissionCreateManyUpdateduserInput = {
    id?: string
    name: string
    value: string
    group: string
    description: string
    createdby: string
    createdat?: Date | string
    updatedat?: Date | string | null
  }

  export type refreshtokenCreateManyUserInput = {
    id?: string
    token: string
    createdat?: Date | string
    updatedat?: Date | string | null
    expiresat?: Date | string | null
  }

  export type roleCreateManyCreateduserInput = {
    id?: string
    name: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
    issystemrole?: boolean
  }

  export type roleCreateManyUpdateduserInput = {
    id?: string
    name: string
    createdby: string
    createdat?: Date | string
    updatedat?: Date | string | null
    issystemrole?: boolean
  }

  export type rolepermissionCreateManyCreateduserInput = {
    id?: string
    roleid: string
    permissionid: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type rolepermissionCreateManyUpdateduserInput = {
    id?: string
    roleid: string
    permissionid: string
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
  }

  export type userCreateManyCreateduserInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
  }

  export type userCreateManyUpdateduserInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    planId?: string | null
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    status?: boolean
  }

  export type userpermissionCreateManyCreateduserInput = {
    id?: string
    userid: string
    permissionid: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type userpermissionCreateManyUpdateduserInput = {
    id?: string
    userid: string
    permissionid: string
    createdby: string
    createdat?: Date | string
    updatedat?: Date | string | null
  }

  export type userpermissionCreateManyUserInput = {
    id?: string
    permissionid: string
    createdby: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type userroleCreateManyCreateduserInput = {
    id?: string
    userid: string
    roleid: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type userroleCreateManyUpdateduserInput = {
    id?: string
    userid: string
    roleid: string
    createdby: string
    createdat?: Date | string
    updatedat?: Date | string | null
  }

  export type userroleCreateManyUserInput = {
    id?: string
    roleid: string
    createdby: string
    createdat?: Date | string
    updatedby?: string | null
    updatedat?: Date | string | null
  }

  export type invoiceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    customer?: customerUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: paymentUpdateManyWithoutInvoiceNestedInput
  }

  export type invoiceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    payments?: paymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type invoiceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type subscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedat?: DateTimeFieldUpdateOperationsInput | Date | string
    endedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plan?: planUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type subscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedat?: DateTimeFieldUpdateOperationsInput | Date | string
    endedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedat?: DateTimeFieldUpdateOperationsInput | Date | string
    endedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type customerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: invoiceUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: invoiceUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type parametersUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type parametersUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type parametersUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type entranceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    useragent?: StringFieldUpdateOperationsInput | string
    ipaddress?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type entranceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    useragent?: StringFieldUpdateOperationsInput | string
    ipaddress?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type entranceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    useragent?: StringFieldUpdateOperationsInput | string
    ipaddress?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: invoiceUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type paymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    useragent?: StringFieldUpdateOperationsInput | string
    ipaddress?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    useragent?: StringFieldUpdateOperationsInput | string
    ipaddress?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    useragent?: StringFieldUpdateOperationsInput | string
    ipaddress?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationUpdateWithoutToInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    readedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationUncheckedUpdateWithoutToInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    readedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationUncheckedUpdateManyWithoutToInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    readedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type apiclientUpdateWithoutCreateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isactive?: BoolFieldUpdateOperationsInput | boolean
    updateduser?: userUpdateOneWithoutUpdatedapiclientsNestedInput
  }

  export type apiclientUncheckedUpdateWithoutCreateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type apiclientUncheckedUpdateManyWithoutCreateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    isactive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type apiclientUpdateWithoutUpdateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isactive?: BoolFieldUpdateOperationsInput | boolean
    createduser?: userUpdateOneRequiredWithoutCreatedapiclientsNestedInput
  }

  export type apiclientUncheckedUpdateWithoutUpdateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isactive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type apiclientUncheckedUpdateManyWithoutUpdateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isactive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type permissionUpdateWithoutCreateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updateduser?: userUpdateOneWithoutUpdatedpermissionsNestedInput
    rolepermissions?: rolepermissionUpdateManyWithoutPermissionNestedInput
    userpermissions?: userpermissionUpdateManyWithoutPermissionNestedInput
  }

  export type permissionUncheckedUpdateWithoutCreateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rolepermissions?: rolepermissionUncheckedUpdateManyWithoutPermissionNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type permissionUncheckedUpdateManyWithoutCreateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type permissionUpdateWithoutUpdateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createduser?: userUpdateOneRequiredWithoutCreatedpermissionsNestedInput
    rolepermissions?: rolepermissionUpdateManyWithoutPermissionNestedInput
    userpermissions?: userpermissionUpdateManyWithoutPermissionNestedInput
  }

  export type permissionUncheckedUpdateWithoutUpdateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rolepermissions?: rolepermissionUncheckedUpdateManyWithoutPermissionNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type permissionUncheckedUpdateManyWithoutUpdateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type refreshtokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type refreshtokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type refreshtokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type roleUpdateWithoutCreateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issystemrole?: BoolFieldUpdateOperationsInput | boolean
    updateduser?: userUpdateOneWithoutUpdatedrolesNestedInput
    rolepermissions?: rolepermissionUpdateManyWithoutRoleNestedInput
    userroles?: userroleUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateWithoutCreateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issystemrole?: BoolFieldUpdateOperationsInput | boolean
    rolepermissions?: rolepermissionUncheckedUpdateManyWithoutRoleNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateManyWithoutCreateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issystemrole?: BoolFieldUpdateOperationsInput | boolean
  }

  export type roleUpdateWithoutUpdateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issystemrole?: BoolFieldUpdateOperationsInput | boolean
    createduser?: userUpdateOneRequiredWithoutCreatedrolesNestedInput
    rolepermissions?: rolepermissionUpdateManyWithoutRoleNestedInput
    userroles?: userroleUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateWithoutUpdateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issystemrole?: BoolFieldUpdateOperationsInput | boolean
    rolepermissions?: rolepermissionUncheckedUpdateManyWithoutRoleNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateManyWithoutUpdateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issystemrole?: BoolFieldUpdateOperationsInput | boolean
  }

  export type rolepermissionUpdateWithoutCreateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permission?: permissionUpdateOneRequiredWithoutRolepermissionsNestedInput
    role?: roleUpdateOneRequiredWithoutRolepermissionsNestedInput
    updateduser?: userUpdateOneWithoutUpdatedrolepermissionsNestedInput
  }

  export type rolepermissionUncheckedUpdateWithoutCreateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleid?: StringFieldUpdateOperationsInput | string
    permissionid?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolepermissionUncheckedUpdateManyWithoutCreateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleid?: StringFieldUpdateOperationsInput | string
    permissionid?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolepermissionUpdateWithoutUpdateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createduser?: userUpdateOneRequiredWithoutCreatedrolepermissionsNestedInput
    permission?: permissionUpdateOneRequiredWithoutRolepermissionsNestedInput
    role?: roleUpdateOneRequiredWithoutRolepermissionsNestedInput
  }

  export type rolepermissionUncheckedUpdateWithoutUpdateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleid?: StringFieldUpdateOperationsInput | string
    permissionid?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolepermissionUncheckedUpdateManyWithoutUpdateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleid?: StringFieldUpdateOperationsInput | string
    permissionid?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userUpdateWithoutCreateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutCreateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateManyWithoutCreateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type userUpdateWithoutUpdateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    plan?: planUpdateOneWithoutUsersNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUpdateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateManyWithoutUpdateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type userpermissionUpdateWithoutCreateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permission?: permissionUpdateOneRequiredWithoutUserpermissionsNestedInput
    updateduser?: userUpdateOneWithoutUpdateduserpermissionsNestedInput
    user?: userUpdateOneRequiredWithoutUserpermissionsNestedInput
  }

  export type userpermissionUncheckedUpdateWithoutCreateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    permissionid?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userpermissionUncheckedUpdateManyWithoutCreateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    permissionid?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userpermissionUpdateWithoutUpdateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createduser?: userUpdateOneRequiredWithoutCreateduserpermissionsNestedInput
    permission?: permissionUpdateOneRequiredWithoutUserpermissionsNestedInput
    user?: userUpdateOneRequiredWithoutUserpermissionsNestedInput
  }

  export type userpermissionUncheckedUpdateWithoutUpdateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    permissionid?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userpermissionUncheckedUpdateManyWithoutUpdateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    permissionid?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userpermissionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createduser?: userUpdateOneRequiredWithoutCreateduserpermissionsNestedInput
    permission?: permissionUpdateOneRequiredWithoutUserpermissionsNestedInput
    updateduser?: userUpdateOneWithoutUpdateduserpermissionsNestedInput
  }

  export type userpermissionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionid?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userpermissionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionid?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userroleUpdateWithoutCreateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: roleUpdateOneRequiredWithoutUserrolesNestedInput
    updateduser?: userUpdateOneWithoutUpdateduserrolesNestedInput
    user?: userUpdateOneRequiredWithoutUserrolesNestedInput
  }

  export type userroleUncheckedUpdateWithoutCreateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    roleid?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userroleUncheckedUpdateManyWithoutCreateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    roleid?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userroleUpdateWithoutUpdateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createduser?: userUpdateOneRequiredWithoutCreateduserrolesNestedInput
    role?: roleUpdateOneRequiredWithoutUserrolesNestedInput
    user?: userUpdateOneRequiredWithoutUserrolesNestedInput
  }

  export type userroleUncheckedUpdateWithoutUpdateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    roleid?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userroleUncheckedUpdateManyWithoutUpdateduserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    roleid?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userroleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createduser?: userUpdateOneRequiredWithoutCreateduserrolesNestedInput
    role?: roleUpdateOneRequiredWithoutUserrolesNestedInput
    updateduser?: userUpdateOneWithoutUpdateduserrolesNestedInput
  }

  export type userroleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleid?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userroleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleid?: StringFieldUpdateOperationsInput | string
    createdby?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subscriptionCreateManyPlanInput = {
    id?: string
    userId: string
    stripeId?: string | null
    status?: string
    startedat?: Date | string
    endedat?: Date | string | null
    canceledat?: Date | string | null
  }

  export type userCreateManyPlanInput = {
    id?: string
    firstname: string
    lastname: string
    email: string
    password: string
    companyName?: string | null
    companyLogoUrl?: string | null
    taxId?: string | null
    address?: string | null
    phone?: string | null
    createdat?: Date | string
    createdby: string
    updatedat?: Date | string | null
    updatedby?: string | null
    status?: boolean
  }

  export type subscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedat?: DateTimeFieldUpdateOperationsInput | Date | string
    endedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type subscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedat?: DateTimeFieldUpdateOperationsInput | Date | string
    endedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    startedat?: DateTimeFieldUpdateOperationsInput | Date | string
    endedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUpdateManyWithoutUserNestedInput
    customers?: customerUpdateManyWithoutUserNestedInput
    parameters?: parametersUpdateManyWithoutUserNestedInput
    entrances?: entranceUpdateManyWithoutUserNestedInput
    payments?: paymentUpdateManyWithoutUserNestedInput
    transactions?: transactionUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUpdateManyWithoutUserNestedInput
    createdroles?: roleUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUpdateManyWithoutUpdateduserNestedInput
    createduser?: userUpdateOneRequiredWithoutCreatedusersNestedInput
    createdusers?: userUpdateManyWithoutCreateduserNestedInput
    updateduser?: userUpdateOneWithoutUpdatedusersNestedInput
    updatedusers?: userUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    invoices?: invoiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    customers?: customerUncheckedUpdateManyWithoutUserNestedInput
    parameters?: parametersUncheckedUpdateManyWithoutUserNestedInput
    entrances?: entranceUncheckedUpdateManyWithoutUserNestedInput
    payments?: paymentUncheckedUpdateManyWithoutUserNestedInput
    transactions?: transactionUncheckedUpdateManyWithoutUserNestedInput
    notificationuser?: notificationUncheckedUpdateManyWithoutToNestedInput
    createdapiclients?: apiclientUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedapiclients?: apiclientUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdpermissions?: permissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedpermissions?: permissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    refreshtokens?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    createdroles?: roleUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedroles?: roleUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdrolepermissions?: rolepermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedrolepermissions?: rolepermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    createdusers?: userUncheckedUpdateManyWithoutCreateduserNestedInput
    updatedusers?: userUncheckedUpdateManyWithoutUpdateduserNestedInput
    createduserpermissions?: userpermissionUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserpermissions?: userpermissionUncheckedUpdateManyWithoutUpdateduserNestedInput
    userpermissions?: userpermissionUncheckedUpdateManyWithoutUserNestedInput
    createduserroles?: userroleUncheckedUpdateManyWithoutCreateduserNestedInput
    updateduserroles?: userroleUncheckedUpdateManyWithoutUpdateduserNestedInput
    userroles?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companyLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    createdby?: StringFieldUpdateOperationsInput | string
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedby?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type invoiceCreateManyCustomerInput = {
    id?: string
    title: string
    description?: string | null
    amount: number
    userId: string
    createdat?: Date | string
    status?: string
  }

  export type invoiceUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    user?: userUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: paymentUpdateManyWithoutInvoiceNestedInput
  }

  export type invoiceUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    payments?: paymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type invoiceUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type paymentCreateManyInvoiceInput = {
    id?: string
    userId: string
    amount: string
    currency: string
    stripeId?: string | null
    status?: string
    createdat?: Date | string
  }

  export type paymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type paymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    stripeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}